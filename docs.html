<?xml version="1.0" encoding="UTF-8"?><html xmlns="http://www.w3.org/1999/xhtml" class="no-js" lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <meta charset="utf-8" />
      <meta generator="SAXONHE 9.6.0.1" />
      <title>XML workflow documentation</title>
      <link rel="stylesheet" href="css/pm-style.css" />
      <link rel="stylesheet" href="css/paged-media.css" />
      <link rel="stylesheet" href="css/styles/github.css" /><script src="lib/highlight.pack.js"></script><script>
          hljs.initHighlighting();
        </script></head>
   <body data-type="book">
      <section data-type="titlepage">
         <h1 id="d2e2">XML workflow documentation</h1>
         <h2 class="author">Carlos Araya</h2>
      </section>
      <section data-type="toc">
         <h1>Table of Contents</h1>
         <nav>
            <ol>
               <li><a href="#d2e12">Thank You</a></li>
               <li><a href="#d2e17">Background: HTML is the final format</a></li>
               <li><a href="#d2e181">Multi platform books from a single source</a></li>
               <li><a href="#d2e432">Introduction</a></li>
               <li><a href="#d2e478">The XML Schema</a></li>
               <li><a href="#d2e970">Converting XML content to HTML</a></li>
               <li><a href="#d2e1487">From XML to PDF: Part 1: Special Transformation</a></li>
               <li><a href="#d2e1595">From XML to PDF Part 2: CSS Paged Media</a></li>
               <li><a href="#d2e1731">From XML to PDF Part 3: CSS Styles for Paged Media</a></li>
               <li><a href="#d2e1943">Converting to ePub</a></li>
               <li><a href="#d2e1959">Tools and dependencies</a></li>
               <li><a href="#d2e2250">Ideas and outstanding items</a></li>
            </ol>
         </nav>
      </section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="dedication" epub:type="dedication">
         <p class="rh">Thank You</p>
         <h1 id="d2e12">Thank You</h1>
         <p>Thanks to Laura Brady for getting this particular idea started :)
            
         </p>
      </section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="chapter" epub:type="chapter">
         <p class="rh">Background: HTML is the final format</p>
         <h1 id="d2e17">Background: HTML is the final format</h1>
         <p>In researching the technologies and tools that I use when developing digital content
            I've come across multiple discussions about what's the best way to create HTML for
            X application (ebooks, web, transforming into other formats and any number of ideas.
            Some people think that HTML is perfect for everyone to write, regardless of experience
            and comfort with the technology. We forget that HTML now is very different to HTML
            as it was originally created.
         </p>
         <blockquote>
            <p>HTML —which is short for HyperText Markup Language— is the official language of the
               World Wide Web and was first conceived in 1990. HTML is a product of SGML (Standard
               Generalized Markup Language) which is a complex, technical specification describing
               markup languages, especially those used in electronic document exchange, document
               management, and document publishing. HTML was originally created to allow those who
               were not specialized in SGML to publish and exchange scientific and other technical
               documents. HTML especially facilitated this exchange by incorporating the ability
               to link documents electronically using hyperlinks.
               
            </p><cite>
               <p>From:
                  <a href="http://www.ironspider.ca/webdesign101/htmlhistory.htm" label="http://www.ironspider.ca/webdesign101/htmlhistory.htm">http://www.ironspider.ca/webdesign101/htmlhistory.htm</a></p></cite></blockquote>
         <p>The biggest issue, in my opinion, is that HTML has become a lot more complicated than
            the initial design. Creating HTML content (particularly when used in conjunction with
            CSS frameworks like Bootstrap or Zurb or with applications that use additional semantic
            elements like ePub) takes a lot more than just knowing markup to code them correctly.
            It takes knowledge of the document structure, the semantics needed for the content
            or the applications we are creating and the restrictions and schemas that we need
            to use so that the content will pass validation.
         </p>
         <p>This article presents 4 different approaches to creating HTML. Two of them use HTML
            directly but target it as the final output for transformations and templating engines;
            the other two use markup like HTML without requiring strict HTML conformance. I've
            made these selections for two reasons:
         </p>
         <ul>
            <li>People who are not profesionals should not have to learn all the details of creating
               an ePub3 table of content or know the classes to add to elements to create a Bootsrap
               or Foundation layout grid
            </li>
            <li>It makes it easier for developers and designers to build the layout for the content
               without having to worry about the content itself; we can play with layout and content
               organization in parallel with content creation and, if we need to make any further
               changes, we just run our compilation process again
            </li>
         </ul>
         <h2>Markdown</h2>
         <p>Perhaps the simplest solution when moving content from text to HTML is Markdown.
            
         </p>
         <p><a href="http://daringfireball.net/projects/markdown/" label="Markdown">Markdown</a>is a text to (X)HTML conversion tool designed for writers. It refers both to the syntax
            used in the Markdown text files and the applications used to perform the conversion.
         </p>
         <p>Markdown language was created in 2004 by John Gruber with the goal of allowing people
            "to write using an easy-to-read, easy-to-write plain text format, and optionally convert
            it to structurally valid XHTML (or HTML)" (
            <a href="http://daringfireball.net/projects/markdown/" label="http://daringfireball.net/projects/markdown/">http://daringfireball.net/projects/markdown/</a>)
         </p>
         <p>The language was designed to be readable as-is, without all the additional tags and
            attributes that makes it possible to covert markdown to languages like SGML, XML and
            HTML. Markdown is a formatting syntax for text that can be read by humans and can
            be easily converted to HTML.
            
         </p>
         <p>The original implementation of Markdown is
            <a href="http://search.cpan.org/~sekimura/Text-Markdown-Discount-0.11/xt/MarkdownXS.pl" label="markdown.pl">markdown.pl</a>and has been implemented in several other languages as applications (Ruby Gems, NodeJS
            modules and Python packages). All versions of Markdown are distributed under open
            source licenses and are included or available as a plugin for, several content-management
            systems and text editors.
         </p>
         <p>Sites such as GitHub, Reddit, Diaspora, Stack Overflow, OpenStreetMap, and SourceForge
            use variants of Markdown to facilitate content creation and discussion between users.
         </p>
         <p>The biggest weakness of Markdown is the lack of a unified standard. The original Markdown
            language hasn't been really supported since it was released in 2004 and all new version
            of Markdown, both parser and language specification have introduced not wholy compatible
            changes to Markdown. The lack of standard is also Markdown’s biggest strength. It
            means you can, like Github did, implement your own extensions to the Markdown syntax
            to acommodate your needs.
         </p>
         <p>Markdown is not easy to learn but once your fingers get used to the way we type the
            different elements it becomes much easier to work with as it is nothing more than
            inserting specific characters in a specific order to obtain the desired effect. Once
            you train yourself, it is also easy to read without having to convert it to HTML or
            any other language.
         </p>
         <p>Most modern text editors have support for Markdown either as part of the default installation
            or through plugins.
         </p>
         <h3>Example Markdown document</h3>
         <ul>
            <li><a href="http://daringfireball.net/projects/markdown/index.text" label="Markdown example form daringfireball">Markdown example form daringfireball</a></li>
         </ul>
         <h2>Asciidoctor</h2>
         <p>I only discovered Asciidoctor recently, while researching O'Reilly Media's publishing
            toolchains. It caught my attention because of it's structure, the expresiveness of
            the markup without being HTML like HTMLbook and the extensibility of the templating
            system that it uses behind the scenes.
         </p>
         <p>Asciidoctor has both a command line interface (CLI) and an API. The CLI is a drop-in
            replacement for the
            <em>asciidoc</em> command from the Standard python distribution. This means that you have a command
            line tool
            <em>asciidoctor</em> that will allow you to convert your marked documents without having to resort to
            a full blown application.
            
         </p>
         <p>Syntax-wise, Asciidoctor is progressively more complex as you implement more advanced
            features. In the first example below no tables are used, for example. Tables are used
            in the second and thirs examples both as data tables and for layout.
         </p>
         <p>The
            <a href="documentation" label="http://asciidoctor.org/docs/">http://asciidoctor.org/docs/</a> provides more detailed instructions for the desired markup.
         </p>
         <h3>Example Asciidoc documents</h3>
         <ul>
            <li><a href="https://raw.githubusercontent.com/asciidoctor/asciidoctor-documentation/master/infrastructure-goals-planning.adoc" label="Asciidoctor planning document">Asciidoctor planning document</a></li>
            <li><a href="https://raw.githubusercontent.com/asciidoctor/asciidoctor-documentation/master/infrastructure-goals-planning.adoc" label="Comparison of Asciidoctor and AsciiDoc Features">Comparison of Asciidoctor and AsciiDoc Features</a></li>
            <li><a href="https://raw.githubusercontent.com/asciidoctor/asciidoctor.org/master/docs/_includes/apply-theme.adoc" label="Applying Custom Themes">Applying Custom Themes</a></li>
         </ul>
         <h2>HTMLBook</h2>
         <p>O'Reilly Media has developed several new tools to get content from authors to readers.
            Atlas is their authoring tool, a web based application that allows you to create content
            they developed HTMLbook, a subset of HTML geared towards authoring and multi format
            publishing.
         </p>
         <p>Given O'Reilly's history and association with open source publishing tools (they were
            an early adopter and promoter of Docbook and still use it for some of their publications)
            I found HTMLbook intriguing but not something to look at right away, as with many
            things you leave for later it fell off my radar.
         </p>
         <p>It wasn't until I saw Sanders Kleinfeld's (O'Reilly Media Director of Publishing Technologies)
            <a href="http://www.slideshare.net/sanderskleinfeld/open-source-forpubsslideshare" label="presentation at IDPF Book World conference">presentation at IDPF Book World conference</a> that I decided to take a second look at HTMLbook and its ecosystem.
         </p>
         <p>Conceptually HTMLbook is very simple; it combines a subset of HTML5, the semantic
            structure of ePub documents and other IDPF specifications to create a flavor of HTML
            5 that is designed specifically for publishing. There are also stylesheets that will
            allow you to convert Markdown and other text formats into HTMLbook (see
            <a href="https://github.com/oreillymedia/htmlbook.js" label="Markdown to HTMLBook">Markdown to HTMLBook</a> and
            <a href="https://github.com/oreillymedia/asciidoctor-htmlbook/" label="AsciiDoc to HTMLBook (via AsciiDoctor)">AsciiDoc to HTMLBook (via AsciiDoctor)</a>)
         </p>
         <p>If you use Atlas (O'Reilly's authoring and publishing platform) you don't have to
            worry about markup as the content is created visually. The challenges begin when implementing
            this vocabulary outside the Atlas environment.
            
         </p>
         <p>The project comes with a set of stylesheets to convert HTMLbook content to ePub, MOBI
            and PDF. The intriguing thing about the stylesheets is that they use CSS Paged Media
            stylesheets in conjunction with third party tools such as
            <a href="http://www.antennahouse.com" label="AntennaHouse">AntennaHouse</a> or
            <a href="http://www.princexml.com/" label="PrinceXML">PrinceXML</a>.
         </p>
         <p>The open source solutions offer permisive licenses that allow modification and integration
            into other products without requiring you to release your project under the same license
            like GPL and LGPL.
         </p>
         <p>As with any solution that advocates creating HTML directly I have my reservations.
            In HTML formating in general and specialized formats like HTMLbooks in particular,
            the learning curve may be too steep for independent authors to use for creating content.
         </p>
         <p>The user must learn not only the required HTML5 syntax but also the details regarding
            ePub semantic structure attributes and the other standards needed to create ePub books.
            While I understand that technologies such as this are not meant for independent authors
            or for poeple who are not comfortable or familiar with HTML but the learning curve
            may still be too steep for most users.
         </p>
         <h3>Example HTMLbook document</h3>
         <ul>
            <li><a href="https://github.com/oreillymedia/HTMLBook/blob/master/samples/alices_adventures_in_wonderland.html" label="Alice Adventures in Wonderland marked as HTMLbook">Alice Adventures in Wonderland marked as HTMLbook</a></li>
         </ul>
         <h2>XML / XSLT</h2>
         <p>Perhaps the oldest solutions in the book to create HTML without actually creating
            HTML are XML-based. Docbook, TEI and DITA all have stylesheets that will take the
            XML content and convert it to HTML, PDF, ePub and other more esoteric formats.
         </p>
         <p>In addition to stylesheets already available developers can create their own to adress
            specific needs.
         </p>
         <p>Furthermore, tools like OxygenXML Author (and I would assume other tools in the same
            category have a visual mode that allow users to write XML content, validated against
            a schema in a way that is more familiar to people not used to creating content with
            raw XML tools.
         </p>
         <p>The issues with xml are similar to those involved in creating HTML. The markup vocabulary
            requires brackets, attributes have to be enclosed in quotation marks and generall
            the syntax is as complicated as you make it. However, tools like Oxygen and smilar
            help alleviate this problem but don't resolve it completely.
         </p>
         <p>The screenshot below shows OxygenXML Author working in a Docbook 5 document using
            visual mode.
         </p>
         <figure width="280px" height="177px"><img src="images/visual-editing-mode-small.png" alt="Visual Editing Using OxygenXML Author" width="280px" height="177px" /><figcaption>
               <p>OxygenXML Visual Editor for XML</p>
            </figcaption>
         </figure>
         <p>The positive side is that using XSLT there is no limit to what we can do with our
            XML content.
         </p>
         <h3>XML examples</h3>
         <ul>
            <li><a href="https://github.com/oreillymedia/docbook_samples/blob/master/ch01.xml" label="Sample Chapter marked as Docbook">Sample Chapter marked as Docbook</a></li>
            <li><a href="http://docsouth.unc.edu/southlit/poe/poe.xml" label="Tales by Edgar Allan Poe, marked as TEI">Tales by Edgar Allan Poe, marked as TEI</a></li>
            <li><a href="http://sourceforge.net/p/dita2indesign/code/HEAD/tree/trunk/dita_gutenberg_samples/dita_src/20000_leagues/chapters/d2e10630.xml" label="Chapter from 20000 Leagues Under the Sea, marked as DITA">Chapter from 20000 Leagues Under the Sea, marked as DITA</a></li>
         </ul>
         <h2>Conclusion</h2>
         <p>After exploring a selection of HTML conversion options the question becomes <strong><em>which one is best?</em></strong></p>
         <p>The answer is <strong><em>it depends</em></strong>.
         </p>
         <p>The best way to see how can these text-based tools can be incorporated is to ask yourself
            how much work you want to do in the backend versus how much work do you want you authors
            to do when creating the content. This is where the value of specialists in digital
            formats and publishing becomes essential, we can work with clients in providing the
            best solution to meet their needs.
         </p>
         <p>Keep in mind who your audience and what the target vocabulary you're working towards,
            it will dictate what your best strategy is. Are these all the solutions; definitely
            not. Other solutions may appear that fit your needs better than those presented here;
            I would love to hear if that is the case.
         </p>
         <p>Striking the balance between author and publisher is a delicate one. I tend to fall
            on the side of making things easier for authors... The tools can be made to translate
            basic markup into the desired result with minimal requirements for authors to mark
            up the content; the same can't necessarily be said about the publisher-first strategy
         </p>
      </section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="chapter" epub:type="chapter">
         <p class="rh">Multi platform books from a single source</p>
         <h1 id="d2e181">Multi platform books from a single source</h1>
         <p>The formats chosen for this project (HTML, PDF and ePub) were not selected at random.
            I'm following Craig Mod's model as outlined in
            <a href="http://craigmod.com/journal/platforming_books/" label="Platforming Books">Platforming Books</a> with my own ideas of what we need to produce.
         </p>
         <p>The formats are:</p>
         <ul>
            <li>(X)HTML Apps</li>
            <li>PDF</li>
            <li>ePub3</li>
            <li>iBooks</li>
            <li>Kindle</li>
         </ul>
         <p>We'll discuss the rationale for each format, what this project is not, and what we
            can do moving forward and answer the most important question:
            <em>Why should I buy the book if I can get it for free?</em></p>
         <h2>(X)HTML</h2>
         <p>rome 16:&lt;/para&gt;
            &lt;code language="html"&gt;&amp;lt;html class="js flexbox canvas canvastext webgl no-touch
            geolocation postmessage websqldatabase indexeddb hashchange history draganddrop websockets
            rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow
            opacity cssanimations c and related books in both Amazon and iBookstore) and samples
            of the content. I know that, as a reader, I want more than 30 pages of the book (not
            necessarily 30 pages of content, most of the time the samples include cover, metadata
            and table of contents.)
         </p>
         <p>We should not depend on devices to create the rich annotation corpus like the one
            Amazon makes public on their
            <a href="https://kindle.amazon.com/" label="Kindle Website">Kindle Website</a>. While the alternative suggested here is a partial solution (and its implementation
            is currently under development) it works everywhere there is a web browser and an
            internet connection.
         </p>
         <p>Perhaps the greatest bennefit of an open web publishing solution is its flexibility.
            Solutions like Emphasis, Annotator and Highlight.Js work with HTML, CSS and Javascript/jQuery
            just like any other websites. There is no reason why we can continue to play and expand
            our XHTML playground with technologies like
            <a href="http://www.wikiwand.com/en/WebGL" label="WebGL">WebGL</a>/
            <a href="http://webvr.info/" label="WebVR">WebVR</a>,
            <a href="http://d3js.org/" label="D3">D3</a>,
            <a href="https://robots.thoughtbot.com/css-animation-for-beginners" label="CSS animations">CSS animations</a> and just about any other web technology. Once we know they work on the web we can
            try them inn ePub books and see how well they work on what devices.
         </p>
         <h3>Technologies implemented</h3>
         <p>These are the technologies currently configured to work with the XHTML format.</p>
         <h4>Emphasis</h4>
         <p><a href="http://open.blogs.nytimes.com/2011/01/11/emphasis-update-and-source/" label="Emphasis">Emphasis</a> is a deep linking library first developed and released by the New York Times in 2011.
            What attracted me to it was the ability to share (deep) links to an article among
            people at different computers. The algorythm always returns the same result so the
            links will always work the same.
         </p>
         <p>The one thing that pushed me away from Emphasis was its dependency on jQuery. Don't
            get me wrong; I love jQuery but I need a good reason to use it beyond the cool factor
            since most, if not all, of the things you can do with jQuery you can do with vanilla
            Javascript in modern browsers.
         </p>
         <p>I decided the bennefits of link sharng far outweigh the jQuery dependency but, when
            I went to update the code I discovered that the library no longer requires jQuery
            :-)
         </p>
         <p>The idea behind Emphasis is that when you highlight a paragraph or portion thereof,
            it will generate a unique string and append it to the page's URL. You can then send
            the URL to a friend or colleague who can paste the URL and open the page with the
            highlighted text. In combination with something like Annotator.js we can build a more
            complex system to create shareable links .
         </p>
         <h4>Annotator.js</h4>
         <p>Some times the deel links from emphasis are not enough. Tool
            <a href="http://annotatorjs.org/" label="Annotator.js">Annotator.js</a> provide one open web answer to Kindle community annotations. While we can't do this
            from an ePub or Kindle we can use in in an open web application.
         </p>
         <p>I've said it before: I love the way Amazon shares the annotations I make in my Kindle
            but there's one down side, it only gives you the quotation, not the context in which
            it happens or provide a way for public sharing of the annotations with people who
            don't own the Kindle edition of the book.
         </p>
         <p>Annotator makes all annotations public so other people can read them and further comment
            on the same text or other comments. It uses a third party backend (
            <a href="http://annotateit.org/" label="annotateit.org">annotateit.org</a>) to provide a consistent experience for all our users regardless of browser version
            or operating system.
         </p>
         <p>Annotator.js requires jQuery to run and
            <a href="https://github.com/showdownjs/showdown" label="Showdown.js">Showdown.js</a> to support Markdown in the annotations.
         </p>
         <p>Once jQuery and Showdown are installed, installing the annotator is as simple as the
            following code:
         </p><pre><code class="javascript hljs">
jQuery(function ($) {
  $('section').annotator() //section is the root of our content
  .annotator('setupPlugins');
});
// Fully worked authentication example to follow
    </code></pre><h4>Highlight.js</h4>
         <p>A lot of what I write is technical material with lots of code examples. Rather than
            highlight code or lines by hand (possible but really complicated), I've always used
            code highlighters. For Wordpress posts I use the Syntax Highlighter plugin and for
            open web and PDF I use
            <a href="https://highlightjs.org/" label="highlight.js">highlight.js</a>.
         </p>
         <p>Highlight.js supports a lot of languages and styles out of the box (I use one style
            for XHTML and a different one for PDF that should make it easier to print) but the
            idea remains the same: to make the code easier to understand by highlighting different
            areas of the code with different colors based on structure.
         </p>
         <p>Perhaps the only downside of Highlight.js is the fact that the Javascript portion
            of the utility must crawl through every code block in the application; the more code
            blocks in a page the bigger the potential for slowness. This has to be part of any
            testing done to measure application performance and functionality.
         </p>
         <p>Running highlight.js is simple. Run the following on your page:</p><pre><code class="javascript hljs">
&lt;script src="js/object-key-polyfill.js"/&gt;
&lt;script src="lib/highlight.pack.js"/&gt;
&lt;script&gt;
  hljs.initHighlighting();
&lt;/script&gt;
    </code></pre><p><em>object-key-polyfill.js</em> polyfills a feature to make sure it works with older browsers (and PrinceXML.)
         </p>
         <h4>Modernizr</h4>
         <p>Not all browser vendors support the same technology or support it the same way. Modernizr
            takes a two prong approach to testing for feature support:
         </p>
         <ul>
            <li>It creates a JavaScript global object (named Modernizr) that contains the results
               of these tests as boolean properties
            </li>
            <li>It adds classes to the html element that explain what features are and are not natively
               supported
            </li>
            <li>It provides a script loader so you can pull in polyfills to backfill functionality
               in old browsers
            </li>
         </ul>
         <p>The classes added to the HTML element in Chrome 41:</p><pre><code class="html hljs">&lt;html class=" js flexbox canvas canvastext webgl no-touch geolocation postmessage websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths no-display-runin display-table pointerevents cssfilters supports" lang="en"&gt;</code></pre><p>The supported elements in Firefox 38.0a2:</p><pre><code class="html hljs">&lt;html class=" js flexbox canvas canvastext webgl no-touch geolocation postmessage no-websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients no-cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths no-display-runin display-table pointerevents cssfilters supports" lang="en"&gt;</code></pre><p>The classes added to the HTML element look like this in Chrome 16:</p><pre><code class="html hljs">&lt;rials"
       /&gt; on how to script PDF files but the emphasis and the functionality is geared towards business automation rather than full interactivity.&lt;/para&gt;

    &lt;h4&gt;PDF Bookmarks&lt;/h4&gt;

    &lt;para&gt;I've chosen to let the CSS Paged Media transformatio csscolumns cssgradients cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths"&gt;</code></pre><p>And the support for IE9 looks like this:</p><pre><code class="html hljs">&lt;html class="js no-flexbox canvas canvastext no-webgl no-touch geolocation postmessage no-websqldatabase no-indexeddb hashchange no-history draganddrop no-websockets rgba hsla multiplebgs backgroundsize no-borderimage borderradius boxshadow no-textshadow opacity no-cssanimations no-csscolumns no-cssgradients no-cssreflections csstransforms no-csstransforms3d no-csstransitions fontface generatedcontent video audio localstorage sessionstorage no-webworkers no-applicationcache svg inlinesvg smil svgclippaths"&gt;</code></pre><p>The CSS feature detection uses the classes defined in the HTML element to match whether
            a feature is supported or not. For example we can use the following selectors to test
            if audio is supported:
         </p><pre><code class="css hljs">
/* In your CSS: */
.no-audio #music {
   display: none; /* Don't show Audio options */
}
.audio #music button {
   /* Style the Play and Pause buttons nicely */
}
    </code></pre><p>The Javascript detection strategy takes advantage of the Modernizr object created
            when the page was loaded to test if a feature is available or not. We can test for
            audio using Javascript with code like below:
         </p><pre><code class="javascript hljs">
if (Modernizr.audio) {
     /* properties for browsers that
     support audio */
}else{
     /* properties for browsers that
     does not support audio */
}
    </code></pre><p><strong>Modernizr.load()</strong> uses Modernizr's Javascript test to load resources only if the tested feature is
            supported. In the example below we test if audio is supported: If the audio element
            is supported then we load
            <em>audio.js</em> with all our awesome HTML5 audio functions and tools. Otherwise we write a message
            to the #notice element already in the page.
         </p><pre><code class="javascript hljs">
Modernizr.load({
  test: Modernizr.audio,
  yep : 'audio.js',
  nope: 'audio-polyfill.js'
});
    </code></pre><p>For a more detailed tutorial check: This
            <a href="http://www.tutorialspoint.com/html5/html5_modernizr.htm" label="tutorial">tutorial</a>.
         </p>
         <h4>Stay in Web App</h4>
         <p>A trick for iOS,
            <a href="https://github.com/mrmoses/jQuery.stayInWebApp" label="jQuery.stayInWebApp">jQuery.stayInWebApp</a> keeps local, relative URLs from braking out the iOS full screen, no toolbar, web
            application.
         </p>
         <p>Once the plugin is loaded (normally at the bottom of the document, right before the
            closing body tag) initializing it is very simple
         </p><pre><code class="jquery hljs">
$(function() {
    $.stayInWebApp();
});
    </code></pre><p>We can also choose to only keep some links (for example, links with a certain class)
            local. To keep links witha class of local from breaking the app we can use something
            like this:
         </p><pre><code class="javascript hljs">
$(function() {
  $.stayInWebApp('a.local');
});

    </code></pre><p>Links starting with http will always open in Safari.</p>
         <h4>iOS icons and splash screens</h4>
         <p>When iOS was first introduced one of the features that first caught my attention was
            the ability to save web sites to the home screen and use them as an online-only web
            application. I always thought that it was something only full applications or apps
            from larger companies could do. It wasn't until I read the
            <a href="https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html" label="Configuring Web Applications">Configuring Web Applications</a> section of the Safari Web Content Guide that I realized that it was hard work but
            it was doable by anyone.
         </p>
         <p>We add the following elements to the head of our content page (not 100% sure if this
            is for every page or only for the index). The first set of resources deal with fixing
            the width of the device to a 1 to 1 scale window, full screen and no app bar at the
            top of the application.
         </p><pre><code class="html hljs">
  &lt;meta name="viewport" content="user-scalable=no, initial-scale=1.0" /&gt;
  &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;
  &lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt;
    </code></pre><p>The second block adds the application icons that will appear in the home screen when
            we add the site/app. We have to add multiple icons to account for different screen
            size/resolution/DPI combinations available to different devices.
         </p><pre><code class="html hljs">
  &lt;!-- iOS ICONS AND START SCREENS --&gt;
  &lt;link rel="apple-touch-icon" href="/images/misc/apple-touch-icon-57x57.png" /&gt;
  &lt;link rel="apple-touch-icon" sizes="72x72" href="/images/misc/apple-touch-icon-72x72.png" /&gt;
  &lt;link rel="apple-touch-icon" sizes="114x114" href="/images/misc/apple-touch-icon-114x114.png" /&gt;
    </code></pre><p>The final step is to add the spalsh screen s that will appear while the site is loading.
            As with the icons, we have to account for different size/resolution/DPI combinations
            for different devices.
         </p><pre><code class="html hljs">
  &lt;!-- iPhone/iPod Touch Portrait – 320 x 460 (standard resolution) --&gt;
  &lt;!-- These are not all available resolutions, do your homework --&gt;
  &lt;link rel="apple-touch-startup-image" href="/images/misc/splash-screen-320x460.png" media="screen and (max-device-width: 320px)" /&gt;

  &lt;!-- For iPad Landscape 1024x748 --&gt;
  &lt;link rel="apple-touch-startup-image" sizes="1024x748" href="/images/misc/splash-screen-1024x748.png" media="screen and (min-device-width: 481px) and (max-device-width: 1024px) and (orientation:landscape)" /&gt;

  &lt;!-- For iPad Portrait 768x1004 (high-resolution) --&gt;
  &lt;link rel="apple-touch-startup-image" sizes="1536x2008" href="/images/misc/splash-screen-1536x2008.png" media="screen and (min-device-width: 481px) and (max-device-width: 1024px) and (orientation:portrait) and (-webkit-min-device-pixel-ratio: 2)"/&gt;
    </code></pre><h4>Windows8 application tiles</h4>
         <p>Windows 8 (in tablets and phones) allows applications to be tiled on the start screen.
            We can take advantage of this feature by going to
            <a href="http://www.buildmypinnedsite.com/en" label="buildmypinnedsite.com">buildmypinnedsite.com</a> completing the form and download the resulting kit. We can the paste the code below
            on the head of our pages and upload the associated images to the server.
         </p><pre><code class="html hljs">
 &lt;-- Windows 8+ tile stuff -- Assumes all content is uploaded to server --&gt;
    &lt;meta name="application-name" content="My Awesome Site"/&gt;
    &lt;meta name="msapplication-TileColor" content="#e809e8"/&gt;
    &lt;meta name="msapplication-square70x70logo" content="tiny.png"/&gt;
    &lt;meta name="msapplication-square150x150logo" content="square.png"/&gt;
    &lt;meta name="msapplication-wide310x150logo" content="wide.png"/&gt;
    &lt;meta name="msapplication-square310x310logo" content="large.png"/&gt;
    </code></pre><h2>PDF</h2>
         <p>As explained elsewhere I've decided to create the PDF version of the file uing CSS
            paged media using XMLPrince rather than the more traditional (and cumbrsome) XSL-Formatting
            Objects tool chain. There are a variety of reasons why I chose to do this: chief among
            them are ease of use (I already know how to create HTML and CSS content and can leverage
            that knowledge to create as advanced a publication as I need
         </p>
         <h3>Technologies implemented</h3>
         <p>Out of necessity the PDF output is a lot simpler in terms of technologies and interactivity
            than the open web or ebook. There are
            <a href="http://www.pdfscripting.com/" label="Sites and tutorials">Sites and tutorials</a> on how to script PDF files but the emphasis and the functionality is geared towards
            business automation rather than full interactivity.
         </p>
         <h4>PDF Bookmarks</h4>
         <p>  &lt;h2&gt;Options for defining the markup&lt;/h2&gt;

            &lt;parn step generate the PDF bookmarks instead of trying to create them manually. Both
            PrinceXML and
            <a href="http://www.antennahouse.com/" label="AntennaHouse">AntennaHouse</a> provide prefixed selectors for PDF bookmark generation.
         </p>
         <p>We can tell the processor the level of the bookmark (using the same level as he headings),
            whether the bookmark is open or closed (if open they will show their children underneath)
            and what to use as the label (in this case we use the label of the associated heading
            elements).
         </p>
         <p>The code looks like this:</p><pre><code class="css hljs">
/* PDF BOOKMARKS */
section[data-type='chapter'] h1 {
  -ah-bookmark-level: 1;
  -ah-bookmark-state: open;
  -ah-bookmark-label: content();
  prince-bookmark-level: 1;
  prince-bookmark-state: open;
  prince-bookmark-label: content();
}

section[data-type='chapter'] h2 {
  -ah-bookmark-level: 2;
  -ah-bookmark-state: open;
  -ah-bookmark-label: content();
  prince-bookmark-level: 2;
  prince-bookmark-state: open;
  prince-bookmark-label: content();
}

section[data-type='chapter'] h3 {
  -ah-bookmark-level: 3;
  -ah-bookmark-state: open;
  -ah-bookmark-label: content();
  prince-bookmark-level: 3;
  prince-bookmark-state: open;
  prince-bookmark-label: content();
}

section[data-type='chapter'] h4 {
  -ah-bookmark-level: 4;
  prince-bookmark-level: 4;
}
    </code></pre><h4>Highlight.js</h4>
         <p>I use the same highlight.js library that I used in the XHTML files with the PDF content.
            The only difference is that we add an object-key polyfill to work around a lack of
            direct support of the feature in PrinceXML and will be removed at the time the feature
            is supported natively.
         </p>
         <p>Other than the object.key polyfill there are no additional changes to make the highlighter
            work in PDF.
         </p>
         <blockquote>
            <p>Note that highlight.js for PDF is currently not coloring the syntax. There seems to
               be an issue with the object.key polyfill that causes problems in longer files.
            </p>
         </blockquote>
         <h2>ePub3</h2>
         <p>ePub is a tricky proposition. While some readers like iBooks will support many multimedia
            features available in the open web others, particularly older, readers will not even
            support scripting or SVG. So the question becomes how much do we want to push the
            envelope in such an uncertain environment? How many levels of fallbacks fo we provide
            for a given technology?
         </p>
         <h3>Modernizr</h3>
         <p>Modernizr is one of the best solutions to tame the complexity conundrum. We can selectively
            (using either CSS or javascript) work around limited capabilities by testing for the
            presence of given elements or lack thereof. Using Javascript we can conditionally
            create DOM elements based on support (or lack thereof) for a given feature:
         </p><pre><code class="javascript hljs">
if (Modernizr.video) {
  var myVideo = document.createElement("video");
  // add the source attributes and their children (src and type)
} else {
  // Provide a fallback, possibly creating the object video programmatically
  var myVideo = document.createElement("object");
}
    </code></pre><p>Using CSS we can choose whether we want to show or hide the element in question. This
            is still dependent on Javasacript but it will work in more devices than just iBooks
            and will provide better alternatives where Javascript is available. The code looks
            something like this:
         </p><pre><code class="css hljs">
.no-video video {
  display:none
}

.video video {
  border: 1px solid $red;
}
    </code></pre><h4>Highlight.js</h4>
         <p>Even though our highlighter suffers from spotty Javascript support we can still enjoy
            some formatting even in browsers that don't support Javascript
         </p>
         <h2>Why would I buy the book if I can get it for free?</h2>
         <p>So now we come back to what, for me, is the central question: <em>Why would I buy the book if I can get it for free?</em></p>
         <p>The open web version (package of XHTML files</p>
      </section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="chapter" epub:type="chapter">
         <p class="rh">Introduction</p>
         <h1 id="d2e432">Introduction</h1>
         <p>One of the biggest limitations of markup languages, in my opinion, is how confining
            they are. Even large vocabularies like [Docbook](http://docbook.org) are limited in
            what they can do out of the box. HTML4 is non-extensible and HTML5 is limited in how
            you can extend it (web components are the only way to extend HTML5 I'm aware of that
            doesn't require an update to the HTML specification.)
         </p>
         <p>By creating our own markup vocabulary we can be as expressive as we need to be without
            adding additional complexity for writers and users and without adding unecessary complexity
            for the developers building the tools to interact with the markup.
         </p>
         <p>It has been suggested that
            <a href="http://johnmacfarlane.net/pandoc/" label="Pandoc">Pandoc</a> may be a better alternative than rolling your own markup and style sheet sets. While
            Pandoc is a very powerful tool it tries to do too much for too many. See the website
            for a list of formats Pandoc supports:
         </p>
         <p>My problems with Pandoc are:</p>
         <ul>
            <li>You can only convert your content to PDF if you have LaTex installed. Even a minimal
               LaTex library requires a fairly large install
            </li>
            <li>LaTex installs are different for Macintosh, Windows and Linux. This makes a uniform
               support system impossible
            </li>
            <li>If you want to add custom formats you have to do so in Lua. I'd rather not learn another
               programming language just for one project
            </li>
         </ul>
         <h2>Why create our own markup</h2>
         <p>Rather than figure out how to use someone else tool for this proof of concept I've
            decided to build my own markup vocabulary and explore XML, XSL and CSS as the tools
            to create HTML and print-ready content.
         </p>
         <p>Using XSL and CSS to manipulate XML content reduces the number of external dependencies.
            As it stands right now, the project depends on
            <a href="http://www.saxonica.com/welcome/welcome.xml" label="Saxon">Saxon</a> to convert XML to HTML and
            <a href="http://www.princexml.com/" label="PrinceXML">PrinceXML</a></p>
         <p>In creating your own xml-based markup you enforce separation of content and style.
            The XML document provides the basic content of the document and the hints to use elsewhere.
            XSLT stylesheets allow you to structure the base document and associated hints into
            any number of formats (for the purposes of this document we'll concentrate on XHTML,
            PDF created through Paged Media CSS and PDF created using XSL formatting Objects)
         </p>
         <p>It reduces the ammount of external code that we have to adapt in order to acomplish
            a given task.
         </p>
         <p>Creating a domain specific markup vocabulary allows you think about structure and
            complexity for yourself as the editor/typesetter and for your authors. It makes you
            think about elements and attributes and which one is better for the given experience
            you want and what, if any, restrictions you want to impose on your makeup.
         </p>
         <p>By creating our own vocabulary we make it easier for authors to write clean and simple
            content. XML provides a host of validation tools to enforce the structure and format
            of the XML document.
         </p>
         <h2>Options for defining the markup</h2>
         <p>For the purpose of this project we'll define a set of resources that work with a book
            structure like the one below:
         </p><pre><code class="xml hljs">&lt;book&gt;
  &lt;metadata&gt;
    &lt;title&gt;The adventures of SHerlock Holmes&lt;/title&gt;

    &lt;author&gt;
      &lt;first-name&gt;Arthur&lt;/first-name&gt;
      &lt;surname&gt;Connan Doyle&lt;/surname&gt;
    &lt;/author&gt;
  &lt;/metadata&gt;

  &lt;section type="chapter"&gt;
    &lt;para&gt;Lorem Ipsum&lt;/para&gt;
    &lt;para&gt;Lorem Ipsum&lt;/para&gt;
  &lt;/section&gt;
&lt;/book&gt;
    </code></pre><p>It is not a complete structure. We will continue adding elements afte we reach the
            MVP (Minimum Viable Product) stage. As usual, feedback is always appreciated.
         </p>
      </section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="chapter" epub:type="chapter">
         <p class="rh">The XML Schema</p>
         <h1 id="d2e478">The XML Schema</h1>
         <blockquote>
            <p>This version of the documentation is based on commit 542178fb21 to the Github repository.
               Any differences between this document and the repository should be resolved in favor
               of the repository (repo is always right)
            </p>
         </blockquote>
         <p>The idea behind the schema is to create as clean a document as possible. The base
            document uses classes and IDs to avoid having to add styles directy to the document
            and leaving all the styling to CSS. There are 2 exceptions for addresses (discussed
            when we look at the XML to XHTML conversion.)
         </p>
         <p>We cover all the content for the schema but will only detail the things I belive are
            important to understand the choices I made and why the schema was created this way.
         </p>
         <h2>Why a schema</h2>
         <p>There are many ways to define a schema. There is the original
            <a href="http://www.w3.org/XML/Schema" label="XML Schema">XML Schema</a> from W3C, there is RelaxNG developed by OASIS in a
            <a href="https://www.oasis-open.org/committees/relax-ng/" label="technical committee">technical committee</a> and
            <a href="http://www.schematron.com/" label="Schematron">Schematron</a> defined as an ISO standard.
         </p>
         <p>With all these choices why did I stick with Schema?</p>
         <ul>
            <li>It's the most widely supported</li>
            <li>It can be converted to RelaxNG or Schematron (an experimental conversion to RelaxNG
               is available in the rng directory of the repository)
            </li>
         </ul>
         <p>You can work with either the Schema or RelaxNG version. This document will refer to
            the Schema.
         </p>
         <h2>Getting started</h2>
         <p>As with all XML document the schema needs to define the XML Prologue (
            <em>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</em>), the root element (
            <em>&lt;xs:schema</em>), the namespaces we'll use for the project and the default forms for elements (
            <em>elementFormDefault="qualified"</em>) and attributes (
            <em>attributeFormDefault="unqualified"</em>`)
         </p><pre><code class="xml hljs">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    elementFormDefault="qualified"
    attributeFormDefault="unqualified"&gt;
</code></pre><p>Form defaults refer to whether we need to add the namespace prefix to our default
            elements. To avoid confusion I've chosen to add namespace prefixes to all our elements
            (using `xs:` as the namespace prefix for the schema name space.) Doing that for attributes
            is unnecessary; it may not always be the case.
         </p>
         <p>We begin the actual work in the schema by defining some basic types that will be the
            basis of elements and complex types later in the schema.
         </p>
         <p>Most of the simeType elements are created by restriction. We base the element in one
            of the default Schema data types.
         </p>
         <p>For example: token255 is based on the toke schema element and is restricted to a maximum
            length of 255 characters. When this length is not enough we can use strings or other
            data types.
         </p><pre><code class="xml hljs">&lt;!-- Simple types to use in the content --&gt;
&lt;xs:simpleType name="token255"&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:maxLength value="255"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
    </code></pre><p>ISBN-type10 uses string as its base and creates a regular expression to match the
            format of
            <a href="http://www.isbn.org/" label="ISBN">ISBN</a> codes used to identify books worldwide.
         </p>
         <p>The ISBN element only matches one format. There are many formats that could match
            an ISBN record depending on where the book was published and which country it was
            registered in. There is a simple type element for ISBN numbers worldwide available
            at
            <a href="http://xfront.com/isbn.html" label="XFront">XFront</a>. The code can be incorporated to the schema at a later time.
         </p><pre><code class="xml hljs">
&lt;xs:simpleType name="ISBN-type10"&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;xs:pattern value="0-[0-1][0-9]-\d{6}-[0-9x]"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
</code></pre><p>The align simple type is an enumeration. We list all the possible values for align
            attribute so we can reference them later without having to type them all the time.
         </p><pre><code class="xml hljs">
&lt;xs:simpleType name="align"&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:enumeration value="left"/&gt;
    &lt;xs:enumeration value="center"/&gt;
    &lt;xs:enumeration value="right"/&gt;
    &lt;xs:enumeration value="justify"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
</code></pre><p>Languages are handled using an element types as the language primitive (
            <em>xs:language</em>.) We can use it anywhere in the schema where we are allowed to use children elements.
         </p>
         <p>Another possibility is to convert it to an attribute and move it to the generic properties
            attribute group discussed below.
         </p><pre><code class="xml hljs">
&lt;xs:element name="language" type="xs:language"/&gt;
</code></pre><p>The attribute group element adds all the attributs with one statement. As it currently
            set up, it adds id and class attributes to the elements it's been added to. A future
            enhancement may be to add the language element as an attribute.
         </p><pre><code class="xml hljs">
&lt;xs:attributeGroup name="genericPropertiesGroup"&gt;
  &lt;xs:attribute name="id" type="xs:ID" use="optional"/&gt;
  &lt;xs:attribute name="class" type="xs:token" use="optional"/&gt;
&lt;/xs:attributeGroup&gt;
</code></pre><h2>Organization and children</h2>
         <p>Initially there was no organization element until the question came up: <strong>What happens when an author is not a person but a company or group?</strong></p>
         <p>We keep the organization element as generic as possible to make sure we can use it
            in different instances. The only thing we know we'll need is the organization's name...
            everything else can be added when we build elements on top of organization (like publisher,
            discussed below.)
         </p>
         <p>Address is one of those additional elements we add to organization. Addresses are
            string based and use the U.S. model.
         </p>
         <p>Finally we build a publisher element by putting together our organization and address
            elements. Notice how the complex type and the element are called differently.
         </p><pre><code class="xml hljs">
&lt;xs:complexType name="organization"&gt;
  &lt;xs:all&gt;
    &lt;xs:element name='name' type="xs:string"/&gt;
  &lt;/xs:all&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="address"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="recipient" type="xs:string"/&gt;
      &lt;xs:element name="street" type="xs:string"/&gt;
      &lt;xs:element name="city" type="xs:string"/&gt;
      &lt;xs:element name="state" type="xs:string"/&gt;
      &lt;xs:element name="postcode" type="xs:string"/&gt;
      &lt;xs:element name="country" type="xs:token"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="publisher"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:all&gt;
      &lt;xs:element name="name" type="organization"/&gt;
      &lt;xs:element ref="address"/&gt;
    &lt;/xs:all&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;just another pe&gt;
&lt;/xs:element&gt;
</code></pre><h2>Person and children elements</h2>
         <p>We now move to define individuals and their roles.</p>
         <p>The base class is person where we define a first-name and surname. We'll use this
            to create the roles for our different users with additional elements and attributes
            where necessary.
         </p><pre><code class="xml hljs">
&lt;!-- complex types to create groups of similar person items --&gt;
&lt;xs:complexType name="person"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name="first-name" type="xs:string"/&gt;
    &lt;xs:element name="surname" type="xs:string"/&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</code></pre><p>Author, editor and otherRole use person as the base and then add additional elements
            to expand the person based on the type of editor (for the editor element) or the role
            they play in the book (for otherRole.)
         </p>
         <p>During initial develpment I thought I'd just only work with plural elements (authors,
            editors and otherRoles) but soon realized that it took a lot of flexibility out of
            the schema since there may be other places where we need this information. For example,
            we may have an edited volume where each chapter has one or more authors.
         </p>
         <p>So we have individual author (directly based on person), editor (with a
            <em>type</em> attribute to indicate what kind of editor the person is) and otherRole (for roles
            other than editor we use this with the
            <em>role</em> attribute.)
         </p><pre><code class="xml hljs">
&lt;xs:complexType name="author"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="person"/&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="editor"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="person"&gt;
      &lt;xs:choice&gt;
        &lt;xs:element name="type" type="xs:string"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="otherRole"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="person"&gt;
      &lt;xs:sequence minOccurs="1" maxOccurs="1"&gt;
        &lt;xs:element name="role" type="xs:string"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</code></pre><p>With individual roles created we can now create elements for multiple individuals.</p>
         <p>Authors can have 1 or more author elements. At least 1 author is required for the
            document to validate, whether we choose to use it or not. Remember that the transformation
            (using XSLT) doesn't have to use all the elements on the XML source.
         </p>
         <p>Editors and otherRoles wrap around individual elements (editor and otherRole) to provide
            an easier way to work with them in XSLT later on.
         </p>
         <p>Also note that we require 0 or more instances of the base type, rather than 1. This
            is my way of making the element optional: either we have zero, one or more than one
            children.
         </p><pre><code class="xml hljs">
&lt;!-- Wrappers around complext types --&gt;
&lt;xs:element name="authors"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element name="author" type="author"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="editors"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element name="editor" type="editor"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="otherRoles"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element name="otherRole" type="otherRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>Metadata and publishing information</p>
         <p>In order to acommodate publishing information, we add multiple publishing related
            elements to account for publishing and publishing related information.
         </p>
         <p>Most of these elements (except pubdate) are made of 1 or more paragraphs.</p><pre><code class="xml hljs">
&lt;xs:element name="releaseinfo"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="copyright"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="legalnotice"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="abstract"&gt;
  &lt;xs:complexType mixed="true"&gt;
      &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="para"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>The date is different as it's based on the date schema type which in turn it's based
            on the
            <a href="http://www.wikiwand.com/en/ISO_8601" label="ISO 8601">ISO 8601</a> standard.
         </p>
         <p>An example of a valid ISO 8601 date is:
            <em>2015-02-28</em></p>
         <p>This is also the standard that handles time so, in theory, we could build a date/time
            structure including a date formated like the example above plus time and timezone
            offset but, unless we're required to we will avoid that much level of detail.
         </p><pre><code class="xml hljs">
&lt;xs:element name="pubdate" type="xs:date"/&gt;
</code></pre><p>The idea behind revision and revhistory is to provide an accountability chain for
            the publication's history. We can have one or more paragraphs where we outline the
            following information:
         </p>
         <ul>
            <li>Revision number (cast as a string)</li>
            <li>Date (using the pubdate element defined earlier)</li>
            <li>Author's initials (short 255 character string)</li>
            <li>Revision description/notes (short 255 character string)</li>
         </ul>
         <p>The revhistory element is a set of one or more revisions. We'll use XSLT to put them
            in na div tag or inside a table structure.
         </p><pre><code class="xml hljs">
&lt;xs:element name="revision"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:all&gt;
      &lt;xs:element name="revnumber" type="xs:string"/&gt;
      &lt;xs:element ref="pubdate"/&gt;
      &lt;xs:element name="authorinitials" type="token255"/&gt;
      &lt;xs:element name="revnotes" type="token255"/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="revhistory"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="revision"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Links and related elements</h2>
         <p>Links are essential to the web. They allow us to connect our content to other elements
            inside and outside the pages we create. We add class and ID from `genericPropertiesGroup`
            and two new elements:
         </p>
         <ul>
            <li><em>href</em> indicates the URL (local or relative) we are linking to
            </li>
            <li><em>label</em> used as the text of the link and also the label attribute created for accessibility
            </li>
         </ul><pre><code class="xml hljs">
&lt;!-- Links --&gt;
&lt;xs:element name="link"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="href" type="xs:anyURI" use="required"/&gt;
    &lt;xs:attribute name="label" type="xs:string" use="required"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h3>About the xs:anyURI data type</h3>
         <blockquote>
            <p>Some information and examples for this section taken from
               <a href="http://www.datypic.com/sc/xsd/t-xsd_anyURI.html" label="http://www.datypic.com/sc/xsd/t-xsd_anyURI.html">http://www.datypic.com/sc/xsd/t-xsd_anyURI.html</a></p>
         </blockquote>
         <p>t-aligned image inside.&lt;/para&gt;
            &lt;code language="xml"&gt;
            &amp;lt;xs:element name="image"&gt;
            &amp;lt;xs:complexType&gt;
            &amp;lt;xs:attributeGrer name for URLs but they are much more and the amount of work they
            save is significant.
         </p>
         <p></p>
         <p></p>
         <p></p>
         <p></p>
         <p></p>
         <p></p>
         <p>URI (uniform resource indicator) are a superset of the web's URL. There are two main
            types of URIs: absolute and relative.
         </p>
         <p>Absolute URIs provide the entire context for locating the resources, such as <strong>http://datypic.com/prod.html</strong>.
         </p>
         <p>Relative URIs are specified as the difference from a base URI, such as <strong>../prod.html</strong>. It is also possible to specify a fragment identifier, using the # character, such
            as <strong>../prod.html#shirt</strong>. Note that when relative URI references are used as values of xsd:anyURI there is
            no attempt made to track the base of the URI.
         </p>
         <p>The three previous examples happen to be HTTP URLs (Uniform Resource Locators), but
            URIs also encompass URLs of other schemes (e.g., FTP, gopher, telnet), as well as
            URNs (Uniform Resource Names). URIs doen't have to exist to be valid; there is no
            need for a resource to live at http://datypic.com/prod.html for the URI pointing to
            it to validate.
         </p>
         <p>URIs require that some characters be escaped with their hexadecimal Unicode code point
            preceded by the % character. This includes non-ASCII characters and some ASCII characters,
            namely control characters, spaces, and the following characters (unless they are used
            as deliimiters in the URI): &lt;&gt;#%{}|\^`. For example, <strong>../édition.html</strong> must be represented instead as <strong>../%C3%A9dition.html</strong>, with the é escaped as %C3%A9. However, the anyURI type will accept these characters
            either escaped or unescaped. With the exception of the characters % and #, it will
            assume that unescaped characters are intended to be escaped when used in an actual
            URI, although the schema processor will do nothing to alter them. It is valid for
            an anyURI value to contain a space, but this practice is strongly discouraged. Spaces
            should instead be escaped using %20.
         </p>
         <p>The schema processor is not required to parse the contents of an xsd:anyURI value
            to determine whether it is valid according to any particular URI scheme. Since the
            bare minimum rules for valid URI references are fairly generic, the schema processor
            will accept most character strings, including an empty value. The only values that
            are not accepted are ones that make inappropriate use of reserved characters, such
            as ones that contain multiple # characters or have % characters that are not followed
            by two hexadecimal digits.
         </p>
         <p>For more information on URIs, see
            <a href="https://www.ietf.org/rfc/rfc2396.txt" label="RFC 2396, Uniform Resource Identifiers (URI): Generic Syntax">RFC 2396, Uniform Resource Identifiers (URI): Generic Syntax</a>.
         </p>
         <p><strong>Valid URI matching xs:anyURI</strong></p>
         <ul>
            <li>http://datypic.com <strong>absolute URI (also a URL)</strong></li>
            <li>mailto:info@datypic.com <strong>absolute URI</strong></li>
            <li>../%C3%A9dition.html <strong>relative URI containing escaped non-ASCII character</strong></li>
            <li>../édition.html <strong>relative URI containing unescaped non-ASCII character</strong></li>
            <li>http://datypic.com/prod.html#shirt <strong>URI with fragment identifier</strong></li>
            <li>../prod.html#shirt <strong>relative URI with fragment identifier</strong></li>
            <li>urn:example:org <strong>URN</strong></li>
            <li>an empty value is allowed</li>
         </ul>
         <h2>Div and span</h2>
         <p>Div and Span are subcontainers for block level elements (div) and inline elements
            (span). As containers I have to decide what elements are allowed as children and that's
            not always easy; any time we add a new element to the schema we have to decide if
            we're using it as a block element (that can be used inside a div) and/or an inline
            element (and whether that inline element can be used inside a span.)
         </p>
         <p>The only special thing about div and span is the additional attribute type. We use
            type to build
            <em>data-type</em> and
            <em>epub:type</em> attributes. ePub and Edupub have lists of allowed values for the attribute and it's
            a good starting point for work with Javascript or additional functionality.
         </p>
         <p>Div is a subsection of our section elements. Most of the elements that we can add
            to a section are also valid inside a div, including other div elements.
         </p>
         <p>Span is used mostly to hold styles that apply to part of a paragraph and can be nested
            to build more elaborate effects and styles using class and id attributes.
         </p><pre><code class="xml hljs">
&lt;xs:element name="div"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:element ref="language"/&gt;
        &lt;xs:element ref="anchor"/&gt;
        &lt;xs:element ref="code"/&gt;
        &lt;xs:element ref="para"/&gt;
        &lt;xs:element ref="ulist"/&gt;
        &lt;xs:element ref="olist"/&gt;
        &lt;xs:element ref="figure"/&gt;
        &lt;xs:element ref="image"/&gt;
        &lt;xs:element ref="div"/&gt;
        &lt;xs:element ref="span"/&gt;
        &lt;xs:element ref="blockquote"/&gt;
        &lt;xs:element ref="video"/&gt;
        &lt;xs:element ref="aside"/&gt;
        &lt;xs:element ref="h1"/&gt;
        &lt;xs:element ref="h2"/&gt;
        &lt;xs:element ref="h3"/&gt;
        &lt;xs:element ref="h4"/&gt;
        &lt;xs:element ref="h5"/&gt;
        &lt;xs:element ref="h6"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="type" type="xs:token" use="optional"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="span"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice  minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="language"/&gt;
      &lt;xs:element ref="strong"/&gt;
      &lt;xs:element ref="emphasis"/&gt;
      &lt;xs:element ref="underline"/&gt;
      &lt;xs:element ref="strike"/&gt;
      &lt;xs:element ref="link"/&gt;
      &lt;xs:element ref="span"/&gt;
      &lt;xs:element ref="quote"/&gt;
    &lt;/xs:choice&gt;
      &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
      &lt;xs:attribute name="type" type="xs:token" use="optional"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Figure and image</h2>
         <p>Figure and image are the two ways the schema provides for working with images. Rather
            than make several elements and attributes optional and make the image elements brittle
            we allow both a figure element with caption and image children and an image without
            caption.
         </p>
         <p>Most of the time I will use the figure/caption/image combination to give a numbering
            schema when performing the transformations.
         </p><pre><code class="xml hljs">&lt;xs:element name="figure"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:all&gt;
      &lt;xs:element ref="image"/&gt;
      &lt;xs:element ref="figcaption"/&gt;
    &lt;/xs:all&gt;
    &lt;xs:attribute name="height" type="xs:nonNegativeInteger" use="optional"/&gt;
    &lt;xs:attribute name="width" type="xs:nonNegativeInteger" use="optional"/&gt;
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>Captions are made of a single paragraph with all the children available to paragraphs
            elsewhere. This way we can add links and styles to the captions.
         </p><pre><code class="xml hljs">
&lt;xs:element name="figcaption"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>One last thing to note about figures and images: Since figure and image have the same
            attributes we can combine them in different combinations. For example: we can have
            a left centered figure and caption with a right-aligned image inside.
         </p><pre><code class="xml hljs">
&lt;xs:element name="image"&gt;
  &lt;xs:complexType&gt;
    &lt;Ws:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="src" type="xs:token" use="required"/&gt;
    &lt;xs:attribute name="height" type="xs:nonNegativeInteger" use="required"/&gt;
    &lt;xs:attribute name="width" type="xs:nonNegativeInteger" use="required"/&gt;
    &lt;xs:attribute name="alt" type="token255" use="required"/&gt;
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Video</h2>
         <p>Video is a rather complex subject. According to the
            <a href="http://www.w3.org/html/wg/drafts/html/master/semantics.html#the-video-element" label="specification">specification</a> there are two ways to create video elements. I've chosen to adopt the multi-source
            element rather than a single src attribute to the video tag itself.
         </p>
         <p>We use two children element: source and track.</p>
         <p>The
            <em>source</em> element is for the actual video content. The element contains two attributes:
            <em>src</em> indicates the location of the video source.
            <em>Type</em> indicates the mimetype of the video and, optionally the codecs that were used to
            encode the video. This is particularly important with MP4 video as there are muliple
            "profiles" that may or may not be supported in all devices.
         </p>
         <p>At least one of source element is required.</p>
         <p>The track element is used to provide additional information to the video using the
            [VTT community specification](http://dev.w3.org/html5/webvtt/). You can use VTT to
            provide captioning and subtitles in multiple languages allowing the user to decide
            what language and what type of track they want to use with the video.
         </p>
         <p>There are other uses for VTT tracks discussed in the HTML5 video captioning article
            listed in resources.
         </p>
         <h3>Attributes for video tag</h3>
         <ul>
            <li>width — Horizontal dimension</li>
            <li>height — Vertical dimension</li>
            <li>poster — Poster frame to show prior to video playback</li>
            <li>preload — Hints how much buffering the media resource will likely need</li>
            <li>autoplay — Hint that the media resource can be started automatically when the page
               is loaded
            </li>
            <li>loop — Whether to loop the media resource</li>
            <li>muted — Whether to mute the media resource by default</li>
            <li>controls — Show user agent controls</li>
         </ul>
         <h3>Additional Resources</h3>
         <ul>
            <li><a href="http://www.w3.org/html/wg/drafts/html/master/semantics.html#the-video-element" label="HTML5 video specification">HTML5 video specification</a></li>
            <li><a href="http://dev.w3.org/html5/webvtt/" label="WebVTT Draft Community Specification">WebVTT Draft Community Specification</a></li>
            <li><a href="http://publishing-project.rivendellweb.net/video-in-epub/" label="Video in ePub">Video in ePub</a> discusses HTML5 video. While written for ePub it is also applicable to HTML5 content
               in general
            </li>
            <li><a href="http://publishing-project.rivendellweb.net/html5-video-captioning-using-vtt/" label="HTML5 video captioning using VTT">HTML5 video captioning using VTT</a> discusses captioning video using VTT tracks
            </li>
         </ul><pre><code class="xml hljs">
    &lt;!-- Video and multimedia --&gt;
    &lt;xs:element name="video"&gt;
      &lt;xs:complexType mixed="true"&gt;
        &lt;xs:choice&gt;
          &lt;xs:element ref="source" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;xs:element ref="track" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:choice&gt;
        &lt;xs:attribute name="height" type="xs:nonNegativeInteger"/&gt;
        &lt;xs:attribute name="width" type="xs:nonNegativeInteger"/&gt;
        &lt;xs:attribute name="controls" type='xs:string' use="optional"/&gt;
        &lt;xs:attribute name="poster" type="xs:anyURI" use="optional"/&gt;
        &lt;xs:attribute name="autoplay" type="xs:string" use="optional"/&gt;
        &lt;xs:attribute name="preload" type="xs:string" use="optional" default="none"/&gt;
        &lt;xs:attribute name="loop" type="xs:string" use="optional"/&gt;
        &lt;xs:attribute name="muted" type="xs:string" use="optional"/&gt;
      &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

    &lt;xs:element name="source"&gt;
      &lt;xs:complexType&gt;
        &lt;xs:attribute name="src" type='xs:string' use="required"/&gt;
        &lt;xs:attribute name="type" type='xs:string' use="optional"/&gt;
      &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

    &lt;xs:element name="track"&gt;
      &lt;xs:complexType&gt;
        &lt;xs:attribute name="src" type='xs:string' use="required"/&gt;
        &lt;xs:attribute name="label" type='xs:string' use="required"/&gt;
        &lt;xs:attribute name="kind" type='xs:string'/&gt;
        &lt;xs:attribute name="srclang" type='xs:string' default='en'/&gt;
      &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
</code></pre><h2>Styles</h2>
         <p>Styles are hints for the transformation engine to apply rules and classes to the enclosed
            elements. We allow for nested styles by indetifying what styles can nest inside each
            of our four basic styles.
         </p><pre><code class="xml hljs">
&lt;!-- Style elements --&gt;
&lt;xs:element name="strong"&gt;
  &lt;xs:complexType mixed="true"&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="emphasis"/&gt;
          &lt;xs:element ref="underline"/&gt;
          &lt;xs:element ref="strike"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="underline"&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:complexType mixed="true"&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="strong"/&gt;
          &lt;xs:element ref="emphasis"/&gt;
          &lt;xs:element ref="strike"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="strike"&gt;
  &lt;xs:complexType mixed="true"&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="strong"/&gt;
          &lt;xs:element ref="emphasis"/&gt;
          &lt;xs:element ref="underline"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>Emphasis is the only style that can be nested in itself. The idea is that if an emphasis
            element is nested inside another emphasis it will display as normal text.
         </p><pre><code class="xml hljs">&lt;xs:element name="emphasis"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="strong"/&gt;
      &lt;xs:element ref="emphasis"/&gt;
      &lt;xs:element ref="underline"/&gt;
      &lt;xs:element ref="strike"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Lists</h2>
         <p>When I originally conceived the schema I had only one list element that, based on
            a type attribute, would generate the correct type of list (numbered or bulleted.)
            as I was implementing this I trealized it was too brittle and hard to work with and
            hard to maintain.
         </p>
         <p>So I broke the element into two separate list elements; one for bulleted (
            <em>ulist</em>) and one for numbered (
            <em>olist</em>) lists. They can also nest other list elements (of either tupe) inside.
         </p><pre><code class="xml hljs">
&lt;!-- Lists --&gt;
&lt;xs:element name="ulist"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="item"/&gt;
      &lt;xs:element ref="olist"/&gt;
      &lt;xs:element ref="ulist"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="olist"&gt;
&lt;xs:complexType mixed="true"&gt;
  &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
    &lt;xs:element ref="item"/&gt;
    &lt;xs:element ref="olist"/&gt;
    &lt;xs:element ref="ulist"/&gt;
  &lt;/xs:choice&gt;
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>They share a common
            <em>item</em>akes it easier to transfor and pick the order and the types of elements we'e don't
            want a full paragraph in each item because they'll mess up the display when we convert
            them to HTML or PDF. We do want the ability to style the content, link or provide
            span and quotes elements.
         </p><pre><code class="xml hljs">
&lt;xs:element name="item"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice  minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="strong"/&gt;
      &lt;xs:element ref="emphasis"/&gt;
      &lt;xs:element ref="underline"/&gt;
      &lt;xs:element ref="strike"/&gt;
      &lt;xs:element ref="link"/&gt;
      &lt;xs:element ref="span"/&gt;
      &lt;xs:element ref="quote"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Fenced code blocks</h2>
         <p>I love the way Github displays fenced code blocks and wanted to get my HTML and, if
            possible, the PDF generated from XML to look similar to it. After researching the
            issue I found out code highlighting libraries for the web. The one I chose (
            <a href="https://highlightjs.org/" label="highlight.js">highlight.js</a>) also works with PrinceXML (with some extra work.)
         </p>
         <p>The schema defines the container for the code, the XSLT transformations, discussed
            in a later chapter, add the appropriate HTML tags and scripts to highlight the code
            and PrinceXML will honor the code highlight in the HTML and display it in the resulting
            PDF.
         </p><pre><code class="xml hljs">
    &lt;!-- Fenced code blocks --&gt;
    &lt;xs:element name="code"&gt;
        &lt;xs:complexType mixed="true"&gt;
            &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
            &lt;xs:attribute name="language" use="required"/&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
</code></pre><h2>Blockquotes, asides and marginalia</h2>
         <blockquote>
            <p>Element descriptions taken from the
               <a href="HTML5 nightly specification" label="http://www.w3.org/html/wg/drafts/html/master/semantics.html">http://www.w3.org/html/wg/drafts/html/master/semantics.html</a></p>
         </blockquote>
         <p>Blockquotes, asides and quotes provide related or parenthetical content.</p>
         <p>The blockquote element represents content that is quoted from another source, optionally
            with a citation which must be within a footer or cite element, and optionally with
            in-line changes such as annotations and abbreviations.
         </p>
         <p>Attribution provides a way to give credit for the quote.</p><pre><code class="xml hljs">
&lt;!-- Blockquotes, asides and marginalia --&gt;
&lt;xs:element name="attribution"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice  minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="blockquote"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="language" minOccurs="0"/&gt;
      &lt;xs:element ref="anchor"/&gt;
      &lt;xs:element ref="attribution"/&gt;
      &lt;xs:element ref="para" minOccurs="1"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>The aside element represents a section of a page that consists of content that is
            tangentially related to the content around the aside element, and which could be considered
            separate from that content. Such sections are often represented as sidebars in printed
            typography. It can be used for typographical effects like pull quotes or sidebars,
            for advertising, for groups of nav elements, and for other content that is considered
            separate from the main content of the page.
         </p>
         <p>It's not appropriate to use the aside element just for parentheticals, since those
            are part of the main flow of the document.
         </p><pre><code class="xml hljs">
&lt;xs:element name="aside"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:element ref="code"/&gt;
        &lt;xs:element ref="para" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="ulist"/&gt;
        &lt;xs:element ref="olist"/&gt;
        &lt;xs:element ref="figure"/&gt;
        &lt;xs:element ref="image"/&gt;
        &lt;xs:element ref="div"/&gt;
        &lt;xs:element ref="span"/&gt;
        &lt;xs:element ref="blockquote"/&gt;
        &lt;xs:element ref="h1"/&gt;
        &lt;xs:element ref="h2"/&gt;
        &lt;xs:element ref="h3"/&gt;
        &lt;xs:element ref="h4"/&gt;
        &lt;xs:element ref="h5"/&gt;
        &lt;xs:element ref="h6"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="type" type="xs:token" use="optional"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>The quote element represents some inline content quoted from another source.</p>
         <p>Content inside a quote element must be quoted from another source, whose address,
            if it has one, may be cited in the cite attribute. The source may be fictional, as
            when quoting characters in a novel or screenplay.
         </p>
         <p>If the cite attribute is present, it must be a valid URL potentially surrounded by
            spaces. To obtain the corresponding citation link, the value of the attribute must
            be resolved relative to the element. User agents may allow users to follow such citation
            links, but they are primarily intended for private use (e.g. by server-side scripts
            collecting statistics about a site's use of quotations), not for readers.
         </p>
         <p>The quote element must not be used in place of quotation marks that do not represent
            quotes; for example, it is inappropriate to use the quote element for marking up sarcastic
            statements.
         </p><pre><code class="xml hljs">
&lt;xs:element name="quote"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:all&gt;
      &lt;xs:element ref="language"/&gt;
    &lt;/xs:all&gt;
    &lt;xs:attribute name="cite" type="xs:anyURI" use="optional"/&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Paragraphs</h2>
         <p>The paragraph is our main unit of content and where we do most, if not all, our inline
            styling of elements (indicated by what children elements are allowed to the paragraph)
         </p>
         <p>In addition to the genericPropertiesGroup attributes, we also use align to control
            the horizontal alignment of the paragraph. This is useful when the paragraph is inside
            an attribution and I'd like the attribution to be right aligned while keeping the
            paragraph aligned to the left.
         </p><pre><code class="xml hljs">
&lt;xs:element name="para"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice  minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="language"/&gt;
      &lt;xs:element ref="strong"/&gt;
      &lt;xs:element ref="emphasis"/&gt;
      &lt;xs:element ref="underline"/&gt;
      &lt;xs:element ref="strike"/&gt;
      &lt;xs:element ref="link"/&gt;
      &lt;xs:element ref="span"/&gt;
      &lt;xs:element ref="quote"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Headings</h2>
         <p>Headins should be self explainatory. They are used to indicate headings and structure
            in the document. While we only show the level 1 heading, the other levels (h2 thought
            h6) share the same structure.
         </p><pre><code class="xml hljs">
&lt;xs:element name="h1"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Metadata element</h2>
         <p>The metadata element contains all the elements for our publication that are not content.
            Information such as copyright, legal notices, publisher, author and staff information.
         </p>
         <p>s we'll work with --&gt;
            &amp;lt;xsl:stylesheet
            xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
            xmlns:dc="http://purl.org/dc/elements/1.1/"
            xmlns:epub="http://www.idpf.org/2007/opf"
            exclude-result-prefixes="dc epub"
            type of document we generate.
         </p>
         <p>Having a separate metadata element makes it easier to add or take away elements as
            needed.
         </p><pre><code class="xml hljs">
&lt;!-- Metadata element --&gt;
&lt;xs:element name="metadata"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element name="isbn" type="ISBN-type10"/&gt;
      &lt;xs:element name="edition" type="xs:string"/&gt;
      &lt;xs:element ref="authors"/&gt;
      &lt;xs:element ref="editors"/&gt;
      &lt;xs:element ref="otherRoles"/&gt;
      &lt;xs:element ref="publisher"/&gt;
      &lt;xs:element ref="releaseinfo"/&gt;
      &lt;xs:element ref="copyright"/&gt;
      &lt;xs:element ref="legalnotice"/&gt;
      &lt;xs:element name="title" type="xs:string"/&gt;
      &lt;xs:element name="subtitle" type="xs:string"/&gt;
      &lt;xs:element ref="language"/&gt;
      &lt;xs:element ref="revhistory" minOccurs="0"/&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Section element</h2>
         <p>Sections are the primary container for our documents. It is at this level that we
            will create separate files when I start looking at multiple output.
         </p>
         <p>I also use the
            <em>type</em> attribute here to indicate the type of section it is. The default value for it is
            chapter since it's the one I use most often. I've been thinking whether I want to
            create an enumeration of all the different values for type (based on epub and edupub
            profiles) to make it easier to create (oXygen gives me a list of all possible values
            for type and it currently only shows the default.)
         </p>
         <p>Other than the title element, defined as a string schema type, all other elements
            reference reference other elements in the schema.
         </p>
         <p>It derives class and id from our genericPropertiesGroup and the type attribute.</p><pre><code class="xml hljs">
&lt;!-- Section element --&gt;
&lt;xs:element name="section"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="title" type="xs:string" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:element ref="anchor"/&gt;
        &lt;xs:element ref="code"/&gt;
        &lt;xs:element ref="para" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="ulist"/&gt;
        &lt;xs:element ref="olist"/&gt;
        &lt;xs:element ref="figure"/&gt;
        &lt;xs:element ref="image"/&gt;
        &lt;xs:element ref="div"/&gt;
        &lt;xs:element ref="span"/&gt;
        &lt;xs:element ref="blockquote"/&gt;
        &lt;xs:element ref="video"/&gt;
        &lt;xs:element ref="aside"/&gt;
        &lt;xs:element ref="h1"/&gt;
        &lt;xs:element ref="h2"/&gt;
        &lt;xs:element ref="h3"/&gt;
        &lt;xs:element ref="h4"/&gt;
        &lt;xs:element ref="h5"/&gt;
        &lt;xs:element ref="h6"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="type" type="xs:token" use="optional" default="chapter"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Table of contents placeholder</h2>
         <p>Even though we're generating the table of contents in the transformation stage of
            the process I still need an element to tell the script where to place the generated
            table of contents.
         </p>
         <p>Since this is a placeholder element we don't assign attributes or children elements.</p><pre><code class="xml hljs">
&lt;!-- place holder for generated toc element --&gt;
&lt;xs:element name="toc"/&gt;
</code></pre><h2>Puting it al together: The book element</h2>
         <p>The last thing to do is to put the structure of the book together. As currently outlined,
            the structure is metadata, followed by the table of contents placeholder and 1 or
            more sections where only 1 section element is required.
         </p>
         <p>The idea for making 1 section required and nothing else is that, sometimes, we're
            writing something quick where I don't really want metadata information or a table
            of contents. Since the section element already has a title I can get away with using
            only that for the document.
         </p><pre><code class="xml hljs">
&lt;!-- Base book element --&gt;
&lt;xs:element name="book"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice maxOccurs="unbounded"&gt;
      &lt;xs:element ref="metadata" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="toc" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="section" minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;/xs:schema&gt;
</code></pre></section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="chapter" epub:type="chapter">
         <p class="rh">Converting XML content to HTML</p>
         <h1 id="d2e970">Converting XML content to HTML</h1>
         <p>One of the biggest advantages of working with XML is that we can convert the abstract
            tags into other markups. For the purposes of this project we'll convert the XML created
            to match the schema we just created to HTML and then use tools like
            <a href="http://www.princexml.com" label="PrinceXML">PrinceXML</a> or
            <a href="http://www.antennahouse.com" label="AntenaHouse">AntenaHouse</a> we'll convert the HTML/CSS files to PDF
         </p>
         <h2>Why HTML</h2>
         <p>HTML is the default format for the web and for most web/html based content such as
            ePub and Kindle. As such it makes a perfect candidate to explore how to generate it
            programmatically from a single source file.
         </p>
         <p>HTML will also act as our source for using CSS paged media to create PDF content.</p>
         <h2>Why PDF</h2>
         <p>Rather than having to deal with
            <a href="http://www.w3.org/TR/2006/REC-xsl11-20061205/" label="XSL-FO">XSL-FO</a>, another XML based vocabulary to create PDF content, we'll use XSLT to create another
            HTML file and process it with
            <a href="http://dev.w3.org/csswg/css-page-3/" label="CSS Paged Media">CSS Paged Media</a> and the companion
            <a href="http://www.w3.org/TR/css-gcpm-3/" label="Generated Content for Paged Media">Generated Content for Paged Media</a> specifications to create PDF content.
         </p>
         <p>Where there is a direct equivalent between our mode and the
            <a href="http://www.w3.org/html/wg/drafts/html/master/sections.html" label="HTML5.1 nightly specification">HTML5.1 nightly specification</a> I've quoted the relevant section of the HTML5 spec as a reference and as a rationale
            of why I've done things the way I did.
         </p>
         <p>In this document we'll concentrate on the XSLT to HTML conversion and will defer converting
            HTML to PDF to a later article.
         </p>
         <h1>Creating our conversion style sheets</h1>
         <p>To convert our XML into other formats we will use XSL Transformations (also known
            as XSLT)
            <a href="http://www.w3.org/TR/xslt" label="version 2">version 2</a> (a W3C standard) and
            <a href="http://www.w3.org/TR/xslt-30/" label="version 3">version 3</a> (a W3C last call draft recommendation) where appropriate.
         </p>
         <p>XSLT is a functional language designed to transform XML into other markup vocabularies.
            It defines template rules that match elements in your source document and processing
            them to convert them to the target vocabulary. 
         </p>
         <p>In the XSLT template below, we do the following:</p>
         <ol>
            <li>Declare the file as an XML document</li>
            <li>Define the root element of the style sheet (xsl:stylesheet)</li>
            <li>Indicate the namespaces that we'll use in the document and, in this case, tell the
               processor to exclude the given namespace
            </li>
            <li>Strip whitespace from all elements and keep it in the code elements</li>
            <li>Create the default output we'll use for the main document and all generated pages
               (discussed later)
            </li>
            <li>Create a default template to warn us if we missed anything</li>
         </ol><pre><code class="xml hljs">
&lt;?xml version="1.0" ?&gt;
&lt;!-- Define stylesheet root and namespaces we'll work with --&gt;
&lt;xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:epub="http://www.idpf.org/2007/opf"
  exclude-result-prefixes="dc epub"
  xml:lang="en-US"
  version="2.0"&gt;
  &lt;!-- Strip whitespace from the listed elements --&gt;
  &lt;xsl:strip-space elements="*"/&gt;
  &lt;!-- And preserve it from the elements below --&gt;
  &lt;xsl:preserve-space elements="code"/&gt;
  &lt;!-- Define the output for this and all document children --&gt;
  &lt;xsl:output name="xhtml-out" method="xhtml" indent="yes" encoding="UTF-8" omit-xml-declaration="yes" /&gt;
  &lt;xsl:template match="*"&gt;
    &lt;xsl:message terminate="no"&gt;
      WARNING: Unmatched element: &lt;xsl:value-of select="name()"/&gt;
    &lt;/xsl:message&gt;

    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre><p>This is a lot of work before we start creating our XSLT content. But it's worth doing
            the work up front. We'll see what are the advantages of doing it this way as we move
            down the style sheet.
         </p>
         <p>Now to our root templates. The first one is the entry point to our document. It performs
            the following tasks:
         </p>
         <ol>
            <li>Match the root element to create the skeleton for our HTML content</li>
            <li>We include the name and version of our XSLT processor as a meta element</li>
            <li>In the title we insert the value of the
               <em>metadata/title</em> element
            </li>
            <li>In the body we
               <em>apply</em> the templates that match the content inside our document (more on this later)
            </li>
         </ol><pre><code class="xml hljs">
&lt;xsl:template match="book"&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;xsl:element name="title"&gt;
      &lt;xsl:value-of select="metadata/title"/&gt;
    &lt;/xsl:element&gt;
    &lt;xsl:element name="meta"&gt;
      &lt;xsl:attribute name="generator"&gt;
        &lt;xsl:value-of select="system-property('xsl:product-name')"/&gt;
        &lt;xsl:value-of select="system-property('xsl:product-version')"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:element&gt;
    &lt;link rel="stylesheet" href="css/style.css" /&gt;
    &lt;xsl:if test="(code)"&gt;
      &lt;link rel="stylesheet" href="css/styles/docco.css" /&gt;
      &lt;!-- Load highlight.js --&gt;
      &lt;script src="lib/highlight.pack.js"&gt;&lt;/script&gt;
      &lt;script&gt;
        hljs.initHighlightingOnLoad();
      &lt;/script&gt;
    &lt;/xsl:if&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:apply-templates select="/" mode="toc"/&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</code></pre><p>We could build the CSS style sheet and JavaScript files as part of our root template
            but we chose not to.
         </p>
         <p>Working with the style sheet as part of the XSLT style sheet allows the XSLT stylesheet
            designer to embed the style and parametrize the stylesheet, thus making the stylesheet
            customizable from the command line.
         </p>
         <p>For all advantages, this method ties the styles for the project to the XSLT stylesheet
            and requires the XSLT stylesheet designer to remain involved in all CSS and JavaScript
            updates.
         </p>
         <p>By linking to external CSS and JavaScript files we can leverage expertise independent
            of the Schema and XSLT style sheets. Book designers can work on the CSS, UX and experience
            designers can work on JavaScript and other CSS areas, book designers can work on the
            Paged Media style sheets and authors can just write.
         </p>
         <p>Furthermore we can reuse our CSS and JavaScript on multiple documents.</p>
         <h2>Table of contents</h2>
         <p>There is a second template matching the root element of our document to create a table
            of content. At first thought this looks like the wrong approach 
         </p>
         <p>We leverage XSLT modes that allow us to create templates for the same element to perform
            different tasks. In
            <em>toc mode</em> we want the root template to do the following:
         </p>
         <ol>
            <li>Create the document that will hold the table of content</li>
            <li>Build the HTML document</li>
            <li>Create the sectiion and assign its data-type attribute</li>
            <li>Add the title for the table of contents</li>
            <li>For each section element that is a child of root create these elements</li>
            <ol>
               <li>The
                  <em>li</em> element
               </li>
               <li>The a element with the corresponding href element</li>
               <li>The href attribute</li>
               <li>The value of the href attribute (a concatenation of the section's type attribute,
                  the position within the document and the .html string)
               </li>
               <li>The title of the section as the 'clickable' portion of the link</li>
            </ol>
         </ol><pre><code class="xml hljs">
&lt;xsl:template match="/" mode="toc"&gt;
  &lt;xsl:result-document href='toc.html' format="xhtml-out"&gt; (1)
    &lt;html&gt; (2)
      &lt;head&gt;
        &lt;link rel="stylesheet" href="css/style.css" /&gt;
        &lt;!-- Load Normalize library --&gt;
        &lt;link rel="stylesheet" href="css/normalize.css"/&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;section data-type="toc"&gt; (3)
          &lt;h2&gt;Table of Contents&lt;/h2&gt; (4)
          &lt;nav&gt;
            &lt;ol&gt;
              &lt;xsl:for-each select="//section"&gt; (5)
                &lt;xsl:element name="li"&gt; (5.1)
                  &lt;xsl:element name="a"&gt; (5.2)
                    &lt;xsl:attribute name="href"&gt; (5.3)
                      &lt;xsl:value-of select="concat(@type, position(),'.html')"/&gt; (5.4)
                    &lt;/xsl:attribute&gt;
                    &lt;xsl:value-of select="title"/&gt; (5.5)
                  &lt;/xsl:element&gt;
                &lt;/xsl:element&gt;
              &lt;/xsl:for-each&gt;
            &lt;/ol&gt;
          &lt;/nav&gt;
        &lt;/section&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
</code></pre><h2>Metadata and Section</h2>
         <p>With these templates in place we can now start writing the major areas of the document,
            <em>metadata</em> and
            <em>section</em>. 
         </p>
         <h3>Metadata</h3>
         <p>The metadata is a container for all the elements inside. As such we just create the
            section that will hold the content and call `xsl:apply-templates` to process the children
            inside the metadata element using the apply-template XSLT instruction. The template
            looks like this
         </p><pre><code class="xml hljs">
&lt;xsl:template match="metadata"&gt;
  &lt;xsl:element name="section"&gt;
    &lt;xsl:attribute name="data-type" select="'metadata'"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Section</h3>
         <p>The section template, on the other hand, is more complex because it has a lot of work
            to do. It is our primary unit for generating content fifiles, takes most of the same
            attributes as the root template and then processes the rest of the content.
         </p>
         <p>Inside the template we first create a vairable to hold the name of the file we'll
            generate. The file name is a concatenation of the following elements:
         </p>
         <ul>
            <li>The type attribute</li>
            <li>The position in the document</li>
            <li>the string ".html"</li>
         </ul>
         <p>The result-document element takes two parameters: the value of the file name variable
            we just defined and the xhtml-out format we defined at the top of the document. The
            XHTML format may look like overkill right now but it makes sense when we consider
            moving the generated content to ePub or other fomats where strict XHTML conformance
            is a requirement. 
         </p>
         <p>We start generating the skeleton of the page, we add the default style sheet and do
            the first conditional test of the document. Don't want to add stylesheets to the page
            unless they are needed so we test if there is a code element on the page and only
            add highlight.js related stylesheets and scripts.
         </p>
         <p>In the body element we add a section element, the main wrapper for our content.</p>
         <p>For the section we conditionally add attributes to the element. We use only add a
            data-type attribute to body if there is a type attribute in the source document. We
            do the same thing for id and class.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="section"&gt;
  &lt;;h2&gt;Production team&amp;lt;/h2&gt;
  &amp;lile names --&gt;
  &lt;xsl:variable name="fileName" select="concat((@type), (position()-1),'.html')"/&gt;
  &lt;!-- An example result of the variable above would be introduction1.xhtml --&gt;
  &lt;xsl:result-document href='{$fileName}' format="xhtml-out"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;link rel="stylesheet" href="css/style.css" /&gt;
        &lt;xsl:if test="(code)"&gt;
          &lt;link rel="stylesheet" href="css/styles/docco.css" /&gt;
          &lt;!-- Load highlight.js --&gt;
          &lt;script src="lib/highlight.pack.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            hljs.initHighlightingOnLoad();
          &lt;/script&gt;
        &lt;/xsl:if&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;section&gt;
          &lt;xsl:if test="string(@type)"&gt;
            &lt;xsl:attribute name="data-type"&gt;
              &lt;xsl:value-of select="@type"/&gt;
            &lt;/xsl:attribute&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="string(@class)"&gt;
            &lt;xsl:attribute name="class"&gt;
              &lt;xsl:value-of select="@class"/&gt;
            &lt;/xsl:attribute&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="string(@id)"&gt;
            &lt;xsl:attribute name="id"&gt;
              &lt;xsl:value-of select="@id"/&gt;
            &lt;/xsl:attribute&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:apply-templates/&gt;
        &lt;/section&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
</code></pre><h2>Metadata content</h2>
         <p>Since the style sheets were oginally written I've added more content to the metadata
            element to acommodate different publishing requirements. The first additional element
            I've added is publisher, an organization or person that has a name (pubname element)
            and an address (modeled after a United States address)
         </p>
         <p>Most of the metadata templates use two conditional statements. The first one tests
            to see if the author gave the element a class attribute. If there is one, we use that
            as the value of the class attribute, otherwise we assign a default value based on
            the element name or its function.
         </p>
         <p>The second test is simple. If there is an ID attribute use it as the value for the
            ID attribute, otherwise leave it blank. 
         </p>
         <p>I coded it this way because of the difference in using classes versus ID values. </p>
         <p>Unless you're using the IDs to structure your content there is no real reason to use
            IDs instead of classes. The consensus is to avoid IDs as much as possible as explained
            in the
            <a href="https://github.com/CSSLint/csslint/wiki/Disallow-IDs-in-selectors" label="CSSLint rule that disallows IDs in selectors">CSSLint rule that disallows IDs in selectors</a></p>
         <p>With two different classes I'm also giving content creators the flexibility of either
            using the default CSS (or no CSS at all) or create their own CSS for the metadata
            element, the choice is yours.
         </p><pre><code class="xml hljs">
  &lt;xsl:template match="publisher"&gt;
    &lt;xsl:element name="div"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="string(@class)"&gt;
          &lt;xsl:attribute name="class" select="@class"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:attribute name="class" select="'publisher'"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:if test="string(@id)"&gt;
        &lt;xsl:attribute name="id"&gt;
          &lt;xsl:value-of select="@id"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:if&gt;
        &lt;xsl:value-of select="name"/&gt;
        &lt;xsl:apply-templates select="address"/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:template&gt;
</code></pre><p>Right now the address is a list of paragraphs with the information of the children
            elements. We may change the structure to a single paragraphy with span elements to
            indicate where each child element happens. I'm not 100% sure which way is better.
         </p><pre><code class="xml hljs">
  &lt;xsl:template match="address"&gt;
    &lt;xsl:element name="div"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="string(@class)"&gt;
          &lt;xsl:attribute name="class" select="@class"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:attribute name="class" select="'address'"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="recipient"/&gt;&lt;/xsl:element&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="street"/&gt;&lt;/xsl:element&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="city"/&gt;&lt;/xsl:element&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="state"/&gt;&lt;/xsl:element&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="postcode"/&gt;&lt;/xsl:element&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="country"/&gt;&lt;/xsl:element&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:template&gt;
</code></pre><p>These elements: releaseinfo, copyright, legal notice, pubdate and abstract share a
            similar structure so, instead of creating one template we match all of them and we
            do a little magic. We replace the class name in the otherwise clause and use the name()
            xpath expression that will match the name of the element that matched the template.
         </p><pre><code class="xml hljs">
  &lt;xsl:template match="releaseinfo | copyright | legalnotice | pubdate | abstract"&gt;
  &lt;xsl:element name="div"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="string(@class)"&gt;
        &lt;xsl:attribute name="class" select="@class"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:attribute name="class" select="name()"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p>The revhistory and revisions attribute provides a way to do authority and change tracking.
            I'm still working on these templates. As they are right now they are paragraphs inside
            a div inside another div holding the full history.
         </p>
         <p>Normally I'd consider using a table but want to explore other options before I do
            so.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="revhistory"&gt;
  &lt;xsl:element name="div"&gt;
    &lt;xsl:attribute name="class" select="'revhistory'"/&gt;
    &lt;xsl:value-of select="revision"/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="revision"&gt;
  &lt;xsl:element name="div"&gt;
    &lt;xsl:attribute name="class" select="'revision'"/&gt;
    &lt;p&gt;&lt;xsl:value-of select="revnumber"/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;xsl:value-of select="pubdate"/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;xsl:value-of select="authorinitials"/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;xsl:value-of select="revnotes"/&gt;&lt;/p&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p>For authors we do the following:</p>
         <ol>
            <li>For each individual in the group we take the first name and the surname</li>
            <li>Wrap the name around an li element to build an unnumbered list. We can style the list
               with CSS later
            </li>
         </ol>
         <p>For editors and other roles we do the same thing</p>
         <ol>
            <li>For each individual in the group we take the first name and the surname</li>
            <li>We concatenate the type/role to create a full title (production editor for example)</li>
            <li>Wrap the name and the title with an li element that we can style with CSS later</li>
         </ol><pre><code class="xml hljs">
&lt;xsl:template match="metadata/authors"&gt;
  &lt;h2&gt;Authors&lt;/h2&gt;
  &lt;ul&gt;
    &lt;xsl:for-each select="author"&gt;
      &lt;li&gt;
        &lt;xsl:value-of select="first-name"/&gt;
        &lt;xsl:text&gt; &lt;/xsl:text&gt;
        &lt;xsl:value-of select="surname"/&gt;
      &lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;
</code></pre><pre><code class="xml hljs">
&lt;xsl:template match="metadata/editors"&gt;
  &lt;h2&gt;Editorial Team&lt;/h2&gt;
  &lt;ul class="no-bullet"&gt;
    &lt;xsl:for-each select="editor"&gt;
      &lt;li&gt;
        &lt;xsl:value-of select="first-name"/&gt;
        &lt;xsl:text&gt; &lt;/xsl:text&gt;
        &lt;xsl:value-of select="surname"/&gt;
        &lt;xsl:value-of select="concat(' - ', type, ' ', 'editor')"/&gt;
      &lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;
</code></pre><pre><code class="xml hljs">
&lt;xsl:template match="metadata/otherRoles"&gt;
  &lt;h2&gt;Production team&lt;/h2&gt;
  &lt;ul class="no-bullet"&gt;
    &lt;xsl:for-each select="otherRole"&gt;
      &lt;li&gt;
        &lt;xsl:value-of select="first-name" /&gt;
        &lt;xsl:text&gt; &lt;/xsl:text&gt;
        &lt;xsl:value-of select="surname" /&gt;
        &lt;xsl:text&gt; - &lt;/xsl:text&gt;
        &lt;xsl:value-of select="role" /&gt;
      &lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Titles and headings</h3>
         <p>Headings are primarily used to create sections of content. We use the same heading
            levels as HTML with the addition of a
            <em>title</em> tag that also maps to a level 1 heading. We've put
            <em>title</em> and
            <em>h1</em> in separate templates to make it possible and easier to generate different code for
            each heading.
         </p>
         <p>Working with XSLT is not the same as using CSS where you can declare rules for the
            same attribute multiple times (with the last one winning); when writing transformations
            you can only have one per element otherwise you will get an error or a different result
            to the one you expected.
         </p>
         <p>According to the spec:</p>
         <blockquote>
            <p>These elements [h1 to h6] represent headings for their sections.</p>
            <p>The semantics and meaning of these elements are defined in the section on headings
               and sections.
            </p>
            <p>These elements have a rank given by the number in their name. The h1 element is said
               to have the highest rank, the h6 element has the lowest rank, and two elements with
               the same name have equal rank.
            </p>
            <p>h1–h6 elements must not be used to markup subheadings, subtitles, alternative titles
               and taglines unless intended to be the heading for a new section or subsection. Instead
               use the markup patterns in the
               <a href="http://www.w3.org/html/wg/drafts/html/master/common-idioms.html#common-idioms" label="Common idioms without dedicated elements">Common idioms without dedicated elements</a> section of the specification.
            </p><cite>
               <p><strong><em>- 4.3.6 The h1, h2, h3, h4, h5, and h6 elements, Berjon et al. 2013</em></strong></p></cite></blockquote>
         <p>All elements have the same attribute set: align, class and id.</p>
         <p>The remaining headings, h2 through h6, all have the same attributes and the templates
            are structured the same way.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="title "&gt;
  &lt;xsl:element name="h1"&gt;
    &lt;xsl:if test="@align"&gt;
      &lt;xsl:attribute name="align"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Blockquotes, quotes and asides</h3>
         <p>Blockquotes, asides and quotes provide sidebar-like content on our document. According
            to the W3C:
         </p>
         <blockquote>
            <p>The blockquote element represents content that is quoted from another source, *optionally*
               with a citation which must be within a footer or cite element, and *optionally* with
               in-line changes such as annotations and abbreviations.
            </p>
            <p>Content inside a blockquote other than citations and in-line changes *must* be quoted
               from another source, whose address, if it has one, *may* be cited in the cite attribute.
               [emphasis mine]
            </p><cite>
               <p><strong><em>- 4.51 the Blockquote element , Berjon et al. 2013</em></strong></p></cite></blockquote>
         <p>The cite HTML provides attribution to the blockquote it is used in. To prevent confusion
            and to make it's meaning clear the document model uses the
            <em>attribution</em> tag instead, their purpose is identical and during the transformation the attribution
            will become a
            <em>cite</em> element. According to spec:
         </p>
         <blockquote>
            <p>The cite element represents a reference to a creative work. It must include the title
               of the work or the name of the author (person, people or organization) or an URL reference,
               which may be in an abbreviated form as per the conventions used for the addition of
               citation metadata.
            </p>
            <p><strong><em>- 4.51 the Cite element , Berjon et al. 2013</em></strong></p>
         </blockquote><pre><code class="xml hljs">
&lt;xsl:template match="blockquote"&gt;
  &lt;xsl:element name="blockquote"&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates /&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;!-- BLOCKQUOTE ATTRIBUTION--&gt;
&lt;xsl:template match="attribution"&gt;
  &lt;xsl:element name="cite"&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p>The
            <em>q</em> element is the inline equivalent to `blockquote` and has been replaced in our markup
            by the
            <em>quote</em> element. As stated in the HTML5 specification:
         </p>
         <blockquote>
            <p>The q element represents some phrasing content quoted from another source.</p>
            <p>Quotation punctuation (such as quotation marks) that is quoting the contents of the
               element must not appear immediately before, after, or inside q elements; they will
               be inserted into the rendering by the user agent.
            </p>
            <p>Content inside a q element must be quoted from another source, whose address, if it
               has one, may be cited in the cite attribute. The source may be fictional, as when
               quoting characters in a novel or screenplay.
            </p>
            <p>If the cite attribute is present, it must be a valid URL potentially surrounded by
               spaces. To obtain the corresponding citation link, the value of the attribute must
               be resolved relative to the element. User agents may allow users to follow such citation
               links, but they are primarily intended for private use (e.g. by server-side scripts
               collecting statistics about a site's use of quotations), not for readers.
            </p>
            <p>The q element must not be used in place of quotation marks that do not represent quotes;
               for example, it is inappropriate to use the q element for marking up sarcastic statements.
            </p>
            <p>The use of q elements to mark up quotations is entirely optional; using explicit quotation
               punctuation without q elements is just as correct.
            </p>
            <p><strong><em>- 4.5.7 The q element, Berjon et al. 2013</em></strong></p>
         </blockquote><pre><code class="xml hljs">
&lt;xs:element name="quote"&gt;
&lt;xs:complexType mixed="true"&gt;
  &lt;xs:attribute name="cite" type="xs:anyURI" use="optional"/&gt;
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>Asides are primarily used for content realted to the main flow of the document. I
            use it mostly for notes indirectly related to the main content, for example, to explain
            that there are other ways to generate Schemas apart from W3C's Schema. It is good
            to know this but it won't change the information in the main content flow.
         </p>
         <p>Per Spec:</p>
         <blockquote>
            <p>re are times when we want to link to sections within the same document or to specifangentially
               related to the content around the aside element, and which could be considered separate
               from that content. Such sections are often represented as sidebars in printed typography.
            </p>
            <p>The element can be used for typographical effects like pull quotes or sidebars, for
               advertising, for groups of nav elements, and for other content that is considered
               separate from the main content of the page.
            </p><cite>
               <p><strong><em>- 4.3.5 The aside element, Berjon et al. 2013</em></strong></p></cite></blockquote><pre><code class="xml hljs">
&lt;xsl:template match="aside"&gt;
  &lt;aside&gt;
    &lt;xsl:if test="type"&gt;
      &lt;xsl:attribute name="data-type"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/aside&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Div and Span</h3>
         <p>div and span elements are neutral, they don't have meaning on their onw but they can
            get their meaning from attributes such as
            <em>class</em>,
            <em>data-*</em>, and
            <em>id</em>. Divs are meant as block level elements and siblings or children to sections where
            `span` is used inline, like a child to our
            <em>para</em> elements.
         </p>
         <p>According to the specification:</p>
         <blockquote>
            <p>The div element has no special meaning at all. It represents its children. It can
               be used with the class, lang, and title attributes to mark up semantics common to
               a group of consecutive elements.
            </p>
            <p>Authors are strongly encouraged to view the div element as an element of last resort,
               for when no other element is suitable. Use of more appropriate elements instead of
               the div element leads to better accessibility for readers and easier maintainability
               for authors.
            </p><cite>
               <p><strong><em>- 4.4.14 The div element, Berjon et al. 2013</em></strong></p></cite></blockquote><pre><code class="xml hljs">
&lt;xsl:template match="div"&gt;
  &lt;xsl:element name="div"&gt;
    &lt;xsl:if test="@align"&gt;
      &lt;xsl:attribute name="align"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p>The span element on its own is meaningless. We can give it meaning with the attributes
            we pass to it. We can give it a class or id for CSS styling or a type to generate
            semantic meaning for the contained text.
         </p>
         <p>When we start working on an ePub implementation we can also add the epub:type attribute
            to create an even more detailed semantic map of our content.
         </p>
         <blockquote>
            <p>The span element doesn't mean anything on its own, but can be useful when used together
               with the global attributes, e.g. class, lang, or dir. It represents its children.
            </p><cite>
               <p><strong><em>- 4.5.28 The span element, Berjon et al. 2013</em></strong></p></cite></blockquote><pre><code class="xml hljs">
&lt;xsl:template match="span"&gt;
  &lt;xsl:element name="span"&gt;
    &lt;xsl:if test="@type"&gt;
      &lt;xsl:attribute name="data-type"&gt;
        &lt;xsl:value-of select="@type"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Paragraphs</h3>
         <p>The paragraph is our basic unit of content. Paragraphs are usually represented as
            blocks of text but they can be styled anyway we choose with the proper CSS.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="para"&gt;
  &lt;xsl:element name="p"&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Styles</h3>
         <p>Styles are used to indicate typograhical styles such as strong, emphsis, strikethrough
            and underline.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="strong"&gt;
  &lt;strong&gt;&lt;xsl:apply-templates /&gt;&lt;/strong&gt;
&lt;/xsl:template&gt;
</code></pre><p>Since we're working with print and visual media only we use only
            <em>strong</em> to indicate bold elements. I've never understood how do strong and
            <em>b</em> work in screen and printed pages or in screen displays.
         </p>
         <p>May have to implement
            <em>b</em> when developing the accessibility component for the document schema.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="emphasis"&gt;
  &lt;em&gt;&lt;xsl:apply-templates/&gt;&lt;/em&gt;
&lt;/xsl:template&gt;
</code></pre><p>As with strong, I've decided to only use
            <em>emphasis</em> to indicate italics and save `
            <em>i</em>` for a future revision when, and if, it becomes necessary. 
         </p><pre><code class="xml hljs">
&lt;xsl:template match="strike"&gt;
  &lt;strike&gt;&lt;xsl:apply-templates/&gt;&lt;/strike&gt;
&lt;/xsl:template&gt;
</code></pre><p>Although the strikethrough element has been deprecated in the HTML5 standard, it's
            still worth having as it can also be the target for CSS that accomplishes the same
            goal.
         </p>
         <p>The CSS way is to assign a
            <em>text-decoration: line-through</em> instruction to the strike selector.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="underline"&gt;
  &lt;u&gt;&lt;xsl:apply-templates/&gt;&lt;/u&gt;
&lt;/xsl:template&gt;
</code></pre><p>While there is a
            <em>u</em> element it has different semantics than underline. Like strike the correct way to
            do it is with CSS; in this case using `text-decoration: underlike` for the chosen
            element.
         </p>
         <h2>Links</h2>
         <p>Links are the essence of the web. They allow you to navigate within the document you're
            in or move to external documents. I've taken shortcuts and made the label attribute
            (used for accessibility) and the content of the link the same text. This reduced the
            ammount of typing we have to do but run the risk of becoming too inflexible.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="link"&gt;
  &lt;xsl:element name="a"&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:attribute name="href"&gt;
      &lt;xsl:value-of select="@href"/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="label"&gt;
      &lt;xsl:value-of select="@label"/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:value-of select="@label"/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p>rt the image directly on our document.&lt;/para&gt;
            &lt;code language="xml"&gt;
            &amp;lt;xsl:template match="image"&gt;
            &amp;lt;xs sections in another document or to specific sections inside a paragraph or
            to a figure. To do this we need anchors that will resolve to the following HTML:
         </p><pre><code class="html hljs">
&lt;a id="#target"&gt;&lt;a&gt;
</code></pre><p>Since all our structural elements can have an id, it's better to target the id in
            the element rather than create a separate element to link to. Because we have the
            facilitie to accomplish the same task I've removed the anchor element from the document
            model.
         </p>
         <h2>Code blocks</h2>
         <p>Code elements create
            <a href="https://help.github.com/articles/github-flavored-markdown/#fenced-code-blocks" label="fenced code blocks">fenced code blocks</a> like the ones from
            <a href="https://help.github.com/articles/github-flavored-markdown/" label="Github Flavored Markdown">Github Flavored Markdown</a>. 
         </p>
         <p>We use
            <a href="https://www.google.com/fonts/specimen/Source+Code+Pro" label="Adobe Source Code Pro">Adobe Source Code Pro</a> font. It's a clean and readable font designed specifically for source code display.
         </p>
         <p>We highlight our code with
            <a href="https://highlightjs.org/" label="Highlight.js">Highlight.js</a>. This makes the class attribute mandatory as we need it to tell highlight.js what
            syntax library to use
         </p><pre><code class="xml hljs">
&lt;xsl:template match="code"&gt;
  &lt;xsl:element name="pre"&gt;
    &lt;xsl:element name="code"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@language"/&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><h2>Lists and list items</h2>
         <p>When I first conceptualized this project I had designed a single list element and
            attributes to produce bulleted and numbered lists. This proved to difficult to implement
            so I went back to two separate elements:
            <em>ulist</em> for bulleted lists and
            <em>olist</em> for numbered lists. 
         </p>
         <p>Both elements share the
            <em>item</em> element to indicates the items inside the list. At least one item is required a list.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="ulist"&gt;
  &lt;xsl:element name="ul"&gt;
    &lt;xsl:if test="string(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="string(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="olist"&gt;
  &lt;xsl:element name="ol"&gt;
    &lt;xsl:if test="string(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="string(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="item"&gt;
  &lt;xsl:element name="li"&gt;
    &lt;xsl:if test="string(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="string(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p></p>
         <h2>Figures and Images</h2>
         <blockquote>
            <p>The figure element represents some flow content, optionally with a caption, that is
               self-contained (like a complete sentence) and is typically referenced as a single
               unit from the main flow of the document.
            </p>
            <p>The element can thus be used to annotate illustrations, diagrams, photos, code listings,
               etc.
            </p>
            <p>A figure element's contents are part of the surrounding flow. If the purpose of the
               page is to display the figure, for example a photograph on an image sharing site,
               the figure and figcaption elements can be used to explicitly provide a caption for
               that figure. For content that is only tangentially related, or that serves a separate
               purpose than the surrounding flow, the aside element should be used (and can itself
               wrap a figure). For example, a pull quote that repeats content from an article would
               be more appropriate in an aside than in a figure, because it isn't part of the content,
               it's a repetition of the content for the purposes of enticing readers or highlighting
               key topics.
            </p><cite>
               <p><strong><em>-  4.4.11 The figure element, Berjon et al. 2013</em></strong></p></cite></blockquote>
         <p>Figures, captions and the images inside present a few challenges. Because we allow
            authors to set height and width on both figure and the image inside we may find situations
            where the figure container is narrower than the image inside.
         </p>
         <p>To avoid this issue we test whether the figure width value is smaller than the width
            of the image inside. If it is, we use the width of the image as the width of the figure,
            otherwise we use the width of the image inside.
         </p>
         <p>We do the same thing for height in order to avoid squished images of captions that
            draw over the image because it's too small. If the height of the figure is smaller
            than the height of the image we use the height of the image, otherwise we use the
            height of the figure element.
         </p>
         <p>For both height and width we concatenate the attribute value with the string 'px'
            to make sure that it works in both straight CSS and with Prince and other CSS PDF
            generators
         </p>
         <p>Alignments can be different, it is possible to have a right-aligned image to live
            inside a centered container.
         </p>
         <p>Contrary to the HTML specification we use figure only to display images. We have a
            specialized template to address code blocks for program listings and can create additional
            elements
         </p><pre><code class="xml hljs">
&lt;xsl:template match="figure"&gt;
  &lt;xsl:element name="figure"&gt;
    &lt;xsl:if test="string(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="string(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="string(width) and (@width lt image/@width)"&gt;
        &lt;xsl:attribute name="width"&gt;
          &lt;xsl:value-of select="@width"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:attribute name="width"&gt;
          &lt;xsl:value-of select="image/@width"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="string(@height) and (@height lt image/@height)"&gt;
        &lt;xsl:attribute name="width"&gt;
          &lt;xsl:value-of select="@height"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:attribute name="width"&gt;
          &lt;xsl:value-of select="image/@height"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:if test="(@align)"&gt;
      &lt;xsl:attribute name="align"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="image"/&gt;
    &lt;xsl:apply-templates select="figcaption"/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="figcaption"&gt;
  &lt;figcaption&gt;&lt;xsl:apply-templates/&gt;&lt;/figcaption&gt;
&lt;/xsl:template&gt;
</code></pre><p>The data model for our content allows both figures and images to be used in the document.
            This is so we don't have to insert empty captions to figures just so we can add an
            image. If we don't want a caption we can insert the image directly on our document.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="image"&gt;
  &lt;xsl:element name="img"&gt;
    &lt;xsl:attribute name="src"&gt;
      &lt;xsl:value-of select="@src"/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="alt"&gt;
      &lt;xsl:value-of select="@alt"/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:if test="(@width)"&gt;
      &lt;xsl:attribute name="width"&gt;
        &lt;xsl:value-of select="@width"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@height)"&gt;
      &lt;xsl:attribute name="height"&gt;
        &lt;xsl:value-of select="@height"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@align)"&gt;
      &lt;xsl:attribute name="align"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre></section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="chapter" epub:type="chapter">
         <p class="rh">From XML to PDF: Part 1: Special Transformation</p>
         <h1 id="d2e1487">From XML to PDF: Part 1: Special Transformation</h1>
         <p>Rather than having to deal with
            <a href="http://www.w3.org/TR/2006/REC-xsl11-20061205/" label="XSL-FO">XSL-FO</a>, another XML based vocabulary to create PDF content, we'll use XSLT to create another
            HTML file and process it with
            <a href="http://dev.w3.org/csswg/css-page-3/" label="CSS Paged Media">CSS Paged Media</a> and the companion
            <a href="http://www.w3.org/TR/css-gcpm-3/" label="Generated Content for Paged Media">Generated Content for Paged Media</a> specifications to create PDF content.
         </p>
         <p>I'm not against XSL-FO but the structure of document is not the easiest or most intuitive.
            An example of XSL-FO looks like this:
         </p><pre><code class="xml hljs">&lt;?xml version="1.0" encoding="iso-8859-1"?&gt; (1)

  &lt;fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt; (2)
    &lt;fo:layout-master-set&gt; (3)
      &lt;fo:simple-page-master master-name="my-page"&gt;
        &lt;fo:region-body margin="1in"/&gt;
      &lt;/fo:simple-page-master&gt;
    &lt;/fo:layout-master-set&gt;

    &lt;fo:page-sequence master-reference="my-page"&gt; (4)
      &lt;fo:flow flow-name="xsl-region-body"&gt; (5)
        &lt;fo:block&gt;Hello, world!&lt;/fo:block&gt; (6)
      &lt;/fo:flow&gt;
    &lt;/fo:page-sequence&gt;
  &lt;/fo:root&gt;
    </code></pre><ol>
            <li>This is an XML declaration. XSL FO (XSLFO) belongs to XML family, so this is obligatory</li>
            <li>Root element. The obligatory namespace attribute declares the XSL Formatting Objects
               namespace
            </li>
            <li>Layout master set. This element contains one or more declarations of page masters
               and page sequence masters — elements that define layouts of single pages and page
               sequences. In the example, I have defined a rudimentary page master, with only one
               area in it. The area should have a 1 inch margin from all sides of the page
            </li>
            <li>Page sequence. Pages in the document are grouped into sequences; each sequence starts
               from a new page. Master-reference attribute selects an appropriate layout scheme from
               masters listed inside
               <em>&lt;fo:layout-master-set&gt;</em>. Setting master-reference to a page master name means that all pages in this sequence
               will be formatted using this page master
            </li>
            <li>Flow. This is the container object for all user text in the document. Everything contained
               in the flow will be formatted into regions on pages generated inside the page sequence.
               Flow name links the flow to a specific region on the page (defined in the page master);
               in our example, it is the body region
            </li>
            <li>Block. This object roughly corresponds to `&lt;div&gt;` in HTML, and normally includes a
               paragraph of text. I need it here, because text cannot be placed directly into a flow.
            </li>
         </ol>
         <p>Rather than define a flow of content and then the content CSS Paged Media uses a combination
            of new and existing CSS elements to format the content. For example, to define default
            page size and then add elements to chapter pages looks like this:
         </p><pre><code class="css hljs">
@page {
  size: 8.5in 11in;
  margin: 0.5in 1in;
  /* Footnote related attributes */
  counter-reset: footnote;

 @footnote {
    counter-increment: footnote;
    float: bottom;
    column-span: all;
    height: auto;
 }
}

@page chapter {
  @bottom-center {
    vertical-align: middle;
    text-align: center;
    content: element(heading);
  }
}
    </code></pre><p>The only problem with the code above is that there is no native broser support. For
            our demonstration we'll use Prince XML to tanslate our HTML/CSS file to PDF. In the
            not so distant future we will be able to do this transformation in the browser and
            print the PDF directly. Until then it's a two step process: Modifying the HTML we
            get from the XML file and running the HTML through Prince to get the PDF.
         </p>
         <h2>Modifying the HTML results</h2>
         <p>I'll use this opportunity to create an xslt customization layer to make changes only
            to the templates where we need to.
         </p>
         <p>We create a customization layer by importing the original stylesheet and making any
            necessary changes in the new stylesheet. Imported stylesheets have a lower precedence
            order than the local version so the local version will win if there is conflict.
         </p>
         <p>Only the templates defined in this stilesheet are overriden. If the template we use
            is not in this customization layer, the transformation engine will use the template
            in the base style sheet (book.xsl in this case)
         </p>
         <p>The style sheet is broken by templates and explained below.</p><pre><code class="xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;xsl:stylesheet
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    exclude-result-prefixes="xs"
    version="2.0"&gt;
      &lt;!-- First import the base stylesheet --&gt;
      &lt;xsl:import href="book.xsl"/&gt;

      &lt;!-- Define the output for this and all document children --&gt;
      &lt;xsl:output name="xhtml-out" method="xhtml"
      indent="yes" encoding="UTF-8" omit-xml-declaration="yes" /&gt;
    </code></pre><p>The first difference in the customization layer is that it imports another style sheet
            (
            <em>book.xsl</em>). We do this to avoid having to copy the entire style sheet and, if we make changes,
            having to make the changes in multiple places.
         </p>
         <p>We will then override the templates we need in order to get a single file to pass
            on to Prince or any other CSS Print Processor.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="book"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"/&gt;
    &lt;xsl:element name="title"&gt;
      &lt;xsl:value-of select="metadata/title"/&gt;
    &lt;/xsl:element&gt;
    &lt;xsl:element name="meta"&gt;
      &lt;xsl:attribute name="generator"&gt;
        &lt;xsl:value-of select="system-property('xsl:product-name')"/&gt;
        &lt;xsl:value-of select="system-property('xsl:product-version')"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:element&gt;

    &lt;!-- Load Typekit Font --&gt;
    &lt;script src="https://use.typekit.net/qcp8nid.js"&gt;&lt;/script&gt;
    &lt;script&gt;try{Typekit.load();}catch(e){}&lt;/script&gt;
    &lt;!-- Paged Media Styles --&gt;
    &lt;link rel="stylesheet" href="css/pm-style.css" /&gt;
    &lt;!-- Paged Media Definitions --&gt;
    &lt;link rel="stylesheet" href="css/paged-media.css"/&gt;
    &lt;xsl:if test="(code)"&gt;
      &lt;link rel="stylesheet" href="css/styles/railscasts.css" /&gt;
      &lt;script src="lib/highlight.pack.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      hljs.initHighlightingOnLoad();
    &lt;/script&gt;
    &lt;/xsl:if&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;xsl:attribute name="data-type"&gt;book&lt;/xsl:attribute&gt;
    &lt;xsl:apply-templates select="/" mode="toc"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
    </code></pre><p>Most of the root template deals with undoing some of the changes we made to create
            multiple pages.
         </p>
         <p>page */
            section[data-type='copyright'] { page: copyright }

            /* Dedication */
            section[data-type='dedication'] {
            page: dedicasetting up the different pages based on the data-type attribute.
         </p>
         <p>We use pm-styles.css to control the style of our documents specifically for our printed
            page application. We have to take into account the fact that Highlight.js is not working
            properly with Prince's Javascript implementation and that there are places where we
            don't want our paragraphs to be indented at all.
         </p>
         <p>We moved elements from the original section templates. We test whether we need to
            add the Highlight.JS since we dropped the multipage output.
         </p>
         <h2>Overriding the section template</h2>
         <p>Sections are the element type that got the biggest makeover. What we've done:</p>
         <ol>
            <li>Remove filename variable. It's not needed</li>
            <li>Remove the result document element since we are building a single file with all our
               content
            </li>
            <li>Change way we check for the type attribute in sections. It will now terminate with
               an error if the attribute is not found
            </li>
            <li>Add the element that will build our running footer (p class="rh") and assign the value
               of the secion's title to it
            </li>
         </ol><pre><code class="xml hljs">
&lt;!-- Override of the section template.--&gt;
&lt;xsl:template match="section"&gt;
  &lt;section&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="string(@type)"&gt;
        &lt;xsl:attribute name="data-type"&gt;
          &lt;xsl:value-of select="@type"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:message terminate="yes"&gt;
          Type attribute is required for paged media.
          Check your section tags for missing type attributes
        &lt;/xsl:message&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;

    &lt;xsl:if test="string(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;

    &lt;xsl:if test="string(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;!--
    Running header paragraph.
    --&gt;
    &lt;xsl:element name="p"&gt;
      &lt;xsl:attribute name="class"&gt;rh&lt;/xsl:attribute&gt;
        &lt;xsl:value-of select="title"/&gt;
    &lt;/xsl:element&gt; &lt;!-- closses rh class --&gt;

    &lt;xsl:apply-templates/&gt;
  &lt;/section&gt;
&lt;/xsl:template&gt;
    </code></pre><h2>Metadata</h2>
         <p>The Metadata section has been reworked into a new section with the title data-type.
            We set up the container section and assign title to the data-type attribute. We then
            apply all children templates.
         </p>
         <p>It is important to note that we've increased the number of children inside metadata
            so we'll have to be careful in making sure that we're using only one page for the
            title and another for the rest of the metadata if needed.
         </p><pre><code class="xml hljs">
&lt;!-- Metadata --&gt;
&lt;xsl:template match="metadata"&gt;
&lt;xsl:element name="section"&gt;
&lt;xsl:attribute name="data-type"&gt;titlepage&lt;/xsl:attribute&gt;
&lt;xsl:apply-templates/&gt;
&lt;/xsl:element&gt;
&lt;/xsl:template&gt;
    </code></pre><h2>Table of contents</h2>
         <p>The table of content creates anchor links (a href='#id') to the title h1 tags we create
            in the step below. We can do it this way because XSLT guarantees that all calls to
            generate-id for a given element (in this case the section/title elements) will return
            the same value for a given execution.
         </p>
         <p>This code depends on the empty toc placeholder element to place it. If the element
            is not present then the table of contents will be placed at the end of the document.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="toc"&gt;
  &lt;section data-type="toc"&gt;
    &lt;h1&gt;Table of Contents&lt;/h1&gt;
    &lt;nav&gt;
      &lt;ol&gt;
        &lt;xsl:for-each select="//section"&gt;
          &lt;xsl:element name="li"&gt;
            &lt;xsl:element name="a"&gt;
              &lt;xsl:attribute name="href"&gt;
              &lt;xsl:value-of select="concat('#', generate-id(.))"/&gt;
              &lt;/xsl:attribute&gt;
              &lt;xsl:value-of select="title"/&gt;
            &lt;/xsl:element&gt;
          &lt;/xsl:element&gt;
        &lt;/xsl:for-each&gt;
      &lt;/ol&gt;
    &lt;/nav&gt;
  &lt;/section&gt;
&lt;/xsl:template&gt;
    </code></pre><h2>Titles</h2>
         <p>The title element has only one addition. We add an ID attribute created using XPath's
            generate-id function on the parent section element.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="title"&gt;
  &lt;xsl:element name="h1"&gt;
    &lt;xsl:attribute name="id"&gt;
      &lt;xsl:value-of select="generate-id(..)"/&gt;
    &lt;/xsl:attribute&gt;

    &lt;xsl:if test="string(@align)"&gt;
      &lt;xsl:attribute name="align"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;

    &lt;xsl:if test="string(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;

    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:element&gt; &lt;!-- closes h1 --&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
    </code></pre><p>With all this in place we can now look to the CSS Paged Media file.</p>
      </section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="chapter" epub:type="chapter">
         <p class="rh">From XML to PDF Part 2: CSS Paged Media</p>
         <h1 id="d2e1595">From XML to PDF Part 2: CSS Paged Media</h1>
         <p>With the HTML ready, we can no look at the CSS stylesheet to process it into PDF.</p>
         <p>The extensions, pseudo elements and attributes we use are all part of the CSS Paged
            Media or Generated Content for Paged Media specifications. Where appropriate I've
            translated them to work on both PDF and HTML.
         </p>
         <h2>Book defaults</h2>
         <p>The first step in creating the default structure for the book using
            <em>@page</em> at-element.
         </p>
         <p>Our base definition does the following:</p>
         <ol>
            <li>Size the page to letter (8.5 by 11 inches), width first</li>
            <li>Use CSS notation for margins. In this case the top and bottom margin are 0.5 inches
               and left and right are 1 inch
            </li>
            <li>Reset the footnote counter</li>
            <li>Using the @footnote attribute do the following</li>
            <ol>
               <li>Increment the footnote counter</li>
               <li>Place footnote at the bottom using another value for the float attribute</li>
               <li>Span all columns</li>
               <li>Make the height as tall as necessary</li>
            </ol>
         </ol><pre><code class="css hljs">
/* STEP 1: DEFINE THE DEFAULT PAGE */
@page {
  size: 8.5in 11in; (1)
  margin: 0.5in 1in; (2)
  /* Footnote related attributes */
  counter-reset: footnote; (3)
  @footnote {
    counter-increment: footnote; (4.1)
    float: bottom; (4.2)
    column-span: all; (4.3)
    height: auto; (4.4)
    }
  }
</code></pre><p>In later sections we'll create named page templates and associate them to different
            portions of our written content.
         </p>
         <h2>Page counters</h2>
         <p>We define two conditions under which we reset the page counter: When we have a book
            followed by a part and when we have a book followed by the a first chapter.
         </p>
         <p>We do <strong>not</strong> reset the content when the path if from book to chapter to part.
         </p><pre><code class="css hljs">
body[data-type='book'] &gt; div[data-type='part']:first-of-type,
body[data-type='book'] &gt; section[data-type='chapter']:first-of-type { counter-reset: page; }
body[data-type='book'] &gt; section[data-type='chapter']+div[data-type='part'] { counter-reset: none }
</code></pre><h2>Matching content sections to page types</h2>
         <p>The next section of the style sheet is to match the content on our book to pages in
            our style sheet.
         </p>
         <p>The book is broken into sections with data-type attributes to indicate the type of
            content; we match the section[data-type] element to a page type along with some basic
            style definitions.
         </p>
         <p>We will further define the types of pages later in the style sheet.</p><pre><code class="css hljs">
/* Title Page*/
section[data-type='titlepage'] { page: titlepage }

/* Copyright page */
section[data-type='copyright'] { page: copyright }

/* Dedication */
section[data-type='dedication'] {
  page: dedication;
  page-break-before: always;
}

/* TOC */
section[data-type='toc'] {
  page: toc;
  page-break-before: always;
}
/* Leader for toc page */
section[data-type='toc'] nav ol li a:after {
  content: leader(dotted) ' ' target-counter(attr(href, url), page);
}

/* Foreword  */
section[data-type='foreword'] { page: foreword }

/* Preface*/
section[data-type='preface'] { page: preface }

/* Part */
div[data-type='part'] { page: part }

/* Chapter */
section[data-type='chapter'] {
  page: chapter;
  page-break-before: always;
}

/* Appendix */
section[data-type='appendix'] {
  page: appendix;
  page-break-before: always;
}

/* Glossary*/
section[data-type='glossary'] { page: glossary }

/* Bibliography */
section[data-type='bibliography'] { page: bibliography }

/* Index */
section[data-type='index'] { page: index }

/* Colophon */
section[data-type='colophon'] { page: colophon }
</code></pre><h2>Front matter formatting</h2>
         <p>For each page of front matter contnt (toc, foreword and preface) we define two pages:
            left and right. We do it this way to acommodate facing pages with numbers on ooposite
            sides (for two sided printout)
         </p>
         <p>For the front matter we chose to use Roman numerals on the bottom of the page</p><pre><code class="css hljs">
/* Comon Front Mater Page Numbering in lowercase ROMAN numerals*/
@page toc:right {
  @bottom-right-corner { content: counter(page, lower-roman) }
  @bottom-left-corner { content: normal }
}

@page toc:left  {
  @bottom-left-corner { content: counter(page, lower-roman) }
  @bottom-right-corner { content: normal }
}


@page foreword:right {
  @bottom-center { content: counter(page, lower-roman) }
  @bottom-left-corner { content: normal }
}

@page foreword:left  {
  @bottom-left-corner { content: counter(page, lower-roman) }
  @bottom-right-corner { content: normal }
}


@page preface:right {
  @bottom-center {content: counter(page, lower-roman)}
  @bottom-right-corner { content: normal }
  @bottom-left-corner { content: normal }
}

@page preface:left  {
  @bottom-center {content: counter(page, lower-roman)}
  @bottom-right-corner { content: normal }
  @bottom-left-corner { content: normal }
}
</code></pre><h2>Pages formatting</h2>
         <p>We use the same system we used in the front matter to do a few things with our content.</p>
         <p>We first remove page numbering from the title page and dedication by setting the numbering
            on both bottom corners to normal.
         </p><pre><code class="css hljs">
/* Common Content Page Numbering  in Arabic numerals 1... 199 */
@page titlepage{ /* Need this to clean up page numbers in titlepage in Prince*/
  margin-top: 18em;
  @bottom-right-corner { content: normal }
  @bottom-left-corner { content: normal }
}

@page dedication { /* Need this to clean up page numbers in titlepage in Prince*/
  page-break-before: always;
  margin-top: 18em;
  @bottom-right-corner { content: normal }
  @bottom-left-corner { content: normal }

}
</code></pre><p>Now we start working on our chapter pages. The first thing we do is to place our running
            header content in the bottom middle of the page, regardless of whether it's left or
            right.
         </p><pre><code class="css hljs">
@page chapter {
  @bottom-center {
    vertical-align: middle;
    text-align: center;
    content: element(heading);
  }
}
</code></pre><p>We next setup a blank page for our chapters and tell the reader that the page was
            intentionally left blank to prevent confusion
         </p><pre><code class="css hljs">
@page chapter:blank { /* Need this to clean up page numbers in titlepage in Prince*/
  @top-center { content: "This page is intentionally left blank" }
  @bottom-left-corner { content: normal;}
  @bottom-right-corner {content:normal;}
}
</code></pre><p>Then we number the pages the same way that we did for our front matter except that
            we use narabic numerals instead of Roman.
         </p><pre><code class="css hljs">
@page chapter:right  {
  @bottom-right-corner { content: counter(page) }
  @bottom-left-corner { content: normal }
}

@page chapter:left {
  @bottom-left-corner { content: counter(page) }
  @bottom-right-corner { content: normal }
}

@page appendix:right  {
  @bottom-right-corner { content: counter(page) }
  @bottom-left-corner { content: normal }
}

@page appendix:left {
  @bottom-left-corner { content: counter(page) }
  @bottom-right-corner { content: normal }
}

@page glossary:right,  {
  @bottom-right-corner { content: counter(page) }
  @bottom-left-corner { content: normal }
}

@page glossary:left, {
  @bottom-left-corner { content: counter(page) }
  @bottom-right-corner { content: normal }
}

@page bibliography:right  {
  @bottom-right-corner { content: counter(page) }
  @bottom-left-corner { content: normal }
}

@page bibliography:left {
  @bottom-left-corner { content: counter(page) }
  @bottom-right-corner { content: normal }
}

@page index:right  {
  @bottom-right-corner { content: counter(page) }
  @bottom-left-corner { content: normal }
}

@page index:left {
  @bottom-left-corner { content: counter(page) }
  @bottom-right-corner { content: normal }
}
</code></pre><h2>Running footer</h2>
         <p>We now style the running footer. This is the same footer that we creataed when converting
            the XML to HTML.
         </p><pre><code class="css hljs">
p.rh {
  position: running(heading);
  text-align: center;
  font-style: italic;
}
</code></pre><h2>Footnotes and cross references</h2>
         <p>Footnotes are tricky, they consist of two parts, the footnote-call and the footnote
            content itself. I'm still trying to figure out what the correct markup should be for
            marking up footnotes.
         </p>
         <p>We've also defined a special class of links that appends a string and the the destination's
            page number.
         </p><pre><code class="css hljs">
/* Footnotes */
span.footnote {
  float: footnote;
}

::footnote-marker {
  content: counter(footnote);
  list-style-position: inside;
}

::footnote-marker::after {
  content: '. ';
}

::footnote-call {
  content: counter(footnote);
  vertical-align: super;
  font-size: 65%;
}

/* XReferences */
a.xref[href]::after {
    content: ' [See page ' target-counter(attr(href), page) ']'
}
</code></pre><h2>PDF Bookmarks</h2>
         <p>PDF bookmarks allow you to navigate your content form the left side bookmark menu
            as show in the image below
         </p>
         <figure width="244px" height="352px"><img src="http://publishing-project.rivendellweb.net/wp-content/uploads/2015/02/pdf-bookmarks.png" alt="PDF Bookmarks" width="244px" height="352px" /><figcaption>
               <p>Exam ple of PDF Bookmarks</p>
            </figcaption>
         </figure>
         <p>For each heading level we do the following things for both Antenna House and PrinceXML:</p>
         <ul>
            <li>Set up the bookmark level</li>
            <li>Set up whether it's open or closed</li>
            <li>Set up the label for the bookmark</li>
         </ul>
         <p>Only heading 1, 2 and 3 are set up, level 4, 5 and 6 are only set up as bookmarks
            only.
         </p><pre><code class="css hljs">
section[data-type='chapter'] h1 {
  -ah-bookmark-level: 1;
  -ah-bookmark-state: open;
  -ah-bookmark-label: content();
  prince-bookmark-level: 1;
  prince-bookmark-state: closed;
  prince-bookmark-label: content();
}

section[data-type='chapter'] h2 {
  -ah-bookmark-level: 2;
  -ah-bookmark-state: closed;
  -ah-bookmark-label: content();
  prince-bookmark-level: 2;
  prince-bookmark-state: closed;
  prince-bookmark-label: content();
}

section[data-type='chapter'] h3 {
  -ah-bookmark-level: 3;
  -ah-bookmark-state: closed;
  -ah-bookmark-label: content();
  prince-bookmark-level: 3;
  prince-bookmark-state: closed;
  prince-bookmark-label: content();
}

section[data-type='chapter'] h4 {
  -ah-bookmark-level: 4;
  prince-bookmark-level: 4;
}

section[data-type='chapter'] h5 {
  -ah-bookmark-level: 5;
  prince-bookmark-level: 5;
}

section[data-type='chapter'] h6 {
  -ah-bookmark-level: 6;
  prince-bookmark-level: 6;
}
</code></pre><h2>Running PrinceXML</h2>
         <p>Once we have the HTML file ready we can run it through PrinceXML to get our PDF using
            CSS stylesheet for Paged Media we discussed above. The command to run the conversion
            for a book.html file is:
         </p><pre><code class="bash hljs">
$ prince --verbose book.html test-book.pdf
</code></pre><p>Because we added the stylesheet link directly to the HTML document we can skip declaring
            it in the conversion itself. This is always a cause of errors and frustratoins for
            me so I thought I'd save everyone else the hassle.
         </p>
      </section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="chapter" epub:type="chapter">
         <p class="rh">From XML to PDF Part 3: CSS Styles for Paged Media</p>
         <h1 id="d2e1731">From XML to PDF Part 3: CSS Styles for Paged Media</h1>
         <p>This is the generated CSS from the SCSS style sheets (see the scss/ directory for
            the source material.) I've chosen to document the resulting stylesheet here and document
            the SCSS source in another document to make life simpler for people who don't want
            to deal with SASS or who want to see what the style sheets look like.
         </p>
         <p>Typography derived from work done at this URL:
            <a href="http://bit.ly/16N6Y2Q" label="http://bit.ly/16N6Y2Q">http://bit.ly/16N6Y2Q</a></p>
         <p>The following scale (also using minor third progression) may also help:
            <a href="http://bit.ly/1DdVbqK" label="http://bit.ly/1DdVbqK">http://bit.ly/1DdVbqK</a></p>
         <p>Feel free to play with these and use them as starting point for your own work :)</p>
         <p>The project currently uses these fonts:</p>
         <ul>
            <li>Roboto Slab for headings</li>
            <li>Roboto for body copy</li>
            <li>Source Code Pro for code blocks and preformated text</li>
         </ul>
         <h2>Font Imports</h2>
         <p>Even though SCSS Lint throws a fit when I put font imports in a stylesheet because
            they stop asynchronous operations, I'm doing it to keep the HTML files clean and because
            we are not loading the CSS on the page, we're just using it to process the PDF file.
         </p>
         <p>Eventually I'll switch to locally hosted fonts using bulletproof font syntax (
            <a href="http://www.paulirish.com/2009/bulletproof-font-face-implementation-syntax/" label="discussed in this post by Paul Irish">discussed in this post by Paul Irish</a> and available for use at
            <a href="http://www.fontsquirrel.com/tools/webfont-generator" label="Font Squirrel">Font Squirrel</a>.
         </p>
         <p>At this point we are not dealing with
            <a href="http://bit.ly/1ul3XBx" label="font subsetting">font subsetting</a> but we may in case we need to depending on the font licensing or file size.
         </p><pre><code class="css hljs">
@import url(http://fonts.googleapis.com/css?family=Roboto:100italic,100,400italic,700italic,300,700,300italic,400);
@import url(http://fonts.googleapis.com/css?family=Roboto+Slab:400,700);
@import url(http://fonts.googleapis.com/css?family=Source+Code+Pro:300,400);
</code></pre><h2>Defaults</h2>
         <p>Now that we've loaded the fonts we can create our defaults for the document. The `html`
            element defines vertical overflow and text size adjustment for Safari and Windows
            browsers.
         </p><pre><code class="css hljs">
html {
  overflow-y: scroll;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
}
</code></pre><p>The
            <em>body</em> selector will handle most of the base formatting for the the document.
         </p>
         <p>The selector sets up the following aspects of the page:</p>
         <ul>
            <li>background and font color</li>
            <li>font family, size and weight</li>
            <li>line height</li>
            <li>left and right padding (overrides the base document's padding)</li>
            <li>orphans and widows</li>
         </ul><pre><code class="css hljs">
body {
  background-color: #fff;
  color: #554c4d;
  font-family: 'Roboto', 'Helvetica Neue', Helvetica, sans-serif;
  font-size: 1em;
  font-weight: 100;
  line-height: 1.1;
  orphans: 4;
  padding-left: 0;
  padding-right: 0;
  widows: 2;
}
</code></pre><h2>Blockquotes, Pullquotes and Marginalia</h2>
         <p>It's fairly easy to create sidebars in HTML so I've played a lot with pull quotes,
            blockquotes and asides as a way to move the content around with basic CSS. We can
            do further work by tuning the CSS
         </p><pre><code class="css hljs">
aside {
  border-bottom: 3px double #ddd;
  border-top: 3px double #ddd;
  color: #666;
  line-height: 1.4em;
  padding-bottom: .5em;
  padding-top: .5em;
  width: 100%;
}

aside .pull {
  margin-bottom: .5em;
  margin-left: -20%;
  margin-top: .2em;
}
</code></pre><p>The
            <em>magin-notes*</em> and
            <em>content*</em> move the content to the corresponding side of the page without having to create specific
            CSS to do so. The downside is that, as with many things in CSS, you are stuck with
            the provided values and will have to modify them to suit your needs.
         </p><pre><code class="css hljs">
.margin-notes,
.content-left {
  font-size: .75em;
  margin-left: -230px;
  margin-right: 20px;
  text-align: right;
  width: 230px;
}

.margin-notes-right,
.content-right {
  font-size: .75em;
  margin-left: 760px;
  margin-right: -20px;
  position: absolute;
  text-align: left;
  width: 230px;
}

.content-right {
  font-size: .75em;
  margin-left: 760px;
  margin-right: -20px;
  position: absolute;
  text-align: left;
  width: 230px;
}

.content-right ul,
.content-left ul {
  list-style: none;
}
</code></pre><p>The opening class style creates a large distinguishing block container for opening
            text. This is useful when you have a summary paragraph at the beginning of your document
            or some other opening piece of text to go at the top of your document
         </p><pre><code class="css hljs">
.opening {
  border-bottom: 3px double #ddd;
  border-top: 3px double #ddd;
  font-size: 2em;
  margin-bottom: 10em;
  padding-bottom: 2em;
  padding-top: 2em;
  text-align: center;
}
</code></pre><p>Blockquotes present the enclosed text in larger italic font with a solid bar to the
            left of the content. Because the font is larger I've added a little extra padding
            to the paragraphs inside the blockquote
         </p><pre><code class="css hljs">
blockquote {
  border-left: 5px solid #ccc;
  color: #222023;
  font-size: 1.5em;
  font-style: italic;
  font-weight: 100;
  margin-bottom: 2em;
  margin-left: 4em;
  margin-right: 4em;
  margin-top: 2em;
}
blockquote p {
  padding-left: .5em;
}
</code></pre><p>The pullquote classes were modeled after an ESPN article and look something like this:</p>
         <figure width="800px" height="297px"><img src="http://publishing-project.rivendellweb.net/wp-content/uploads/2015/02/example-pullquote.png" alt="example pullquote" width="800px" height="297px" /><figcaption>
               <p>Example pullquote</p>
            </figcaption>
         </figure>
         <p>The original was hardcoded to pixels. Where possible I've changed the values to em
            to provide a more responsive
         </p><pre><code class="css hljs">
.pullquote {
  border-bottom: 18px solid #000;
  border-top: 18px solid #000;
  font-size: 2.25em;
  font-weight: 700;
  letter-spacing: -.02em;
  line-height: 2.125em;
  margin-right: 2.5em;
  padding: 1.25em 0;
  position: relative;
  width: 200px;
}
.pullquote p {
  color: #00298a;
  font-weight: 700;
  text-transform: uppercase;
  z-index: 1;
}
.pullquote p:last-child {
  line-height: 1.25em;
  padding-top: 2px;
}
.pullquote cite {
  color: #333;
  font-size: 1.125em;
  font-weight: 400;
}
</code></pre><h2>Paragraphs</h2>
         <p>The paragraph selector creates the default paragraph formatting with a size of 1em
            (equivalent to 16 pixels) and a line height of 1.3 em (20.8 pixels)
         </p><pre><code class="css hljs">
p {
  font-size: 1em;
  margin-bottom: 1.3em;
}
</code></pre><p>To indent all paragraphs but the first we use the sibling selector we indent all paragraphs
            that are the next sibling of another paragraph element (that is: the next child of
            the same parent).
         </p>
         <p>The first paragraph doesn't have a paragraph sibling so the indent doesn't happen
            but all other paragraphs are indented
         </p><pre><code class="css hljs">
p + p {
  text-indent: 2em;
}
</code></pre><p>Rather than use pseudo elements (
            <em>:first-line</em> and
            <em>:first-letter</em>) we use classes to give authors the option to use these elements.
         </p><pre><code class="css hljs">
.first-line {
  font-size: 1.1em;
  text-indent: 0;
  text-transform: uppercase;
}

.first-letter {
  float: left;
  font-size: 7em;
  line-height: .8em;
  margin-bottom: -.1em;
  padding-right: .1em;
}
</code></pre><h2>Lists</h2>
         <p>The only thing we do for list and list items is to indicate what type of list we'll
            use as our default square for unordered list and Arabic decimals for our numbered
            lists.
         </p><pre><code class="css hljs">
ul li {
  list-style: square;
}

ol li {
  list-style: decimal;
}
</code></pre><h2>Figures and captions</h2>
         <p>The only interesting aspect of the CSS we use for figures is the counter. The
            <em>figure figcaption::before</em> selector creates automatic text that is inserted before each caption. This text is
            the string "Figure", the value of our figure counter and the string ": ".
         </p>
         <p>This makes it easier to insert figures without having to change the captions for all
            figures after the one we inserted. The figure counter is reset for every chapter.
            I'm researching ways to get the figure numbering across chapters.
         </p><pre><code class="css hljs">
figure {
  counter-increment: figure_count;
  margin-bottom: 1em;
  margin-top: 1em;
}
figure figcaption {
  font-weight: 700;
  padding-bottom: 1em;
  padding-top: .2em;
}

figure figcaption::before {
  content: "Figure " counter(figure_count) ": ";
}
</code></pre><h2>Headings</h2>
         <p>Headings are configured in two parts. The first one sets common attributes to all
            headings:
            <em>font-family</em>,
            <em>font-weight</em>,
            <em>hyphens</em>,
            <em>line-height</em>, margins and
            <em>text-transform</em>.
         </p>
         <p>It's this attribute that needs a little more discussion. Using text-transform we make
            all headings uppercase without having to write them that way
         </p><pre><code class="css hljs">
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: 'Roboto Slab', sans-serif;
  font-weight: 400;
  hyphens: none;
  line-height: 1.2;
  margin: 1.414em 0 .5em;
  text-transform: uppercase;
}
</code></pre><p>In the second part of our heading styles we work on rules that only apply to one heading
            at a time. Things such as size and specific attributes (like removing the top margin
            on the h1 elements) need to be handled need to be handled individually
         </p><pre><code class="css hljs">
h1 {
  font-size: 3.157em;
  margin-top: 0;
}

h2 {
  font-size: 2.369em;
}

h3 {
  font-size: 1.777em;
}

h4 {
  font-size: 1.333em;
}

h4,
h5,
h6 {
  text-align: inherit;
}
</code></pre><h2>Different parts of the book</h2>
         <p>There are certains aspects of the book that need different formatting from our defaults.</p>
         <p>We use the element[attribute=name] syntax to identify which section we want to work
            with and then tell it the element within the section that we want to change.
         </p>
         <p>For example, in the bibliography (a section with the
            <em>data-type='bibliography</em> attribute) we want all paragraphs to be left aligned and all paragraphs to have no
            margin (basicallwe we are undoing the indentation for paragraphs with sibling paragraphs
            within the bibliography section)
         </p><pre><code class="css hljs">
section[data-type='bibliography'] p {
  text-align: left;
}
section[data-type='bibliography'] p + p {
  text-indent: 0 !important;
}
</code></pre><p>The same logic applies to the other sections that we're customizing. We tell it what
            type of section we are working with and what element inside that sectin we want to
            change.
         </p><pre><code class="css hljs">
section[data-type='titlepage'] h1,
section[data-type='titlepage'] h2,
section[data-type='titlepage'] p {
  text-align: center;
}

section[data-type='dedication'] h1,
section[data-type='dedication'] h2 {
  text-align: center;
}
section[data-type='dedication'] p {
  text-align: left;
}
section[data-type='dedication'] p + p {
  text-indent: 0 !important;
}
</code></pre><h2>Preformatted code blocks</h2>
         <p>A lot of what I write is technical and requires code examples. We take a two pronged
            approach to the fenced code blocks.
         </p>
         <p>We format some aspects our content (wrap, font-family, size, line height and wether
            to do page breaks inside the content) locally and hand off syntax highlighting to
            <a href="https://highlightjs.org/" label="highlight.js">highlight.js</a> with a style to mark the content differently.
         </p><pre><code class="css hljs">
pre {
  overflow-wrap: break-word;
  white-space: pre-line !important;
  word-wrap: break-word;
}
pre code {
  font-family: 'Source Code Pro', monospace;
  font-size: 1em;
  line-height: 1.2em;
  page-break-inside: avoid;
}
</code></pre><h2>Miscelaneous classes</h2>
         <p>Rather than for people to justify text we provide a class to make it so. I normally
            justify at the div or section level but it's not always necessary or desirable.
         </p>
         <p>Code will be used in a future iteration of the code to highlight inline snippets (think
            of it as an inline version of the &lt;pre&gt;&lt;code&gt; tag combination)
         </p><pre><code class="css hljs">
.justified {
  text-align: justify;
}

</code></pre><h2>Columns</h2>
         <p>The last portion of the stylesheet deals with columns. I've set up 2 set of rules
            for 2 and 3 column with similar attributes. In the SCSS source these are created with
            a column mixin.
         </p><pre><code class="css hljs">
.columns2 {
  column-count: 2;
  column-gap: 3em;
  column-fill: balance;
  column-span: none;
  line-height: 1.25em;
  width: 100%;
}
.columns2 p:first-of-type {
  margin-top: 0;
}
.columns2 p + p {
  text-indent: 2em;
}
.columns2 p:last-of-type {
  margin-bottom: 1.25em;
}

.columns3 {
  column-count: 3;
  column-gap: 10px;
  column-fill: balance;
  column-span: none;
  width: 100%;
}
.columns3 p:first-of-type {
  margin-top: 0;
}
.columns3 p:not:first-of-type {
  text-indent: 2em;
}
.columns3 p:last-of-type {
  margin-bottom: 1.25em;
}
</code></pre></section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="chapter" epub:type="chapter">
         <p class="rh">Converting to ePub</p>
         <h1 id="d2e1943">Converting to ePub</h1>
         <blockquote>
            <p>This chapter is a draft! This style sheet is under development</p>
         </blockquote>
         <p>Perhaps the most ambitious part of the proof of concept is to convert the XML content
            to an ePub book that would pass epubcheck validation. To accomplish this we'll create
            another customization layer to acommodate the special syntax and additional content
            needed to create the ePub 3 package.
         </p>
         <p>This is more complicated than the creation of the single file for generating PDF.
            The epub specification is more complex and requires a lot more auxiliary files and
            directories with very specific formatting. I wonder if some of them need to be XML
            files at all.
         </p>
         <p>Take the<em>package.opf</em>, for example. As portable as XML is and as many XML parsers are there in the wild,
            it would work much better if we do the same code in JSON, YAML, or other similar formats.
         </p>
         <p></p>
      </section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="chapter" epub:type="chapter">
         <p class="rh">Tools and dependencies</p>
         <h1 id="d2e1959">Tools and dependencies</h1>
         <p>Because we use XML we can't just dump our code in the browser or the PDF viewer and
            expect it to appear just like HTML content.
         </p>
         <p>We need to prepare our content for conversion to PDF before we can view it. There
            are also front-end web development best practices to follow.
         </p>
         <p>This chapter will discuss tools to accomplish both tasks from one build file.</p>
         <h2>What software we need</h2>
         <p>For this to work you need the following software installed:</p>
         <ul>
            <li>Java (version 1.7 or later)</li>
            <li>Node.js (0.10.35 or later)</li>
         </ul>
         <p>Once you have java installed, you can install the following Java package</p>
         <ul>
            <li><a href="http://sourceforge.net/projects/saxon/files/latest/download?source=files" label="Saxon">Saxon</a> (9.0.6.4 for Java)
               
            </li>
         </ul>
         <p>A note about Saxon for OxygenXML users: OxygenXML comes with a version of Saxon Enterprise
            Edition. We'll use a different version to make it easier to use outside the editor.
         </p>
         <p>Node packages are handled through NPM, the Node Package Manager. On the Node side
            we need at least the
            <em>grunt-cli</em> package installed globally. TO do so we use this command:
         </p><pre><code class="bash hljs">
$ npm install -g grunt-cli
</code></pre><p>The -g flag will install this globally, as opposed to installing it in the project
            directory.
         </p>
         <p>Now that we have the required sotfware installed we can move ahead and create our
            configuration files.
         </p>
         <h2>Optional: Ruby, SCSS-Lint and SASS</h2>
         <p>The only external dependencies you need to worry about are Ruby, SCSS-Lint and SASS.
            Ruby comes installe in most (if not all) Macintosh and Linux systems; an
            <a href="http://rubyinstaller.org/" label="installer for Windows">installer for Windows</a> is also available.
         </p>
         <p>SASS (syntactically awesome style sheets) are a superset of CSS that brings to the
            table enhancements to CSS that make life easier for designers and the people who have
            to create the stylesheets. I've taken advantage of these features to simplify my stylesheets
            and to save myself from repetitive and tedious tasks.
         </p>
         <p>SASS, the main tool, is written in Ruby and is available as a Ruby Gem.</p>
         <p>To install SASS, open a terminal/command window and type:</p><pre><code class="bash hljs">
$ gem install sass
</code></pre><p>Note that on Mac and Linux you may need to run the command as a superuser:</p><pre><code class="bash hljs">
$ gem install sass
</code></pre><p>If you get an error, you probably need to install the gem as an administrator. Try
            the following command
         </p><pre><code class="bash hljs">
$ sudo gem install sass
</code></pre><p>And enter your password when prompted.</p>
         <p>SCSS-Lint is a linter for the SCSS flavor of SASS. As with other linters it will detect
            errors and potential erors in your SCSS style sheets. As with SASS, SCSSLint is a
            Ruby Gem that can be installed with the following command:
         </p><pre><code class="bash hljs">
$ sudo gem install scss-lint
</code></pre><p>The same caveat about errors and installing as an administrator apply.</p>
         <blockquote>
            <p>&gt;Ruby, SCSS-Lint and SASS are only necessary if you plan to change the SCSS/SASS files.
               If you don't you can skip the Ruby install and work directly with the CSS files
            </p>
            <p>If you want to peek at the SASS source look at the files under the scss directory.</p>
         </blockquote>
         <h2>Installing Node packages</h2>
         <p>Grunt is a Node.js based task runner. It's a declarative version of Make and similar
            tools in other languages. Since Grunt and it's associated plugins are Node Packages
            we need to configure Node.
         </p>
         <p>At the root of the project there's a
            <em>package.json</em> file where all the files necessary for the project have already been configured.
            All that is left is to run the install command.
         </p><pre><code class="bash hljs">
npm install
</code></pre><p>This will install all the packages indicated in configuration file and all their dependencies;
            go get a cup of coffee as this may take a while in slower machines.
         </p>
         <p>As it installs the software it'll display a list of what it installed and when it's
            done you'll have all the packages.
         </p>
         <p>The final step of the node installation is to run bower, a front end package manager.
            It is not configured by default but you can use it to manage packages such as jQuery,
            Highlight.JS, Polymer web components and others.
         </p>
         <h2>Grunt and Front End Development best practices</h2>
         <p>While developing the XML and XSL for this project, I decided that it was also a good
            chance to test front end development tools and best practices for styling and general
            front end development.
         </p>
         <p>One of the best known tools for front end development is Grunt. It is a Javascript
            task runner and it can do pretty much whatever you need to do in your development
            environment. The fact that Grunt is written in Javascript saves developers from having
            to learn another language for task management.
         </p>
         <p>Grunt has its own configuration file (
            <em>Gruntfile.js</em>) one of which is provided as a model for the project.
         </p>
         <p>As currently written the Grunt file provides the following functionality in the assigned
            tasks. Please note that the tasks with an asterisk have subtasks to perform specific
            functions. We will discuss the subtasks as we look at each portion of the file and
            its purpose.
         </p><pre><code class="bash hljs">
      autoprefixer  Prefix CSS files. *
             clean  Clean files and folders. *
            coffee  Compile CoffeeScript files into JavaScript *
              copy  Copy files. *
            jshint  Validate files with JSHint. *
              sass  Compile Sass to CSS *
            uglify  Minify files with UglifyJS. *
             watch  Run predefined tasks whenever watched files change.
          gh-pages  Publish to gh-pages. *
    gh-pages-clean  Clean cache dir
             mkdir  Make directories. *
          scsslint  Validate `.scss` files with `scss-lint`. *
             shell  Run shell commands *
              sftp  Copy files to a (remote) machine running an SSH daemon. *
           sshexec  Executes a shell command on a remote machine *
             uncss  Remove unused CSS *
              lint  Alias for "jshint" task.
          lint-all  Alias for "scsslint", "jshint" tasks.
          prep-css  Alias for "scsslint", "sass:dev", "autoprefixer" tasks.
           prep-js  Alias for "jshint", "uglify" tasks.
      generate-pdf  Alias for "shell:single", "shell:prince" tasks.
 generate-pdf-scss  Alias for "scsslint", "sass:dev", "shell:single",
                    "shell:prince" tasks.
      generate-all  Alias for "shell" task.
</code></pre><p>The first thing we do is declare two variables (module and require) as global for
            JSLint and JSHint. Otherwise we'll get errors and it's not essential to declare them
            before they are used.
         </p>
         <p>We then wrap the Gruntfile with a self executing function as a deffensive coding strategy.</p>
         <p>When concatenating Javascript files there may be some that use strict Javascript and
            some that don't; With Javascript
            <a href="http://code.tutsplus.com/tutorials/javascript-hoisting-explained--net-15092" label="variable hoisting">variable hoisting</a> the use stric declaration would be placed at the very top of the concatenated file
            making all the scripts underneat use the strict declaration.
         </p>
         <p>The function wrap prevents this by making the use strict declaration local to the
            file where it was written. None of the other templates will be affected and they will
            still execute from the master stylesheet. It's not essential for Grunt drivers (Gruntfile.js
            in our case) but it's always a good habit to get into.
         </p>
         <h2>Setup</h2><pre><code class="javascript hljs">
/*global module */
/*global require */
(function () {
  'use strict';
  module.exports = function (grunt) {
    // require it at the top and pass in the grunt instance
    // it will measure how long things take for performance
    //testing
    require('time-grunt')(grunt);

    // load-grunt will read the package file and automatically
    // load all our packages configured there.
    // Yay for laziness
    require('load-grunt-tasks')(grunt);
</code></pre><p>The first two elements that work with our content are
            <em>time-grunt</em> and
            <em>load-grunt-tasks</em>.
         </p>
         <p>Time-grunt provides a breakdown of time and percentage of total execution time for
            each task performed in this particular Grunt run. The example below illustrates the
            result when running multiple tasks (bars reduced in length for formatting.)
         </p><pre><code class="bash hljs">
Execution Time (2015-02-01 03:43:57 UTC)
loading tasks      983ms  ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 12%
scsslint:allFiles   1.1s  ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 13%
sass:dev           441ms  ▇▇▇▇▇▇▇▇▇ 5%tps://github.com/addyosmani/g▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 18%
shell:single        1.2s  ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 14%
shell:prince        2.9s  ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 36%
Total 8.1s
</code></pre><p>Load-grunt-tasks automates the loading of packages located in the
            <em>package.json</em> configuration file. It's specially good for forgetful people like me whose main mistake
            when building Grunt-based tool chains is forgetting to load the plugins to use :-).
         </p>
         <h2>Javascript</h2><pre><code class="javascript hljs">
    grunt.initConfig({

      // JAVASCRIPT TASKS
      // Hint the grunt file and all files under js/
      // and one directory below
      jshint: {
        files: ['Gruntfile.js', 'js/{,*/}*.js'],
        options: {
          reporter: require('jshint-stylish')
            // options here to override JSHint defaults
        }
      },

      // Takes all the files under js/ and selected files under lib
      // and concatenates them together. I've chosen not to mangle
      // the compressed file
      uglify: {
        dist: {
          options: {
            mangle: false,
            sourceMap: true,
            sourceMapName: 'css/script.min.map'
          },
          files: {
            'js/script.min.js': ['js/video.js', 'lib/highlight.pack.js']
          }
        }
      },
</code></pre><p>JSHint will lint the Gruntfile itself and all files under the js/ directory for errors
            and potential errors. 
         </p><pre><code class="bash hljs">
[20:58:14] carlos@rivendell xml-workflow 13902$ grunt jshint
Running "jshint:files" (jshint) task

Gruntfile.js
  line 9    col 33  Missing semicolon.
  line 269  col 6   Missing semicolon.

  ⚠  2 warnings

Warning: Task "jshint:files" failed. Use --force to continue.

Aborted due to warnings.
</code></pre><p>Uglify allow us to concatenate our Javascript files and, if we choose to, further
            reduce the file size by mangling the code (See this [page](http://lisperator.net/uglifyjs/mangle)
            for an explanation of what mangle is and does). I've chosen not to mangle the code
            to make it easier to read. May add it as an option for production deployments.
         </p>
         <h2>SASS and CSS</h2>
         <p>As mentioned elsewhere I chose to use the SCSS flavor of SASS because it allows me
            to do some awesome things with CSS that I wouldn't be able to do with CSS alone. 
         </p>
         <p>The first task with SASS is convert it to CSS. For this we have two separate tasks.
            One for development (dev task below) where we pick all the files from the scss directory
            (the entire files section is equivalent to writing
            <em>scss/*.scss</em>) and converting them to files with the same name in the css directory.
         </p><pre><code class="javascript hljs">
      // SASS RELATED TASKS
      // Converts all the files under scss/ ending with .scss
      // into the equivalent css file on the css/ directory
      sass: {
        dev: {
          options: {
            style: 'expanded'
          },
          files: [{
            expand: true,
            cwd: 'scss',
            src: ['*.scss'],
            dest: 'css',
            ext: '.css'
          }]
        },
        production: {
          options: {
            style: 'compact'
          },
          files: [{
            expand: true,
            cwd: 'scss',
            src: ['*.scss'],
            dest: 'css',
            ext: '.css'
          }]
        }
      },
</code></pre><p>There are two similar versions of the task. The development version will produce the
            format below, which is easier to read and easier to troubleshoot (css-lint, discussed
            below, tells you what line the error or warning happened in.)
         </p><pre><code class="css hljs">
@import url(http://fonts.googleapis.com/css?family=Roboto:100italic,100,400italic,700italic,300,700,300italic,400);
@import url(http://fonts.googleapis.com/css?family=Montserrat:400,700);
@import url(http://fonts.googleapis.com/css?family=Roboto+Slab:400,700);
@import url(http://fonts.googleapis.com/css?family=Source+Code+Pro:300,400);
html {
  font-size: 16px;
  overflow-y: scroll;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
}

body {
  background-color: #fff;
  color: #554c4d;
  color: #554c4d;
  font-family: Adelle, Rockwell, Georgia, 'Times New Roman', Times, serif;
  font-size: 1em;
  font-weight: 100;
  line-height: 1.1;
  padding-left: 10em;
  padding-right: 10em;
}
</code></pre><p>The production code compresses the output. It deletes all tabs and carriage returns
            to produce cod elike the one below. It reduces the file size by eliminating spaces,
            tabs and carriage returns inside the rules, otherwise both versions are equivalent.
            
         </p><pre><code class="css hljs">
@import url(http://fonts.googleapis.com/css?family=Roboto:100italic,100,400italic,700italic,300,700,300italic,400);
@import url(http://fonts.googleapis.com/css?family=Montserrat:400,700);
@import url(http://fonts.googleapis.com/css?family=Roboto+Slab:400,700);
@import url(http://fonts.googleapis.com/css?family=Source+Code+Pro:300,400);
html { font-size: 16px; overflow-y: scroll; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }

body { background-color: #fff; color: #554c4d; color: #554c4d; font-family: Adelle, Rockwell, Georgia, 'Times New Roman', Times, serif; font-size: 1em; font-weight: 100; line-height: 1.1; padding-left: 10em; padding-right: 10em; }
</code></pre><p>I did consider adding
            <a href="https://github.com/gruntjs/grunt-contrib-cssmin" label="cssmin">cssmin</a> but decided against it for two reasons:
         </p>
         <p>SASS already concatenates all the files when it imports files from the modules and
            partials directory so we're only working with one file for each version of the project
            (html and PDF)
         </p>
         <p>The only other file we'd have to add, normalize.css, is a third party library that
            I'd rather leave along rather than mess with. 
         </p>
         <p>The
            <em>scsslint</em> task is a wrapper for the scss-lint Ruby Gem that must be installed on your system.
            It warns you of errors and potential errors in your SCSS stylesheets. 
         </p>
         <p>We've chosen to force it to run when it finds errors. We want the linting tasks to
            be used as the developer's discretion, there may be times when vendor prefixes have
            to be used or where colors have to be defined multiple times to acommodate older browsers.
            
         </p><pre><code class="javascript hljs">
      // I've chosen not to fail on errors or warnings.
      scsslint: {
        allFiles: [
          'scss/*.scss',
          'scss/modules/_mixins.scss',
          'scss/modules/_variables.scss',
          'scss/partials/*.scss'
        ],
        options: {
          config: '.scss-lint.yml',
          force: true,
          colorizeOutput: true
        }
      },
</code></pre><p>Grunt's
            <a href="https://github.com/nDmitry/grunt-autoprefixer" label="autoprefixer">autoprefixer</a> task uses the
            <a href="http://caniuse.com/" label="CanIUse database">CanIUse database</a> to determine if properties need a vendor prefix and add the prefix if they do.
         </p>
         <p>This becomes important for older browsers or when vendors drop their prefix for a
            given property. Rather than having to keep up to date on all vendor prefixed properties
            you can tell autoprefixer what browsers to test for (last 2 versions in this case)
            and let it worry about what needs to be prefixed or not. 
         </p><pre><code class="javascript hljs">
      autoprefixer: {
        options: {
          browsers: ['last 2']
        },

        files: {
          expand: true,
          flatten: true,
          src: 'scss/*.scss',
          dest: 'css/'
        }
      },
</code></pre><p>The last css task is the most complicated one.
            <a href="https://github.com/addyosmani/grunt-uncss" label="Uncss">Uncss</a> takes out whatever CSS rules are not used in our target HTML files. 
         </p><pre><code class="javascript hljs">
      // CSS TASKS TO RUN AFTER CONVERSION
      // Cleans the CSS based on what's used in the specified filesor more tasks defined above
    grunt.task.rerunt-uncss for more
      // information
      uncss: {
        dist: {
          files: {
            'css/tidy.css': ['*.html', '!docs.html']
          }
        }
      },
</code></pre><p>This is not a big deal for our workflow as most, if not all, the CSS is designed for
            the tags and classes we've implemented but it's impossible for the SASS/CSS libraries
            to grow over time and become bloated.
         </p>
         <p>This will also become and issue when you decide to include third part libraries in
            projects implemented on top of our workflow. By running Uncss on all our HTML files
            except the file we'll pass to our PDF generator (docs.html) we can be assured that
            we'll get the smallest css possible.
         </p>
         <p>We skip out PDF source html file because I'm not 100% certain that Uncss can work
            with Paged Media CSS extensions. Better safe than sorry. 
         </p>
         <h2>Optional tasks</h2>
         <p>I've also created a set of optional tasks that are commented in the Grunt file but
            have been uncommented here for readability. 
         </p>
         <p>The first optional task is a Coffeescript compiler.
            <a href="http://coffeescript.org/" label="Coffeescript">Coffeescript</a> is a scripting language that provides a set of useful features and that compiles
            directly to Javascript. 
         </p>
         <p>I some times use Coffeescript to create scripts and other interactive content so it's
            important to have the compilation option available.
         </p><pre><code class="javascript hljs">
      // OPTIONAL TASKS
      // Tasks below have been set up but are currently not used.
      // If you want them, uncomment the corresponding block below

      // COFFEESCRIPT
      // If you want to use coffeescript (http://coffeescript.org/)
      // instead of vanilla JS, uncoment the block below and change
      // the cwd value to the locations of your coffee files
      coffee: {
        target1: {
          expand: true,
          flatten: true,
          cwd: 'src/',
          src: ['*.coffee'],
          dest: 'build/',
          ext: '.js'
      },
</code></pre><p>The following two tasks are for managing file transfers and uploads to different targets.</p>
         <p>One of the things I love from working on Github is that your project automatically
            gets an ssl-enabled site for free.
            <a href="https://pages.github.com/" label="Github Pages">Github Pages</a> work with any kind of static website; Github even offers an automatic site generator
            as part of our your project site.
         </p>
         <p>For the puposes of our workflow validation we'll make a package of our content in
            a build directory and push it to the gh-pages branch of our repository. We'll look
            at building our app directory when we look at copying files.
         </p><pre><code class="javascript hljs">
      // GH-PAGES TASK
      // Push the specified content into the repository's gh-pages branch
      'gh-pages': {
        options: {
          message: 'Content committed from Grunt gh-pages',
          base: './build/app',
          dotfiles: true
        },
        // These files will get pushed to the `
        // gh-pages` branch (the default)
        // We have to specifically remove node_modules
        src: ['**/*']
      },
</code></pre><p>There are times when we are not working with Github or pages. In this case we need
            to FTP or SFTP (encrypted version of FTP) to push files to remote servers. We use
            an external json file to store our account information. Ideally we'd encrypt the information
            but until then using the external file is the first option.
         </p><pre><code class="javascript hljs">
      //SFTP TASK
      //Using grunt-ssh (https://www.npmjs.com/package/grunt-ssh)
      //to store files in a remote SFTP server. Alternative to gh-pages
      secret: grunt.file.readJSON('secret.json'),
      sftp: {
        test: {
          files: {
            "./": "*.json"
          },
          options: {
            path: '/tmp/',
            host: '&lt;%= secret.host %&gt;',
            username: '&lt;%= secret.username %&gt;',
            password: '&lt;%= secret.password %&gt;',
            showProgress: true
          }
        }
      },
</code></pre><h2>File Management</h2>
         <p>We've taken a few file management tasks into Grunt to make our lifes easier. The functions
            are for:
         </p>
         <ul>
            <li>Creating directories</li>
            <li>Copying files</li>
            <li>Deleting files and directories</li>
         </ul>
         <p>We will use the mkdir and copy tasks to create a build directory and copy all css,
            js and html files to the build directory. We will then use the gh-pages task (described
            earlier) to push the content to the repository's gh-pages branches
         </p><pre><code class="javascript hljs">
      // FILE MANAGEMENT
      // Can't seem to make the copy task create the directory
      // if it doesn't exist so we go to another task to create
      // the fn directory
      mkdir: {
        build: {
          options: {
            create: ['build']
          }
        }
      },

      // Copy the files from our repository into the build directory
      copy: {
        build: {
          files: [{
            expand: true,
            src: ['app/**/*'],
            dest: 'build/'
          }]
        }
      },

      // Clean the build directory
      clean: {
        production: ['build/']
      },
</code></pre><h2>Watch task</h2>
         <p>Rather than type a command over and over again we can set up watchers so that, any
            time a file of the indicated type changes, we perform specific tasks.
         </p>
         <p>AS currentlly configured we track Javascript and SASS files.</p>
         <p>For Javascript files anytime that the Gruntfile or any file under the Javascript directorie
            we run the JSHint task to make sure we haven't made any mistakes. 
         </p>
         <p>For our SASS/SCSS files, any files under the scss directory, we run the sass:dev task
            to translate the files to CSS. 
         </p><pre><code class="javascript hljs">
      // WATCH TASK
      // Watch for changes on the js and scss files and perform
      // the specified task
      watch: {
        options: {
          nospawn: true
        },
        // Watch all javascript files and hint them
        js: {
          files: ['Gruntfile.js', 'js/{,*/}*.js'],
          tasks: ['jshint']
        },
        sass: {
          files: ['scss/*.scss'],
          tasks: ['sass:dev']
        }
      },
</code></pre><h2>Compile and Execute</h2>
         <p>Rather than using Ant, I've settled on Grunt's shell task to run the compilation steps
            to create HTML and PDF. This reduces teh number of dependecies for our project and
            makes it easier to consolidate all the work.
         </p>
         <p>We have three different commands:</p>
         <ul>
            <li>html will create multiple html files using Saxon, a Java XSLT processor</li>
            <li>single will create a single html file using Saxon</li>
            <li>prince will create a PDF based on the single html file using PrinceXML</li>
         </ul>
         <p>We make sure that we don't continue if there is an error. Want to make sure that we
            troubleshoot before we get all the resulting files.
         </p><pre><code class="javascript hljs">
      // COMPILE AND EXECUTE TASKS
      shell: {
        options: {
          failOnError: true,
          stderr: false
        },
        html: {
          command: 'java -jar /usr/local/java/saxon.jar -xsl:xslt/book.xsl docs.xml -o:index.html'
        },
        single: {
          command: 'java -jar /usr/local/java/saxon.jar -xsl:xslt/pm-book.xsl docs.xml -o:docs.html'
        },
        prince: {
          command: 'prince --verbose --javascript docs.html -o docs.pdf'
        }
      }


    }); // closes initConfig
</code></pre><h2>Custom Tasks</h2>
         <p>The custom task uses one or more of the tasks defined above to accomplish a sequence
            of tasks.
         </p>
         <p>Look at specific tasks defined above for specific definitions.</p><pre><code class="javascript hljs">
    // CUSTOM TASKS
    // Usually a combination of one or more tasks defined above
    grunt.task.registerTask(
      'lint',
      [
        'jshint'
      ]
    )

    grunt.task.registerTask(
      'lint-all',
      [
        'scsslint',
        'jshint'
      ]
    );

    // Prep CSS starting with SASS, autoprefix et. al
    grunt.task.registerTask(
      'prep-css',
      [
        'scsslint',
        'sass:dev',
        'autoprefixer'
      ]
    );

    grunt.task.registerTask(
      'prep-js',
      [
        'jshint',
        'uglify'
      ]
    );

    grunt.task.registerTask(
      'generate-pdf',
      [
        'shell:single',
        'shell:prince'
      ]
    );

    grunt.task.registerTask(
      'generate-pdf-scss',
      [
        'scsslint',
        'sass:dev',
        'shell:single',
        'shell:prince'
      ]
    );

    grunt.task.registerTask(
      'generate-all',
      [
        'shell'
      ]
    );


  }; // closes module.exports
}()); // closes the use strict function
</code></pre></section>
      <section xmlns:epub="http://www.idpf.org/2007/ops" data-type="appendix" epub:type="appendix">
         <p class="rh">Ideas and outstanding items</p>
         <h1 id="d2e2250">Ideas and outstanding items</h1>
         <p>These are the things I want to look at after finishing mvp.</p>
         <h2>Deep Linking using Emphasis</h2>
         <p>The NYT developed a deep linking library called Emphasis (
            <a href="https://github.com/NYTimes/Emphasis" label="code">code</a> -
            <a href="http://open.blogs.nytimes.com/2011/01/11/emphasis-update-and-source/" label="writeup">writeup</a>) that would allow us to create links to specific areas of our content.
         </p>
         <p>Downside is that it uses jQuery and I'm not certain I want to go through the pain
            in the ass process of converting it to plain JS or ES6 (and if it's even possible)
         </p>
         <p>Still, if we use jQuery for something else (video manipulation?) it may be worth exploring
            both as a sharing tool and as a technology.
         </p>
         <p>One thing it doesn't do is handle mobile well, if at all. How do we make this tool
            work everywhere?
            <a href="http://www.w3.org/TR/pointerevents/" label="Pointer Events">Pointer Events</a>?
         </p>
         <h2>Explore how to add other parts of a book structure</h2>
         <p>Right now we're working with chapters and chapter-like structures. What would it take
            to add parts? Do we need to add them to the schema and let them trickle from there?
            Do we really need them?
         </p>
         <h2>Build Media Queries</h2>
         <p>Particularly if we want to use the same XSLT and CSS for mutliple projects we need
            to be able to tailor the display for different devices and viewports.
         </p>
         <p>Media Queries are the best solution (or are they?)</p>
         <h2>Using XSLT to build navigation</h2>
         <p>The same way we build the table of content should allow us to build navigation within
            the pages of a publication using preceeding-sibling and following-sibling logic
         </p>
         <h2>Create a better way to generate filenames</h2>
         <p>The current way to create filenames doesn't take into account that different
            <em>section/@type</em> elements have different starting values. Can I make it start from 1 for every @type
            in the document?
         </p>
         <h2>Expand the use cases for this project</h2>
         <p>The original idea was for text and code-heavy content. Is there a case to be made
            for a more expressive vocabulary? I'm thinking of additional elements for navigation
            and content display such as asides and blockquotes
         </p>
         <h2>Explore implementing a serviceworker solution</h2>
         <video height="315" width="560" poster="./images/video1-poster.jpg" controls="controls">
            <source src="./video/serviceworker.mp4" type="video/mp4"></source>
         </video>
         <p>The core of the proposed offline capabilities is a scoped service worker that will
            initially handle the caching of the publication's content. We take advantage of the
            multiple cache capabilitity available with service workers to create caches for individual
            unitts of content (like magazine issues) and to expire them within a certain time
            period (by removing and deleting the cache).
         </p>
         <p>For publications needing to pull data from specific URLs we can special case the requests
            based on different pieces of the URL allowing to create different caches based on
            edition (assuming each edition is stored in its own directory), resource type or even
            the URL we are requesting.
         </p>
         <p>Serviceworkers have another benefit not directly related with offline connections.
            They will give all access to our content a speed boost by eliminating the network
            roundtrip after the content is installed. If the content is in the cache, the resource's
            time to load is only limited by the Hard Drive's speed.
         </p>
         <p>This is what the ServiceWorker code looks like in the demo application:</p><pre><code class="javascript hljs">
// ATHENA DEMO SERVICE WORKER
//
// @author Carlos Araya
// @email carlos.araya@gmail.com
//
// Based on Paul Lewis' Chrome Dev Summit serviceworker.

importScripts('js/serviceworker-cache-polyfill.js');

var CACHE_NAME = 'athena-demo';
var CACHE_VERSION = 8;

self.oninstall = function(event) {

  event.waitUntil(
    caches.open(CACHE_NAME + '-v' + CACHE_VERSION).then(function(cache) {

      return cache.addAll([
        '/athena-framework/',
        '/athena-framework/bower_components/',
        '/athena-framework/css/',
        '/athena-framework/js/',
        '/athena-framework/layouts/',

        '/athena-framework/content/',
        '/athena-framework/index.html',
        '/athena-framework/notes.html',

        'http://chimera.labs.oreilly.com/books/1230000000345/ch12.html',
        'http//chimera.labs.oreilly.com/books/1230000000345/apa.html'
      ]);
    })
  );
};

self.onactivate = function(event) {

  var currentCacheName = CACHE_NAME + '-v' + CACHE_VERSION;
  caches.keys().then(function(cacheNames) {
    return Promise.all(
      cacheNames.map(function(cacheName) {
        if (cacheName.indexOf(CACHE_NAME) == -1) {
          return;
        }

        if (cacheName != currentCacheName) {
          return caches.delete(cacheName);
        }
      })
    );
  });

};

self.onfetch = function(event) {
  var request = event.request;
  var requestURL = new URL(event.request.url);

  event.respondWith(

    // Check the cache for a hit.
    caches.match(request).then(function(response) {

      // If we have a response return it.
      if (response)
        return response;

      // Otherwise fetch it, store and respond.
      return fetch(request).then(function(response) {

        var responseToCache = response.clone();

        caches.open(CACHE_NAME + '-v' + CACHE_VERSION).then(
          function(cache) {
            cache.put(request, responseToCache).catch(function(err) {
              // Likely we got an opaque response which the polyfill
              // can't deal with, so log out a warning.
              console.warn(requestURL + ': ' + err.message);
            });
          });
=
        return response;
      });

    })
  );
};
    </code></pre><h3>Limitations</h3>
         <p>As powerful as service workers are they also have some drawbacks. They can only be
            served through HTTPS (you cannot install a service worker in a non secure server)
            to prevent
            <a href="http://www.wikiwand.com/en/Man-in-the-middle_attack" label="man-in-the-middle attacks">man-in-the-middle attacks</a>.
         </p>
         <p>There is limited support for the API (only Chrome Canary and Firefox Nightly builds
            behind a flag will work.) This will change as the API matures and becomes finalized
            in the WHATWG and/or a recommendation with the W3C. 
         </p>
         <p>Even in browsers that support the API the support is not complete. Chrome uses a polyfill
            for elements of the cache API that it does not support natively. This should be fixed
            in upcoming versions of Chrome and Chromium (the open source project Chrome is based
            on.)
         </p>
         <p>We need to be careful with how much data we choose to store in the caches. From what
            I understand the ammount of storage given to offline applications is divided between
            all offline storage types: IndexedDB, Session Storage, Web Workers and ServiceWorkers
            and this amount is not consistent across all browsers.
         </p>
         <p>Furthermore I am not aware of any way to increase this total amount or to specifically
            increase the storage assigned to ServiceWorkers; Jake Archibald mentions this in the
            offline cookbook section on
            <a href="http://jakearchibald.com/2014/offline-cookbook/#cache-persistence" label="cache persistence">cache persistence</a>.
         </p>
      </section>
   </body>
</html>
