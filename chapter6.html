<html>
   <head>
      <link rel="stylesheet" href="css/style.css"></link>
      <link rel="stylesheet" href="css/normalize.css"></link>
      <link rel="stylesheet" href="css/styles/railscasts.css"></link>
      <script src="lib/highlight.pack.js"></script>
      <script>
         hljs.initHighlightingOnLoad();

      </script>
   </head>
   <body>
      <section data-type="chapter">
         <h1>From XML to PDF: Part 1: Special Transformation</h1>
         <p> Rather than having to deal with

            <a href="http://www.w3.org/TR/2006/REC-xsl11-20061205/" label="XSL-FO">XSL-FO</a>, another XML based vocabulary to create PDF content, we'll use XSLT to create another
            HTML file and process it with

            <a href="http://dev.w3.org/csswg/css-page-3/" label="CSS Paged Media">CSS Paged Media</a> and the companion

            <a href="http://www.w3.org/TR/css-gcpm-3/" label="Generated Content for Paged Media">Generated Content for Paged Media</a> specifications to create PDF content.

         </p>
         <p>I'm not against XSL-FO but the structure of document is not the easiest or most intuitive.
            An example of XSL-FO looks like this:
         </p>
         <pre>
            <code language="xml"> &lt;?xml version="1.0" encoding="iso-8859-1"?&gt; (1)
               &lt;fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt; (2)
               &lt;fo:layout-master-set&gt; (3)
               &lt;fo:simple-page-master master-name="my-page"&gt;
               &lt;fo:region-body margin="1in"/&gt;
               &lt;/fo:simple-page-master&gt; &lt;/fo:layout-master-set&gt;
               &lt;fo:page-sequence master-reference="my-page"&gt; (4)
               &lt;fo:flow flow-name="xsl-region-body"&gt; (5)
               &lt;fo:block&gt;Hello, world!&lt;/fo:block&gt; (6)
               &lt;/fo:flow&gt;
               &lt;/fo:page-sequence&gt;
               &lt;/fo:root&gt;
            </code>
         </pre>
         <ol>
            <li>This is an XML declaration. XSL FO (XSLFO) belongs to XML family, so this is obligatory</li>
            <li>Root element. The obligatory namespace attribute declares the XSL Formatting Objects
               namespace
            </li>
            <li>Layout master set. This element contains one or more declarations of page masters
               and page sequence masters â€” elements that define layouts of single pages and page
               sequences. In the example, I have defined a rudimentary page master, with only one
               area in it. The area should have a 1 inch margin from all sides of the page
            </li>
            <li>Page sequence. Pages in the document are grouped into sequences; each sequence starts
               from a new page. Master-reference attribute selects an appropriate layout scheme from
               masters listed inside `&lt;fo:layout-master-set&gt;`. Setting master-reference to a page
               master name means that all pages in this sequence will be formatted using this page
               master
            </li>
            <li>Flow. This is the container object for all user text in the document. Everything contained
               in the flow will be formatted into regions on pages generated inside the page sequence.
               Flow name links the flow to a specific region on the page (defined in the page master);
               in our example, it is the body region
            </li>
            <li>Block. This object roughly corresponds to `&lt;div&gt;` in HTML, and normally includes a
               paragraph of text. I need it here, because text cannot be placed directly into a flow
            </li>
         </ol>
         <p>Rather than define a flow of content and then the content CSS Paged Media uses a combination
            of new and existing CSS elements to format the content. For example, to define default
            page size and then add elements to chapter pages looks like this:
         </p>
         <pre>
            <code language="css"> @page {
               size: 8.5in 11in; margin: 0.5in 1in;
               /* Footnote related attributes */
               counter-reset: footnote;
               @footnote {
               counter-increment: footnote;
               float: bottom;
               column-span: all;
               height: auto;
               }
               }

               @page chapter {
               @bottom-center {
               vertical-align: middle;
               text-align: center;
               content: element(heading);
               }
               }
            </code>
         </pre>
         <p>The only problem with the code above is that there is no native broser support. For
            our demonstration we'll use Prince XML to tanslate our HTML/CSS file to PDF. In the
            not so distant future we will be able to do this transformation in the browser and
            print the PDF directly. Until then it's a two step process: Modifying the HTML we
            get from the XML file and running the HTML through Prince to get the PDF.
         </p>
         <h2>Modifying the HTML results</h2>
         <p>We'll use this opportunity to create an xslt customization layer to make changes only
            to the templates where we need to.
         </p>
         <p>We create a customization layer by importing the original stylesheet and making any
            necessary changes in the new stylesheet. Imported stylesheets have a lower precedence
            order than the local version so the local version will win if there is conflict.
         </p>
         <p>Only the templates defined in this stilesheet are overriden. If the template we use
            is not in this customization layer, the transformation engine will use the template
            in the base style sheet (book.xsl in this case)

         </p>
         <p>The style sheet is broken by templates and explained below.</p>
         <pre>
            <code language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
               &lt;xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
               exclude-result-prefixes="xs" version="2.0"&gt;
               &lt;!--
               XSLT Paged Media Customization Layer Makes the necessary
               changes to the content to work with the Paged Media CSS
               stylesheet
               --&gt;
               &lt;!-- First import the base stylesheet --&gt;
               &lt;xsl:import href="book.xsl"/&gt;

               &lt;!-- Define the output for this and all document children --&gt;
               &lt;xsl:output name="xhtml-out" method="xhtml" indent="yes"
               encoding="UTF-8" omit-xml-declaration="yes" /&gt;
            </code>
         </pre>
         <p>The first difference in the customization layer is that it imports another style sheet
            (

            <em>book.xsl</em>). We do this to avoid having to copy the entire style sheet and, if we make changes,
            having to make the changes in multiple places.
         </p>
         <p>We will then override the templates we need in order to get a single file to pass
            on to Prince or any other CSS Print Processor.
         </p>
         <pre>
            <code language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
               &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"
               exclude-result-prefixes="xs"
               version="2.0"&gt;

               &lt;!-- First import the base stylesheet --&gt;
               &lt;xsl:import href="book.xsl"/&gt;

               &lt;!-- Define the output for this and all document children --&gt;
               &lt;xsl:output name="xhtml-out" method="xhtml" indent="yes"
               encoding="UTF-8" omit-xml-declaration="yes" /&gt;

               &lt;!-- Root template matching book --&gt;
               &lt;xsl:template match="book"&gt;
               &lt;html&gt;
               &lt;head&gt;
               &lt;xsl:element name="title"&gt;
               &lt;xsl:value-of select="metadata/title"/&gt;
               &lt;/xsl:element&gt;
               &lt;!-- Paged Media Styles --&gt;
               &lt;link rel="stylesheet" href="css/pm-style.css" /&gt;
               &lt;!-- Load Paged Media definitions just so I won't forget it again --&gt;
               &lt;link rel="stylesheet" href="css/paged-media.css"/&gt;
               &lt;!-- Use highlight.js and style --&gt;
               &lt;xsl:if test="(code)"&gt;
               &lt;link rel="stylesheet" href="css/styles/railscasts.css" /&gt;
               &lt;!-- Load highlight.js --&gt;
               &lt;script src="lib/highlight.pack.js"&gt;&lt;/script&gt;
               &lt;script&gt;
               hljs.initHighlightingOnLoad();
               &lt;/script&gt;
               &lt;/xsl:if&gt;
               &lt;!-- &lt;script src="js/script.js"&gt;&lt;/script&gt; --&gt;
               &lt;/head&gt;
               &lt;body&gt;
               &lt;xsl:attribute name="data-type"&gt;book&lt;/xsl:attribute&gt;
               &lt;xsl:element name="meta"&gt;
               &lt;xsl:attribute name="generator"&gt;
               &lt;xsl:value-of select="system-property('xsl:product-name')"/&gt;
               &lt;xsl:value-of select="system-property('xsl:product-version')"/&gt;
               &lt;/xsl:attribute&gt;
               &lt;/xsl:element&gt;

               &lt;xsl:apply-templates select="/" mode="toc"/&gt;
               &lt;xsl:apply-templates/&gt;
               &lt;/body&gt;
               &lt;/html&gt;
               &lt;/xsl:template&gt;
            </code>
         </pre>
         <p>Most of the root template deals with undoing some of the changes we made to create
            multiple pages.
         </p>
         <p>We've changed the CSS we use to process the content. We use paged-media.css to create
            the content for our media files, mostly setting up the different pages based on the
            data-type attribute.
         </p>
         <p>We use pm-styles.css to control the style of our documents specifically for our printed
            page application. We have to take into account the fact that Highlight.js is not working
            properly with Prince's Javascript implementation and that there are places where we
            don't want our paragraphs to be indented at all.
         </p>
         <p>We moved elements from the original section templates. We test whether we need to
            add the Highlight.JS since we dropped the multipage output.

         </p>
         <h2>Overriding the section template</h2>
         <p>Sections are the element type that got the biggest makeover. What we've done:</p>
         <ul>
            <li>Remove filename variable. It's not needed</li>
            <li>Remove the result document element since we are building a single file with all our
               content
            </li>
            <li>Change way we check for the type attribute in sections. It will now terminate with
               an error if the attribute is not found
            </li>
            <li>Add the element that will build our running footer (p class="rh") and assign the value
               of the secion's title to it
            </li>
         </ul>
         <pre>
            <code language="xml"> &lt;!-- Override of the section template.--&gt;
               &lt;xsl:template match="section"&gt;
               &lt;section&gt;
               &lt;xsl:choose&gt;
               &lt;xsl:when test="string(@type)"&gt;
               &lt;xsl:attribute name="data-type"&gt;
               &lt;xsl:value-of select="@type"/&gt;
               &lt;/xsl:attribute&gt;
               &lt;/xsl:when&gt;
               &lt;xsl:otherwise&gt;
               &lt;xsl:message terminate="yes"&gt;Type attribute is required for paged media. Check your
               section tags for missing type attributes &lt;/xsl:message&gt;
               &lt;/xsl:otherwise&gt;
               &lt;/xsl:choose&gt;
               &lt;xsl:if test="string(@class)"&gt;
               &lt;xsl:attribute name="class"&gt;
               &lt;xsl:value-of select="@class"/&gt;
               &lt;/xsl:attribute&gt;
               &lt;/xsl:if&gt;
               &lt;xsl:if test="string(@id)"&gt;
               &lt;xsl:attribute name="id"&gt;
               &lt;xsl:value-of select="@id"/&gt;
               &lt;/xsl:attribute&gt;
               &lt;/xsl:if&gt;

               &lt;!--
               Running header paragraph. This will be take out of the regular flow
               of text so it doesn't matter if we add it or not
               --&gt;
               &lt;xsl:element name="p"&gt;
               &lt;xsl:attribute name="class"&gt;rh&lt;/xsl:attribute&gt;
               &lt;xsl:value-of select="title"/&gt;
               &lt;/xsl:element&gt; &lt;!-- closses rh class --&gt;
               &lt;xsl:apply-templates/&gt;
               &lt;/section&gt;
               &lt;/xsl:template&gt;
            </code>
         </pre>
         <h2>Metadata</h2>
         <p>The Metadata section has been reworked into a new section with the title data-type.
            We then apply all children templates.
         </p>
         <pre>
            <code language="xml"> &lt;!-- Metadata --&gt;
               &lt;xsl:template match="metadata"&gt;
               &lt;xsl:element name="section"&gt;
               &lt;xsl:attribute name="data-type"&gt;titlepage&lt;/xsl:attribute&gt;
               &lt;xsl:apply-templates/&gt;
               &lt;/xsl:element&gt;
               &lt;/xsl:template&gt;
            </code>
         </pre>
         <h2>Titles and tables of content</h2>
         <p>The table of content is commented for now as I work on improving the content and placement
            of the table contents in the final document.
         </p>
         <p>The title element has only one addition. We add an ID attribute created using XPath's
            generate-id function on the parent section element.

         </p>
         <pre>
            <code language="xml"> &lt;!-- Create Table of Contents Work in progress--&gt;
               &lt;xsl:template match="/" mode="toc"/&gt;
               &lt;xsl:template match="title"&gt;
               &lt;xsl:element name="h1"&gt;
               &lt;xsl:attribute name="id"&gt;
               &lt;xsl:value-of select="generate-id(..)"/&gt;
               &lt;/xsl:attribute&gt;
               &lt;xsl:if test="string(@align)"&gt;
               &lt;xsl:attribute name="align"&gt;
               &lt;xsl:value-of select="@align"/&gt;
               &lt;/xsl:attribute&gt; &lt;/xsl:if&gt;
               &lt;xsl:if test="string(@class)"&gt;
               &lt;xsl:attribute name="class"&gt;
               &lt;xsl:value-of select="@class"/&gt;
               &lt;/xsl:attribute&gt;
               &lt;/xsl:if&gt;
               &lt;xsl:value-of select="."/&gt;
               &lt;/xsl:element&gt;
               &lt;!-- closes h1 --&gt;
               &lt;/xsl:template&gt;
               &lt;/xsl:stylesheet&gt;
            </code>
         </pre>
         <p>With all this in place we can now look to the CSS Paged Media file.

         </p>
      </section>
   </body>
</html>
