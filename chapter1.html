<html xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:epub="http://www.idpf.org/2007/opf">
   <head>
      <link rel="stylesheet" href="css/style.css"></link>
      <link rel="stylesheet" href="css/styles/railscasts.css"></link>
      <script src="js/highlight.pack.js"></script>
      <script>
         hljs.initHighlightingOnLoad();

      </script>
   </head>
   <body>
      <section data-type="chapter">
         <h1>Converting our content to HTML</h1>
         <p>One of the biggest advantages of working with XML is that we can convert the abstract
            tags into other markups. For the purposes of this project we'll convert the XML created
            to match the schema we just created to HTML and then use tools like
            <a href="http://www.princexml.com" label="PrinceXML">PrinceXML</a> or
            <a href="http://www.antennahouse.com" label="AntenaHouse">AntenaHouse</a> we'll convert the HTML/CSS files to PDF
         </p>
         <h2>Why HTML</h2>
         <p>HTML is the default format for the web and for most web/html based content such as
            ePub and Kindle. As such it makes a perfect candidate to explore how to generate it
            programatically from a single source file.
         </p>
         <p>HTML will also act as our source for using CSS paged media to create PDF cotnent.</p>
         <h2>Why PDF</h2>
         <p>Rather than having to deal with
            <a href="http://www.w3.org/TR/2006/REC-xsl11-20061205/" label="XSL-FO">XSL-FO</a>, another XML based vocabulary to create PDF content, we'll use XSLT to create another
            HTML file and process it with
            <a href="http://dev.w3.org/csswg/css-page-3/" label="CSS Paged Media">CSS Paged Media</a> and the companion
            <a href="http://www.w3.org/TR/css-gcpm-3/" label="Generated Content for Paged Media">Generated Content for Paged Media</a> specifications to create PDF content.
         </p>
         <p>In this document we'll concentrate on the XSLT to HTML conversion and will defer the
            conversion from HTML to PDF to a later article.
         </p>
         <h1>Creating our conversion stylesheets</h1>
         <p>To convert our XML into other formats we will use XSL Transformations (also known
            as XSLT)
            <a href="http://www.w3.org/TR/xslt" label="version 2">version 2</a> (a W3C standard) and
            <a href="http://www.w3.org/TR/xslt-30/" label="version 3">version 3</a> (a W3C last call draft recommendation) where appropriate.
         </p>
         <p>XSLT is a functional language designed to transform XML into other markup vocabularies.
            It defines template rules that match elements in your source document and processing
            them to convert them to the target vocabulary.
         </p>
         <p>In the XSLT example below, we do the following:</p>
         <ol>
            <li>match the root element to create the skeleton for our HTML content</li>
            <li>In the title we insert the content of the `metadata/title` element</li>
            <li>In the body we 'apply' the templates that match the content inside our document (more
               on this later)
            </li>
         </ol>
         <pre>
            <code class="xml">
               &lt;?xml version="1.0" ?&gt;

               &lt;xsl:stylesheet
               xmlns="http://www.w3.org/1999/xhtml"
               xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
               xmlns:dc="http://purl.org/dc/elements/1.1/"
               xml:lang="en-US"
               version="2.0"&gt;

               &lt;xsl:template match="/"&gt;
               &lt;html&gt;
               &lt;head&gt;
               &lt;title&gt;&lt;xsl:value-of select="metadata/title"/&gt;&lt;/title&gt;
               &lt;link rel="stylesheet" href="css/style.css"/&gt;
               &lt;script src="js/script.js"&gt;&lt;/script&gt;
               &lt;/head&gt;
               &lt;body&gt;
               &lt;xsl:apply-templates/&gt;
               &lt;/body&gt;
               &lt;/html&gt;
               &lt;/xsl:template&gt;
               &lt;/xsl:stylesheet&gt;

            </code>
         </pre>
         <p>We could build the CSS stylesheet as part of our root element but I choose not to
            do so. Working with the stylesheet as part of the XSLT stylesheet allows the XSLT
            stylesheet designer to embed the style and parameterize the stylesheet, thus making
            the stylesheet customizable from the command line.
         </p>
         <p>For all advantages, this method ties the styles for the project to the XSLT stylesheet
            and requires the XSLT stylesheet designer to be involved in all CSS updates.
         </p>
         <p>By linking to external CSS and Javascript files we can leverage expertise independent
            of the Schema and XSLT stylesheets. Book designers can work on the CSS, UX and experience
            designers can work on Javascript and additional CSS areas, book designers can work
            on the Paged Media stylesheets and authors can just write.
         </p>
         <p>Furthermore we can reuse our CSS and Javascript on multiple documents.</p>
         <h2>Working on content with XSLT</h2>
         <p>Once we have defined the structure of the document structure we can start building
            the rendering of our content.
         </p>
         <p>The first thing we'll do is to define the output for our master document and all the
            files that will be generated from our style sheet.
         </p>
         <pre>
            <code class="xml">

               &lt;xsl:output name="xhtml-out" method="xhtml" indent="yes"
               encoding="UTF-8" omit-xml-declaration="yes" /&gt;

            </code>
         </pre>
         <p>We will being with the major areas of the document, `metadata` and `section`. The
            metadata is a container for all the elements inside. As such we just create the div
            that will hold the content and call `xsl:apply-templates` to process the content inside
            the metadata element.
         </p>
         <pre>
            <code class="xml">
               &lt;xsl:template match="metadata" mode="content"&gt;
               &lt;div class="metadata"&gt;
               &lt;xsl:apply-templates/&gt;
               &lt;/div&gt;
               &lt;/xsl:template&gt;

            </code>
         </pre>
         <p>The
            <emphasis>section</emphasis> element is hardest to wrap your head around
         </p>
         <pre>
            <code class="xml">
               &lt;xsl:template match="section" mode="content"&gt;

               &lt;xsl:variable name="fileName"
               select="concat(section/@type, count(section),'.xhtml')"/&gt;
               &lt;!-- An example result of the variable above would be introduction1.xhtml --&gt;
               &lt;xsl:apply-templates/&gt;
               &lt;xsl:if test="(@class)"&gt;
               &lt;xsl:attribute name="class"&gt;
               &lt;xsl:value-of select="@class"/&gt;
               &lt;/xsl:attribute&gt;
               &lt;/xsl:if&gt;
               &lt;xsl:if test="(@id)"&gt;
               &lt;xsl:attribute name="id"&gt;
               &lt;xsl:value-of select="@id"/&gt;
               &lt;/xsl:attribute&gt;
               &lt;/xsl:if&gt;
               &lt;xsl:result-document href='${fileName}' format="xhtml-out"&gt;
               &lt;section&gt;
               &lt;xsl:apply-templates/&gt;
               &lt;/section&gt;
               &lt;/xsl:result-document&gt;
               &lt;/xsl:template&gt;

            </code>
         </pre>
      </section>
   </body>
</html>
