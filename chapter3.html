<html>
   <head>
      <script src="//use.typekit.net/qcp8nid.js"></script>
      <script>try{Typekit.load();}catch(e){}</script>
      <link rel="stylesheet" href="css/style.css"></link>
      <link rel="stylesheet" href="css/styles/docco.css"></link>
      <script src="lib/highlight.pack.js"></script>
      <script>
         hljs.initHighlightingOnLoad();

      </script>
   </head>
   <body>
      <section data-type="chapter">
         <h1>XML Schema</h1>
         <p>The schema is defined from most general to most specific elements. We'll follow the
            same process to explain what the schema does and how we arrived to the choices we
            made.
         </p>
         <p>At the beginning of the schema we define some custom types that will be used throughout
            the document.
         </p>
         <p>The first one,
            <em>string255</em> is a string that is limited to 255 characters in length. We do this to prevent overtly
            long strings.
         </p>
         <p>The second one,
            <em>isbn</em> is a regular expression to match 10 digits ISBN numbers. We'll have to modify it
            to handle ISBN-13 as well as 10.
         </p>
         <p>The third custom type is an enumeration of all possible values for the
            <em>align</em> attribute acording to CSS and HTML. Rather than manually type each of these we will
            reference this enumeration and include all its values for "free".
         </p>
         <p>We also allow the optional use of `class` and `id` attributes for the book by assigning
            `genericPropertiesGroup` attribute group as attributes to the group. We'll see this
            assigned to other elements so I decided to make it reusable rather than have to duplicate
            the attributes in every element I want to use them in.
         </p>
         <pre>
            <code class="xml">
               &lt;!-- Simple types to use in the content --&gt;
               &lt;xs:simpleType name="token255"&gt;
               &lt;xs:restriction base="xs:token"&gt;
               &lt;xs:maxLength value="255"/&gt;
               &lt;/xs:restriction&gt;
               &lt;/xs:simpleType&gt;

               &lt;xs:simpleType name="isbn"&gt;
               &lt;xs:restriction base="xs:unsignedLong"&gt;
               &lt;xs:totalDigits value="10"/&gt;
               &lt;xs:pattern value="d{10}"/&gt;
               &lt;/xs:restriction&gt;
               &lt;/xs:simpleType&gt;

               &lt;xs:simpleType name="align"&gt;
               &lt;xs:restriction base="xs:token"&gt;
               &lt;xs:enumeration value="left"/&gt;
               &lt;xs:enumeration value="center"/&gt;
               &lt;xs:enumeration value="right"/&gt;
               &lt;xs:enumeration value="justify"/&gt;
               &lt;/xs:restriction&gt;
               &lt;/xs:simpleType&gt;

               &lt;xs:attributeGroup name="genericPropertiesGroup"&gt;
               &lt;xs:attribute name="id" type="xs:ID" use="optional"/&gt;
               &lt;xs:attribute name="class" type="xs:token" use="optional"/&gt;
               &lt;/xs:attributeGroup&gt;

            </code>
         </pre>
         <p>The next stage is to define elements to create our
            <em>people</em> types.  We create a base person element and then create three role elements based
            on person. We will use this next to define groups for each role.
         </p>
         <pre>
            <code class="xml">
               &lt;!-- complex types to create groups of similar person items --&gt;
               &lt;xs:complexType name="person"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="first-name" type="xs:token"/&gt;
               &lt;xs:element name="surname" type="xs:token"/&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:attribute name="id" type="xs:ID" use="optional"/&gt;
               &lt;/xs:complexType&gt;

               &lt;xs:complexType name="author"&gt;
               &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
               &lt;xs:element name="author" type="person"/&gt;
               &lt;/xs:choice&gt;
               &lt;/xs:complexType&gt;

               &lt;xs:complexType name="editor"&gt;
               &lt;xs:complexContent&gt;
               &lt;xs:extension base="person"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="type" type="xs:string"/&gt;
               &lt;/xs:sequence&gt;
               &lt;/xs:extension&gt;
               &lt;/xs:complexContent&gt;
               &lt;/xs:complexType&gt;

               &lt;xs:complexType name="otherRole"&gt;
               &lt;xs:complexContent&gt;
               &lt;xs:extension base="person"&gt;
               &lt;xs:sequence minOccurs="1" maxOccurs="1"&gt;
               &lt;xs:element name="role" type="xs:string"/&gt;
               &lt;/xs:sequence&gt;
               &lt;/xs:extension&gt;
               &lt;/xs:complexContent&gt;
               &lt;/xs:complexType&gt;

            </code>
         </pre>

         Two of the derived types add attributes or elements to the base person element to
         make the generic person more appropriate to their role rather than repeat the content
         of person each time that an author, editor or other role appear.

         Author is the most straight forward and only wraps person in the author element.


         Editor takes the base person element and adds a `type` child to indicate the type
         of editor (some that come to mind are acquisition, production and managing.) The editor
         elements looks like this:


         <pre>
            <code class="xml">
               &lt;editor&gt;
               &lt;first-name&gt;Carlos&lt;/first-name&gt;
               &lt;surname&gt;Araya&lt;/surname&gt;
               &lt;type&gt;Managing&lt;/type&gt;
               &lt;/editor&gt;

            </code>
         </pre>

         OtherRoles takes all other roles that are not author or editor and adds a role element
         to specify what role they play, for example: Illustrator, Indexer, Research Assistant,
         among others. The element looks like this:


         <pre>
            <code class="xml">
               &lt;otherRole&gt;
               &lt;first-name&gt;Sherlock&lt;/first-name&gt;
               &lt;surname&gt;Holmes&lt;/surname&gt;
               &lt;role&gt;Researcher&lt;/role&gt;
               &lt;/otherRole&gt;

            </code>
         </pre>
         <p>Next we create wrappers for each group as
            <em>authors</em>,
            <em>editors</em> and
            <em>otherRoles</em> so we can provide easier styling with XSLT and CSS later on.
         </p>
         <pre>
            <code class="xml">
               &lt;xs:complexType name="authors"&gt;
               &lt;xs:annotation&gt;
               &lt;xs:documentation&gt;Wrapper to get more than one author&lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="author" type="person"/&gt;
               &lt;/xs:sequence&gt;
               &lt;/xs:complexType&gt;

               &lt;xs:complexType name="editors"&gt;
               &lt;xs:annotation&gt;
               &lt;xs:documentation&gt;
               extension to person to indicate editor and his/her role
               &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
               &lt;xs:complexContent&gt;
               &lt;xs:extension base="person"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="type" type="xs:token"/&gt;
               &lt;/xs:sequence&gt;
               &lt;/xs:extension&gt;
               &lt;/xs:complexContent&gt;
               &lt;/xs:complexType&gt;

               &lt;xs:complexType name="otherRoles"&gt;
               &lt;xs:annotation&gt;
               &lt;xs:documentation&gt;
               extension to person to accomodate roles other than author and editor
               &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
               &lt;xs:complexContent&gt;
               &lt;xs:extension base="person"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="role" type="xs:token"/&gt;
               &lt;/xs:sequence&gt;
               &lt;/xs:extension&gt;
               &lt;/xs:complexContent&gt;
               &lt;/xs:complexType&gt;

            </code>
         </pre>
         <p>We now look at the elements that we can put inside a section. Some of these elements
            are overtly complex and deliberately so since they have to acommodate a lot of possible
            parameters.
         </p>
         <p>We'll look at links first as it is the simplest of our content structures. We borrow
            the
            <em>href</em> attribute from HTML to indicate the destination for the link and make it required.

         </p>
         <p>We also incoporate a
            <em>label</em> so we can later build the link and for accessibility purposes. It also uses our `genericPropertiesGroup`
            attribute set to add class and ID as attributes for our links.
         </p>
         <pre>
            <code class="xml">
               &lt;!-- Elements inside section --&gt;
               &lt;xs:element name="link"&gt;
               &lt;xs:annotation&gt;
               &lt;xs:documentation&gt;links...&lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
               &lt;xs:complexType&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup" /&gt;
               &lt;xs:attribute name="href" type="xs:string" use="required"&gt;
               &lt;xs:annotation&gt;
               &lt;xs:documentation&gt;
               Link destination
               &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
               &lt;/xs:attribute&gt;
               &lt;xs:attribute name="label" type="xs:string" use="required"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>

         The link in our resulting book will look like this:


         <pre>
            <code class="xml">
               &lt;link href="http://google.com" label="link to google"/&gt;

            </code>
         </pre>

         and with the optional attributes it will look like this


         <pre>
            <code class="xml">
               &lt;link class="external" id="ex01" href="http://google.com" label="link to google"&gt;


            </code>
         </pre>
         <p>Once I had the links I figured I need a way to create anchors for internal links that
            look like this:
            <em>&lt;a href="#top"&gt;</em> and expect the target to be formated like this
            <em>&lt;a name="top"&gt;</em>. To accomodate this I created an anchor element to provide the destination for internal
            links.
         </p>
         <pre>
            <code class="xml">
               &lt;!-- Named Anchor --&gt;
               &lt;xs:element name="anchor"&gt;
               &lt;xs:complexType&gt;
               &lt;xs:attribute name="name"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>As I was working on further ideas for the project I realized that we forgot to create
            inline and block level containers for the content, important if you're going to style
            smaller portions of content within a paragraph or witin a section. Taking the names
            from HTML we define
            <em>section</em> (inline) and
            <em>div</em> (block) elements. Div is a secondary section, containing the same model as the section,
            including additional div containers.
         </p>
         <pre>
            <code class="javascript">
               &lt;xs:element name="div"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
               &lt;xs:element ref="code"/&gt;
               &lt;xs:element ref="para" minOccurs="1" maxOccurs="unbounded"/&gt;
               &lt;xs:element ref="ulist"/&gt;
               &lt;xs:element ref="olist"/&gt;
               &lt;xs:element ref="figure"/&gt;
               &lt;xs:element ref="image"/&gt;
               &lt;xs:element ref="div"/&gt;
               &lt;xs:element ref="span"/&gt;
               &lt;xs:element ref="blockquote"/&gt;
               &lt;xs:element ref="h1"/&gt;
               &lt;xs:element ref="h2"/&gt;
               &lt;xs:element ref="h3"/&gt;
               &lt;xs:element ref="h4"/&gt;
               &lt;xs:element ref="h5"/&gt;
               &lt;xs:element ref="h6"/&gt;
               &lt;/xs:choice&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="type" type="xs:token" use="optional"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>Span is an inline element, therefore the model is greatly reduced to only the elements
            that can be inside a paragraph
         </p>
         <p>Type is used in these two elements and in our sections to create data-type and epub:type
            attributes. These are used in the Paged Media stylesheet to decide how will the content
            be formated.
         </p>
         <pre>
            <code class="xml">
               &lt;xs:element name="span"&gt;
               &lt;xs:complexType&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="type" type="xs:token" use="optional" default="chapter"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>Next are images and figures where we borrow from HTML, again, for the name of attribute
            names and their functionality. We define 3 elements for the image-related tags:
            <em>figure</em>,
            <em>figcaption</em> and the
            <em>image</em> itself.
         </p>
         <p>
            <em>Figure</em> is the wrapper around a `figcaption` caption and the `image` element itself. The
            `figcaption` is a text-only element that will contain the caption for the associated
            image
         </p>
         <pre>
            <code class="xml">
               &lt;!-- Figure and related elements --&gt;
               &lt;xs:element name="figure"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:all&gt;
               &lt;xs:element ref="image"/&gt;
               &lt;xs:element ref="figcaption"/&gt;
               &lt;/xs:all&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>The caption child only uses text and, because it's only used as a child of figure,
            we don't need to assign attributes to it. It will inherit from the image or the surrounding
            figure.
         </p>
         <pre>
            <code class="xml">
               &lt;xs:element name="figcaption"&gt;
               &lt;xs:annotation&gt;
               &lt;xs:documentation&gt;
               caption for the image in the figure. Because it's only used
               as a child of figure, we don't need to assign attributes to
               it
               &lt;/xs:documentation&gt;
               &lt;/xs:annotation&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>When working with the image element we start with `genericPropertiesGroup` to define

            <em>class</em> and
            <em>id</em>.
         </p>
         <p>Then we require a
            <em>src</em> attribute to tell where the image is located. We need to be careful because we haven't
            told the schema the different types of images. We have at least three different locations
            for the image files. All three of these are valid locations for our image.png file.
         </p>
         <pre>
            <code class="bash">
               image.png
               directory/image.png
               http://mysite.org/images/image.png

            </code>
         </pre>
         <p>We could create branches of our schema to deal with the different locations but I've
            chosen to let the XSLT style sheets deal with this particular situation. The schema
            type for the image (
            <em>xs:anyURI</em>) should also help to sort out the issue.
         </p>
         <p>
            <em>width</em> and
            <em>height</em> are expressed as integer and are left as optional to account for the possibility
            that the CSS or XSLT stylesheets modify the image dimensions. Making these dimensions
            mandatory may affect how the element interact with the styles later on.
         </p>
         <p>The
            <em>alt</em> attribute indicates alternative text for the image. It is not meant as a full description
            so we've constrained it to 255 characters.
         </p>
         <p>
            <em>align</em> uses our align enumeration to indicae the image's alignment. It is not essential
            to the XML but will be useful to the XSLT stylesheets we'll create later as part of
            the process.
         </p>
         <pre>
            <code class="xml">
               &lt;xs:element name="image"&gt;
               &lt;xs:complexType&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup" /&gt;
               &lt;xs:attribute name="src" type="xs:string" use="required"/&gt;
               &lt;xs:attribute name="height" type="xs:integer" use="optional"/&gt;
               &lt;xs:attribute name="width" type="xs:integer" use="optional"/&gt;
               &lt;xs:attribute name="alt" type="string255" use="required"/&gt;
               &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>In order to acommodate the four basic styles available to our documents:
            <em>strong</em>,
            <em>emphasis</em>,
            <em>strike</em> and
            <em>underline</em> and their nesting we had to do some juryriging of the elements to tell the schema
            what children are allowed for each element.  The schema look like this:
         </p>
         <pre>
            <code class="xml">
               &lt;xs:element name="strong"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
               &lt;xs:element ref="emphasis"/&gt;
               &lt;xs:element ref="underline"/&gt;
               &lt;xs:element ref="strike"/&gt;
               &lt;/xs:choice&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

               &lt;xs:element name="emphasis"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
               &lt;xs:element ref="strong"/&gt;
               &lt;xs:element ref="emphasis"/&gt;
               &lt;xs:element ref="underline"/&gt;
               &lt;xs:element ref="strike"/&gt;
               &lt;/xs:choice&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

               &lt;xs:element name="underline"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
               &lt;xs:element ref="strong"/&gt;
               &lt;xs:element ref="emphasis"/&gt;
               &lt;xs:element ref="strike"/&gt;
               &lt;/xs:choice&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

               &lt;xs:element name="strike"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
               &lt;xs:element ref="strong"/&gt;
               &lt;xs:element ref="emphasis"/&gt;
               &lt;xs:element ref="underline"/&gt;
               &lt;/xs:choice&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>The
            <em>emphasis</em> element is the only one that allows the same element to be nested. When nesting emphasis
            elements they cancel each other
         </p>
         <p>When I first conceptualized the project I envisioned one element for both numbered
            and bulleted lists. That proved to difficult to  implement and to cumbersome to write
            so I reverted to having to sepratate lists, one for ordered or numbered lists (
            <em>olist</em>) and one for unordered or bulleted lists (
            <em>ulist</em>). The only difference is the type of list that we use in XSLT later on.
         </p>
         <p>The list elements also require at least 1
            <em>item</em> child. If it's going to be left empty why bother having the list to begin with.
         </p>
         <p>They inherit class and ID from
            <em>genreicPropertiesGroup</em>.
         </p>
         <pre>
            <code class="xml">
               &lt;!-- Lists --&gt;
               &lt;xs:element name="ulist"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:sequence minOccurs="1" maxOccurs="unbounded"&gt;
               &lt;xs:element ref="item"/&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

               &lt;xs:element name="olist"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:sequence minOccurs="1" maxOccurs="unbounded"&gt;
               &lt;xs:element ref="item"/&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

               &lt;xs:element name="item"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>The
            <em>code</em> element wraps code and works as higlighted, fenced code blocks (think Github Flavored
            Markdown.)
         </p>
         <p>When using CSS we'll generate a &lt;code&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/code&gt; block with a language attribute
            that will be formated with Highlight.js (the chosen package will be a part of the
            project tool chain)
         </p>
         <p>Because of the intended use, the `language` attribute is required.</p>
         <p>Class and ID (from
            <em>genericPropertiesGroup</em>) are optional
         </p>
         <pre>
            <code class="xml">
               &lt;xs:element name="code"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="language" use="required"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>Another type of element that came up when working on the documentation were aside,
            blockquotes and quotes. `Blockquote` and `attribution` are for longer block level
            quotations (more than 4 lines of text) while `quote` is for shorter quotations usually
            inserted in a paragraph.
         </p>
         <pre>
            <code class="xml">
               &lt;xs:element name="code"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="language" use="required"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>Paragraphs (
            <em>para</em> in our documents) are the essential unit of content for our books. The paragraph
            is where most content will happen, text, styles and additional elements that we may
            add as we go along (inline code comes to mind).
         </p>
         <p>We include 3 different groups of properties in the paragraph declaration: Styles (
            <em>strong</em>,
            <em>emphasis</em>,
            <em>underline</em> and
            <em>strike</em> to do bold, italics, underline (outside links) and strikethrough text); Organization
            (
            <em>span</em> and
            <em>link</em>) and our
            <em>genericPropertiesGroup</em> (class and id).
         </p>
         <p>This model barely begins to scratch the surface of what we can do with our paragraph
            model. I decided to go for simplicity rather than completeness. This will definitely
            change in future versions of the schema.
         </p>
         <pre>
            <code class="xml">
               &lt;!-- Paragraphs --&gt;
               &lt;xs:element name="para"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:choice  minOccurs="0" maxOccurs="unbounded"&gt;
               &lt;xs:element ref="strong"/&gt;
               &lt;xs:element ref="emphasis"/&gt;
               &lt;xs:element ref="underline"/&gt;
               &lt;xs:element ref="strike"/&gt;
               &lt;xs:element ref="link"/&gt;
               &lt;xs:element ref="span"/&gt;
               &lt;xs:element ref="quote"/&gt;
               &lt;/xs:choice&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>Like HTML we've chose to create 6 levels of headings although, to be honest, I can't
            see the need for more than 4.
         </p>
         <p>We give all links three attributes:
            <em>class</em>,
            <em>id</em> and
            <em>align</em> to hint stylesheets where we want to place the heading (left, right, center)
         </p>
         <pre>
            <code class="xml">
               &lt;!-- Headings --&gt;
               &lt;xs:element name="h1"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

               &lt;xs:element name="h2"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

               &lt;xs:element name="h3"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

               &lt;xs:element name="h4"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

               &lt;xs:element name="h5"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

               &lt;xs:element name="h6"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>The metadata section tells us more about the book itself and can be used to build
            a
            <em>package.opf</em> manifest using XSLT as part of our transformation process. We include basic information
            such as
            <em>isbn</em> (validated as an ISBN type defined earlier in the schema), an
            <em>edition</em> (integer indicating what edition of the book it is) and
            <em>title</em>.
         </p>
         <pre>
            <code class="xml">
               &lt;!-- Metadata element --&gt;
               &lt;xs:element name="metadata"&gt;
               &lt;xs:complexType&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="isbn" type="isbn"/&gt;
               &lt;xs:element name="edition" type="xs:integer"/&gt;
               &lt;xs:element name="title" type="token255"/&gt;
               &lt;xs:element name="authors" type="authors" minOccurs="1" maxOccurs="unbounded"/&gt;
               &lt;xs:element name="editors" type="editors" minOccurs="0" maxOccurs="unbounded"/&gt;
               &lt;xs:element name="otherRoles" type="otherRoles" minOccurs="0" maxOccurs="unbounded"/&gt;
               &lt;xs:element ref="para"/&gt;
               &lt;/xs:sequence&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>Section is our primary container for paragraphs and associated content. Some of the
            items exclusive to sections are:
         </p>
         <p>The
            <em>title</em> element is required to appear exactly one time.
         </p>
         <p>We can have 1 or more
            <em>para</em> elements.
         </p>
         <p>We can use 0 or more of the following elements:</p>
         <ul>
            <li>code fenced code blocks elements</li>
            <li>ulist unordered list</li>
            <li>olist ordered (numbered) lists</li>
            <li>figure for captioned images</li>
            <li>image without captions</li>
            <li>div block level containers</li>
            <li>span inline level container</li>
         </ul>
         <p>The element inherits
            <em>class</em> and
            <em>ID</em> from genericPropertiesGroup.
         </p>
         <p>Finally we add the `type` to create data-type and/or epub:type attributes. I chose
            to make it option and default it to chapter. We want to make it easier for authors
            to create content; where possible. I'd rather have the wrong value than no value at
            all.
         </p>
         <pre>
            <code class="xml">
               &lt;!-- Section element --&gt;
               &lt;xs:element name="section"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element name="title" type="xs:token" minOccurs="1" maxOccurs="1"/&gt;
               &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
               &lt;xs:element ref="code"/&gt;
               &lt;xs:element ref="para" minOccurs="1" maxOccurs="unbounded"/&gt;
               &lt;xs:element ref="ulist"/&gt;
               &lt;xs:element ref="olist"/&gt;
               &lt;xs:element ref="figure"/&gt;
               &lt;xs:element ref="image"/&gt;
               &lt;xs:element ref="div"/&gt;
               &lt;xs:element ref="span"/&gt;
               &lt;xs:element ref="blockquote"/&gt;
               &lt;xs:element ref="h1"/&gt;
               &lt;xs:element ref="h2"/&gt;
               &lt;xs:element ref="h3"/&gt;
               &lt;xs:element ref="h4"/&gt;
               &lt;xs:element ref="h5"/&gt;
               &lt;xs:element ref="h6"/&gt;
               &lt;/xs:choice&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;xs:attribute name="type" type="xs:token" use="optional" default="chapter"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>Now that we have defined our elements, we'll define the core structure of the document
            by defining the structure of the `book` element.
         </p>
         <p>After all the work we've done defining the content the definition of our book is almost
            anticlimatic. We define the `book` element as the sequence of exactly 1
            <em>metadata</em> element and 1 or more
            <em>section</em> elements.
         </p>
         <p>As with all our elements we add
            <em>class</em> and
            <em>ID</em> from our genericPropertiesGroup.
         </p>
         <pre>
            <code class="xml">
               &lt;xs:element name="book"&gt;
               &lt;xs:complexType mixed="true"&gt;
               &lt;xs:sequence&gt;
               &lt;xs:element ref="metadata" minOccurs="0" maxOccurs="1"/&gt;
               &lt;xs:element ref="section" minOccurs="1" maxOccurs="unbounded"/&gt;
               &lt;/xs:sequence&gt;
               &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
               &lt;/xs:complexType&gt;
               &lt;/xs:element&gt;

            </code>
         </pre>
         <p>This covers the schema for our document type. It is not completed by any stretch of
            the imagination. It can be further customized to suit individual needs. The current
            version represents a very basic text heavy document type.
         </p>
         <p>There are definitely more elements to add like video, audio and others both with equivalent
            elements in HTML and compound elements based on your needs.
         </p>
      </section>
   </body>
</html>
