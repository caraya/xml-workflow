<?xml version="1.0" encoding="UTF-8"?>
<book xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="xsd/book-schema-draft.xsd">
  <metadata>
      <title>XML workflow documentation</title>

      <authors>
          <author>
              <first-name>Carlos</first-name>
              <surname>Araya</surname>
          </author>
      </authors>
  </metadata>

  <section type="dedication">
    <title>Thank You</title>
    <para>Thanks to Laura Brady for getting this particular idea started :)</para>
  </section>

  <section type="preface">
      <title>Introduction</title>

      <para>One of the biggest limitations of markup languages, in my opinion, is how confining they are. Even large vocabularies like <link href="http://docbook.org" label="Docbook"/> are limited in what they can do out of the box. HTML4 is non-extensible and HTML5 is limited in how you can extend it (web components are the only way to extend HTML5 I'm aware of that doesn't require an update to the HTML specification.)</para>

<para>By creating our own markup vocabulary we can be as expressive as we need to be without adding additional complexity for writers and users and without adding unecessary complexity for the developers building the tools to interact with the markup.
</para>

<h2>Why create our own markup</h2>

<para>I have a few answers to that question:</para>

<para>In creating your own xml-based markup you enforce separation of content and style. The XML document provides the basic content of the document and the hints to use elsewhere. XSLT stylesheets allow you to structure the base document and associated hints into any number of formats (for the purposes of this document we'll concentrate on XHTML, PDF created through Paged Media CSS and PDF created using XSL formatting Objects)</para>

<para>Creating a domain specific markup vocabulary allows you think about structure and complexity for yourself as the editor/typesetter and for your authors. It makes you think about elements and attributes and which one is better for the given experience you want and what, if any, restrictions you want to impose on your makeup.</para>

<para>By creating our own vocabulary we make it easier for authors to write clean and simple content. XML provides a host of validation tools to enforce the structure and format of the XML document.</para>

<h2>Options for defining the markup</h2>

<para>For the purpose of this project we'll define a set of resources that work with a book structure like the one below:</para>

<code language="xml">
 &lt;?xml version="1.0" encoding="UTF-8"?>
 &lt;book
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="xsd/book-schema-draft.xsd">
  &lt;metadata>
    &lt;title>Sample Document&lt;/title>
    &lt;authors>
      &lt;author>
        &lt;first-name>Carlos&lt;/first-name>
        &lt;surname>Araya&lt;/surname>
      &lt;/author>
    &lt;/authors>
  &lt;/metadata>

  &lt;section type="chapter">
    &lt;title>Chapter 1&lt;/title>

    &lt;para>&lt;/para>
    &lt;para>&lt;/para>
    &lt;para>&lt;/para>

  &lt;/section>

  &lt;section type="chapter">

  &lt;title>Chapter 2&lt;/title>

  &lt;para>&lt;/para>
  &lt;para>&lt;/para>
  &lt;para>&lt;/para>

  &lt;/section>
&lt;/book>
</code>


<para>It is not a complete structure. We will continue adding elements afte we reach the MVP (Minimum Viable Product) stage. As usual, feedback is always appreciated.</para>
    </section>

  <section type="chapter">
      <title>XML Schema</title>

<para>The schema is defined from most general to most specific elements. We'll follow the same process to explain what the schema does and how we arrived to the choices we made. </para>

<para>At the beginning of the schema we define some custom types that will be used throughout the document.</para>

<para>The first one, <emphasis>string255</emphasis> is a string that is limited to 255 characters in length. We do this to prevent overtly long strings.</para>

<para>The second one, <emphasis>isbn</emphasis> is a regular expression to match 10 digits ISBN numbers. We'll have to modify it to handle ISBN-13 as well as 10.</para>

<para>The third custom type is an enumeration of all possible values for the <emphasis>align</emphasis> attribute acording to CSS and HTML. Rather than manually type each of these we will reference this enumeration and include all its values for "free".</para>

<para>We also allow the optional use of <emphasis>class</emphasis> and <emphasis>id</emphasis> attributes for the book by assigning `genericPropertiesGroup` attribute group as attributes to the group. We'll see this assigned to other elements so I decided to make it reusable rather than have to duplicate the attributes in every element I want to use them in.</para>

<code language="xml">
&lt;!-- Simple types to use in the content -->
&lt;xs:simpleType name="token255">
  &lt;xs:restriction base="xs:token">
    &lt;xs:maxLength value="255"/>
  &lt;/xs:restriction>
&lt;/xs:simpleType>

&lt;xs:simpleType name="isbn">
  &lt;xs:restriction base="xs:unsignedLong">
    &lt;xs:totalDigits value="10"/>
    &lt;xs:pattern value="d{10}"/>
  &lt;/xs:restriction>
&lt;/xs:simpleType>

&lt;xs:simpleType name="align">
  &lt;xs:restriction base="xs:token">
    &lt;xs:enumeration value="left"/>
    &lt;xs:enumeration value="center"/>
    &lt;xs:enumeration value="right"/>
    &lt;xs:enumeration value="justify"/>
  &lt;/xs:restriction>
&lt;/xs:simpleType>

&lt;xs:attributeGroup name="genericPropertiesGroup">
  &lt;xs:attribute name="id" type="xs:ID" use="optional"/>
  &lt;xs:attribute name="class" type="xs:token" use="optional"/>
&lt;/xs:attributeGroup>
</code>

<para>The next stage is to define elements to create our <emphasis>people</emphasis> types.  We create a base person element and then create three role elements based on person. We will use this next to define groups for each role.</para>

<code language="xml">
&lt;!-- complex types to create groups of similar person items -->
&lt;xs:complexType name="person">
  &lt;xs:sequence>
    &lt;xs:element name="first-name" type="xs:token"/>
    &lt;xs:element name="surname" type="xs:token"/>
  &lt;/xs:sequence>
  &lt;xs:attribute name="id" type="xs:ID" use="optional"/>
&lt;/xs:complexType>

&lt;xs:complexType name="author">
  &lt;xs:choice minOccurs="1" maxOccurs="unbounded">
    &lt;xs:element name="author" type="person"/>
  &lt;/xs:choice>
&lt;/xs:complexType>

&lt;xs:complexType name="editor">
  &lt;xs:complexContent>
    &lt;xs:extension base="person">
      &lt;xs:sequence>
        &lt;xs:element name="type" type="xs:string"/>
      &lt;/xs:sequence>
    &lt;/xs:extension>
  &lt;/xs:complexContent>
&lt;/xs:complexType>

&lt;xs:complexType name="otherRole">
  &lt;xs:complexContent>
    &lt;xs:extension base="person">
      &lt;xs:sequence minOccurs="1" maxOccurs="1">
        &lt;xs:element name="role" type="xs:string"/>
      &lt;/xs:sequence>
    &lt;/xs:extension>
  &lt;/xs:complexContent>
&lt;/xs:complexType>
</code>

<para>Two of the derived types add attributes or elements to the base person element to make the generic person more appropriate to their role rather than repeat the content of person each time that an author, editor or other role appear.</para>

<para>Author is the most straight forward and only wraps person in the author element.
</para>

<para>Editor takes the base person element and adds a `type` child to indicate the type of editor (some that come to mind are acquisition, production and managing.) The editor elements looks like this:</para>

<code language="xml">
&lt;editor>
&lt;first-name>Carlos&lt;/first-name>
&lt;surname>Araya&lt;/surname>
&lt;type>Managing&lt;/type>
&lt;/editor>
</code>

<para>OtherRoles takes all other roles that are not author or editor and adds a role element to specify what role they play, for example: Illustrator, Indexer, Research Assistant, among others. The element looks like this:</para>

<code language="xml">
  &lt;otherRole>
  &lt;first-name>Sherlock&lt;/first-name>
  &lt;surname>Holmes&lt;/surname>
  &lt;role>Researcher&lt;/role>
  &lt;/otherRole>
</code>

      <para>Next we create wrappers for each group as <emphasis>authors</emphasis>, <emphasis>editors</emphasis> and <emphasis>otherRoles</emphasis> so we can provide easier styling with XSLT and CSS later on.</para>

<code language="xml">
  &lt;xs:complexType name="authors">
  &lt;xs:annotation>
  &lt;xs:documentation>Wrapper to get more than one author&lt;/xs:documentation>
  &lt;/xs:annotation>
  &lt;xs:sequence>
  &lt;xs:element name="author" type="person"/>
  &lt;/xs:sequence>
  &lt;/xs:complexType>

  &lt;xs:complexType name="editors">
  &lt;xs:annotation>
  &lt;xs:documentation>
  extension to person to indicate editor and his/her role
  &lt;/xs:documentation>
  &lt;/xs:annotation>
  &lt;xs:complexContent>
  &lt;xs:extension base="person">
  &lt;xs:sequence>
  &lt;xs:element name="type" type="xs:token"/>
  &lt;/xs:sequence>
  &lt;/xs:extension>
  &lt;/xs:complexContent>
  &lt;/xs:complexType>

  &lt;xs:complexType name="otherRoles">
  &lt;xs:annotation>
  &lt;xs:documentation>
  extension to person to accomodate roles other than author and editor
  &lt;/xs:documentation>
  &lt;/xs:annotation>
  &lt;xs:complexContent>
  &lt;xs:extension base="person">
  &lt;xs:sequence>
  &lt;xs:element name="role" type="xs:token"/>
  &lt;/xs:sequence>
  &lt;/xs:extension>
  &lt;/xs:complexContent>
  &lt;/xs:complexType>
</code>

<para>We now look at the elements that we can put inside a section. Some of these elements are overtly complex and deliberately so since they have to acommodate a lot of possible parameters.</para>

<para>We'll look at links first as it is the simplest of our content structures. We borrow the <emphasis>href</emphasis> attribute from HTML to indicate the destination for the link and make it required. </para>

<para>We also incoporate a <emphasis>label</emphasis> so we can later build the link and for accessibility purposes. It also uses our `genericPropertiesGroup` attribute set to add class and ID as attributes for our links.</para>

<code language="xml">
  &lt;!-- Elements inside section -->
  &lt;xs:element name="link">
  &lt;xs:annotation>
  &lt;xs:documentation>links...&lt;/xs:documentation>
  &lt;/xs:annotation>
  &lt;xs:complexType>
  &lt;xs:attributeGroup ref="genericPropertiesGroup" />
  &lt;xs:attribute name="href" type="xs:string" use="required">
  &lt;xs:annotation>
  &lt;xs:documentation>
  Link destination
  &lt;/xs:documentation>
  &lt;/xs:annotation>
  &lt;/xs:attribute>
  &lt;xs:attribute name="label" type="xs:string" use="required"/>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>

The link in our resulting book will look like this:

<code language="xml">
&lt;link href="http://google.com" label="link to google"/>
</code>

and with the optional attributes it will look like this

<code language="xml">
&lt;link class="external" id="ex01" href="http://google.com" label="link to google">
</code>

<para>Once I had the links I figured I need a way to create anchors for internal links that look like this: <emphasis>&lt;a href="#top"></emphasis> and expect the target to be formated like this <emphasis>&lt;a name="top"></emphasis>. To accomodate this I created an anchor element to provide the destination for internal links. </para>

<code language="xml">
&lt;!-- Named Anchor -->
&lt;xs:element name="anchor">
  &lt;xs:complexType>
    &lt;xs:attribute name="name"/>
  &lt;/xs:complexType>
&lt;/xs:element>
</code>

<para>As I was working on further ideas for the project I realized that we forgot to create inline and block level containers for the content, important if you're going to style smaller portions of content within a paragraph or witin a section. Taking the names from HTML we define <emphasis>section</emphasis> (inline) and <emphasis>div</emphasis> (block) elements. Div is a secondary section, containing the same model as the section, including additional div containers.</para>

<code language="javascript">
&lt;xs:element name="div">
  &lt;xs:complexType mixed="true">
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
      &lt;xs:element ref="code"/>
      &lt;xs:element ref="para" minOccurs="1" maxOccurs="unbounded"/>
      &lt;xs:element ref="ulist"/>
      &lt;xs:element ref="olist"/>
      &lt;xs:element ref="figure"/>
      &lt;xs:element ref="image"/>
      &lt;xs:element ref="div"/>
      &lt;xs:element ref="span"/>
      &lt;xs:element ref="blockquote"/>
      &lt;xs:element ref="h1"/>
      &lt;xs:element ref="h2"/>
      &lt;xs:element ref="h2"/>
      &lt;xs:element ref="h3"/>
      &lt;xs:element ref="h5"/>
      &lt;xs:element ref="h6"/>
    &lt;/xs:choice>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="type" type="xs:token" use="optional"/>
  &lt;/xs:complexType>
&lt;/xs:element>
</code>

<para>Span is an inline element, therefore the model is greatly reduced to only the elements that can be inside a paragraph</para>

<para>Type is used in these two elements and in our sections to create data-type and epub:type attributes. These are used in the Paged Media stylesheet to decide how will the content be formated.</para>

<code language="xml">
&lt;xs:element name="span">
  &lt;xs:complexType>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="type" type="xs:token" use="optional" default="chapter"/>
  &lt;/xs:complexType>
&lt;/xs:element>
</code>

<para>Next are images and figures where we borrow from HTML, again, for the name of attribute names and their functionality. We define 3 elements for the image-related tags: <emphasis>figure</emphasis>, <emphasis>figcaption</emphasis> and the <emphasis>image</emphasis> itself.</para>

<para><emphasis>Figure</emphasis> is the wrapper around a `figcaption` caption and the `image` element itself. The `figcaption` is a text-only element that will contain the caption for the associated image</para>

<code language="xml">
  &lt;!-- Figure and related elements -->
  &lt;xs:element name="figure">
  &lt;xs:complexType mixed="true">
  &lt;xs:all>
  &lt;xs:element ref="image"/>
  &lt;xs:element ref="figcaption"/>
  &lt;/xs:all>
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>

<para>The caption child only uses text and, because it's only used as a child of figure, we don't need to assign attributes to it. It will inherit from the image or the surrounding figure.</para>

<code language="xml">
  &lt;xs:element name="figcaption">
  &lt;xs:annotation>
  &lt;xs:documentation>
  caption for the image in the figure. Because it's only used
  as a child of figure, we don't need to assign attributes to
  it
  &lt;/xs:documentation>
  &lt;/xs:annotation>
  &lt;/xs:element>
</code>

<para>When working with the image element we start with `genericPropertiesGroup` to define <emphasis>class</emphasis> and <emphasis>id</emphasis>.</para>

<para>Then we require a <emphasis>src</emphasis> attribute to tell where the image is located. We need to be careful because we haven't told the schema the different types of images. We have at least three different locations for the image files. All three of these are valid locations for our image.png file.</para>

<code language="bash">
  image.png
  directory/image.png
  http://mysite.org/images/image.png
</code>

<para>We could create branches of our schema to deal with the different locations but I've chosen to let the XSLT style sheets deal with this particular situation. The schema type for the image (<emphasis>xs:anyURI</emphasis>) should also help to sort out the issue.</para>

<para> <emphasis>width</emphasis> and <emphasis>height</emphasis> are expressed as integer and are left as optional to account for the possibility that the CSS or XSLT stylesheets modify the image dimensions. Making these dimensions mandatory may affect how the element interact with the styles later on.</para>

<para>The <emphasis>alt</emphasis> attribute indicates alternative text for the image. It is not meant as a full description so we've constrained it to 255 characters.</para>

<para><emphasis>align</emphasis> uses our align enumeration to indicae the image's alignment. It is not essential to the XML but will be useful to the XSLT stylesheets we'll create later as part of the process.</para>

<code language="xml">
  &lt;xs:element name="image">
  &lt;xs:complexType>
  &lt;xs:attributeGroup ref="genericPropertiesGroup" />
  &lt;xs:attribute name="src" type="xs:string" use="required"/>
  &lt;xs:attribute name="height" type="xs:integer" use="optional"/>
  &lt;xs:attribute name="width" type="xs:integer" use="optional"/>
  &lt;xs:attribute name="alt" type="string255" use="required"/>
  &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>

<para>In order to acommodate the four basic styles available to our documents: <emphasis>strong</emphasis>, <emphasis>emphasis</emphasis>, <emphasis>strike</emphasis> and <emphasis>underline</emphasis> and their nesting we had to do some juryriging of the elements to tell the schema what children are allowed for each element.  The schema look like this:</para>

<code language="xml">
  &lt;xs:element name="strong">
  &lt;xs:complexType mixed="true">
  &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
  &lt;xs:element ref="emphasis"/>
  &lt;xs:element ref="underline"/>
  &lt;xs:element ref="strike"/>
  &lt;/xs:choice>
  &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name="emphasis">
  &lt;xs:complexType mixed="true">
  &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
  &lt;xs:element ref="strong"/>
  &lt;xs:element ref="emphasis"/>
  &lt;xs:element ref="underline"/>
  &lt;xs:element ref="strike"/>
  &lt;/xs:choice>
  &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name="underline">
  &lt;xs:complexType mixed="true">
  &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
  &lt;xs:element ref="strong"/>
  &lt;xs:element ref="emphasis"/>
  &lt;xs:element ref="strike"/>
  &lt;/xs:choice>
  &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name="strike">
  &lt;xs:complexType mixed="true">
  &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
  &lt;xs:element ref="strong"/>
  &lt;xs:element ref="emphasis"/>
  &lt;xs:element ref="underline"/>
  &lt;/xs:choice>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>

<para>The <emphasis>emphasis</emphasis> element is the only one that allows the same element to be nested. When nesting emphasis elements they cancel each other</para>

<para>When I first conceptualized the project I envisioned one element for both numbered and bulleted lists. That proved to difficult to  implement and to cumbersome to write so I reverted to having to sepratate lists, one for ordered or numbered lists (<emphasis>olist</emphasis>) and one for unordered or bulleted lists (<emphasis>ulist</emphasis>). The only difference is the type of list that we use in XSLT later on.</para>

<para>The list elements also require at least 1 <emphasis>item</emphasis> child. If it's going to be left empty why bother having the list to begin with.</para>

<para>They inherit class and ID from <emphasis>genreicPropertiesGroup</emphasis>.</para>

<code language="xml">
  &lt;!-- Lists -->
  &lt;xs:element name="ulist">
  &lt;xs:complexType mixed="true">
  &lt;xs:sequence minOccurs="1" maxOccurs="unbounded">
  &lt;xs:element ref="item"/>
  &lt;/xs:sequence>
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name="olist">
  &lt;xs:complexType mixed="true">
  &lt;xs:sequence minOccurs="1" maxOccurs="unbounded">
  &lt;xs:element ref="item"/>
  &lt;/xs:sequence>
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name="item">
  &lt;xs:complexType mixed="true">
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>

<para>The <emphasis>code</emphasis> element wraps code and works as higlighted, fenced code blocks (think Github Flavored Markdown.)</para>

<para>When using CSS we'll generate a &lt;code>&lt;pre>&lt;/pre>&lt;/code> block with a language attribute that will be formated with Highlight.js (the chosen package will be a part of the project tool chain)</para>

<para>Because of the intended use, the `language` attribute is required.</para>

<para>Class and ID (from <emphasis>genericPropertiesGroup</emphasis>) are optional</para>

<code language="xml">
  &lt;xs:element name="code">
  &lt;xs:complexType mixed="true">
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;xs:attribute name="language" use="required"/>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>

<para>Another type of element that came up when working on the documentation were aside, blockquotes and quotes. `Blockquote` and `attribution` are for longer block level quotations (more than 4 lines of text) while `quote` is for shorter quotations usually inserted in a paragraph.</para>

<code language="xml">
&lt;xs:element name="code">
  &lt;xs:complexType mixed="true">
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="language" use="required"/>
  &lt;/xs:complexType>
&lt;/xs:element>
</code>

<para>Paragraphs (<emphasis>para</emphasis> in our documents) are the essential unit of content for our books. The paragraph is where most content will happen, text, styles and additional elements that we may add as we go along (inline code comes to mind).</para>

<para>We include 3 different groups of properties in the paragraph declaration: Styles (<emphasis>strong</emphasis>, <emphasis>emphasis</emphasis>, <emphasis>underline</emphasis> and <emphasis>strike</emphasis> to do bold, italics, underline (outside links) and strikethrough text); Organization (<emphasis>span</emphasis> and <emphasis>link</emphasis>) and our <emphasis>genericPropertiesGroup</emphasis> (class and id).</para>

<para>This model barely begins to scratch the surface of what we can do with our paragraph model. I decided to go for simplicity rather than completeness. This will definitely change in future versions of the schema.</para>

<code language="xml">
  &lt;!-- Paragraphs -->
  &lt;xs:element name="para">
  &lt;xs:complexType mixed="true">
  &lt;xs:choice  minOccurs="0" maxOccurs="unbounded">
  &lt;xs:element ref="strong"/>
  &lt;xs:element ref="emphasis"/>
  &lt;xs:element ref="underline"/>
  &lt;xs:element ref="strike"/>
  &lt;xs:element ref="link"/>
  &lt;xs:element ref="span"/>
  &lt;xs:element ref="quote"/>
  &lt;/xs:choice>
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>

<para>Like HTML we've chose to create 6 levels of headings although, to be honest, I can't see the need for more than 4. </para>

<para>We give all links three attributes: <emphasis>class</emphasis>, <emphasis>id</emphasis> and <emphasis>align</emphasis> to hint stylesheets where we want to place the heading (left, right, center)</para>

<code language="xml">
  &lt;!-- Headings -->
  &lt;xs:element name="h1">
  &lt;xs:complexType mixed="true">
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name="h2">
  &lt;xs:complexType mixed="true">
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name="h2">
  &lt;xs:complexType mixed="true">
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name="h3">
  &lt;xs:complexType mixed="true">
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name="h5">
  &lt;xs:complexType mixed="true">
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name="h6">
  &lt;xs:complexType mixed="true">
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>


      <para>The metadata section tells us more about the book itself and can be used to build a <emphasis>package.opf</emphasis> manifest using XSLT as part of our transformation process. We include basic information such as <emphasis>isbn</emphasis> (validated as an ISBN type defined earlier in the schema), an <emphasis>edition</emphasis> (integer indicating what edition of the book it is) and <emphasis>title</emphasis>.</para>

<code language="xml">
  &lt;!-- Metadata element -->
  &lt;xs:element name="metadata">
  &lt;xs:complexType>
  &lt;xs:sequence>
  &lt;xs:element name="isbn" type="isbn"/>
  &lt;xs:element name="edition" type="xs:integer"/>
  &lt;xs:element name="title" type="token255"/>
  &lt;xs:element name="authors" type="authors" minOccurs="1" maxOccurs="unbounded"/>
  &lt;xs:element name="editors" type="editors" minOccurs="0" maxOccurs="unbounded"/>
  &lt;xs:element name="otherRoles" type="otherRoles" minOccurs="0" maxOccurs="unbounded"/>
  &lt;xs:element ref="para"/>
  &lt;/xs:sequence>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>

<para>Section is our primary container for paragraphs and associated content. Some of the items exclusive to sections are:</para>

<para>The <emphasis>title</emphasis> element is required to appear exactly one time.</para>

<para>We can have 1 or more <emphasis>para</emphasis> elements.</para>

<para>We can use 0 or more of the following elements:</para>

<ulist>
  <item><emphasis>code</emphasis> fenced code blocks elements</item>
  <item><emphasis>ulist</emphasis> unordered list</item>
  <item><emphasis>olist</emphasis> ordered (numbered) lists</item>
  <item><emphasis>figure</emphasis> for captioned images</item>
  <item><emphasis>image</emphasis> without captions</item>
  <item><emphasis>div</emphasis> block level containers</item>
  <item><emphasis>span</emphasis> inline level container</item>
</ulist>

<para>The element inherits <emphasis>class</emphasis> and <emphasis>ID</emphasis> from genericPropertiesGroup.</para>

<para>Finally we add the `type` to create data-type and/or epub:type attributes. I chose to make it option and default it to chapter. We want to make it easier for authors to create content; where possible. I'd rather have the wrong value than no value at all.</para>

<code language="xml">
  &lt;!-- Section element -->
  &lt;xs:element name="section">
  &lt;xs:complexType mixed="true">
  &lt;xs:sequence>
  &lt;xs:element name="title" type="xs:token" minOccurs="1" maxOccurs="1"/>
  &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
  &lt;xs:element ref="code"/>
  &lt;xs:element ref="para" minOccurs="1" maxOccurs="unbounded"/>
  &lt;xs:element ref="ulist"/>
  &lt;xs:element ref="olist"/>
  &lt;xs:element ref="figure"/>
  &lt;xs:element ref="image"/>
  &lt;xs:element ref="div"/>
  &lt;xs:element ref="span"/>
  &lt;xs:element ref="blockquote"/>
  &lt;xs:element ref="h1"/>
  &lt;xs:element ref="h2"/>
  &lt;xs:element ref="h2"/>
  &lt;xs:element ref="h3"/>
  &lt;xs:element ref="h5"/>
  &lt;xs:element ref="h6"/>
  &lt;/xs:choice>
  &lt;/xs:sequence>
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;xs:attribute name="type" type="xs:token" use="optional" default="chapter"/>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>

<para>Now that we have defined our elements, we'll define the core structure of the document by defining the structure of the `book` element.</para>

<para>After all the work we've done defining the content the definition of our book is almost anticlimatic. We define the `book` element as the sequence of exactly 1 <emphasis>metadata</emphasis> element and 1 or more <emphasis>section</emphasis> elements.</para>

<para>As with all our elements we add <emphasis>class</emphasis> and <emphasis>ID</emphasis> from our genericPropertiesGroup.</para>

<code language="xml">
  &lt;xs:element name="book">
  &lt;xs:complexType mixed="true">
  &lt;xs:sequence>
  &lt;xs:element ref="metadata" minOccurs="0" maxOccurs="1"/>
  &lt;xs:element ref="section" minOccurs="1" maxOccurs="unbounded"/>
  &lt;/xs:sequence>
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
  &lt;/xs:element>
</code>

<para>This covers the schema for our document type. It is not completed by any stretch of the imagination. It can be further customized to suit individual needs. The current version represents a very basic text heavy document type.</para>

<para>There are definitely more elements to add like video, audio and others both with equivalent elements in HTML and compound elements based on your needs.</para>
</section>

  <section type="chapter">
    <title>From XML to HTML</title>

    <para>One of the biggest advantages of working with XML is that we can convert the abstract tags into other markups. For the purposes of this project we'll convert the XML created to match the schema we just created to HTML and then use tools like <link href="http://www.princexml.com" label="PrinceXML"/> or <link href="http://www.antennahouse.com" label="AntenaHouse"/> we'll convert the HTML/CSS files to PDF</para>

    <h2>Why HTML</h2>

    <para>HTML is the default format for the web and for most web/html based content such as ePub and Kindle. As such it makes a perfect candidate to explore how to generate it programatically from a single source file.</para>

    <para>HTML will also act as our source for using CSS paged media to create PDF cotnent.</para>

    <h2>Why PDF</h2>

    <para>Rather than having to deal with <link href="http://www.w3.org/TR/2006/REC-xsl11-20061205/" label="XSL-FO"/>, another XML based vocabulary to create PDF content, we'll use XSLT to create another HTML file and process it with <link href="http://dev.w3.org/csswg/css-page-3/" label="CSS Paged Media"/> and the companion <link href="http://www.w3.org/TR/css-gcpm-3/" label="Generated Content for Paged Media"/> specifications to create PDF content.</para>

    <para>In this document we'll concentrate on the XSLT to HTML conversion and will defer the from HTML to PDF to a later article.</para>

    <h2>Creating our conversion stylesheets</h2>

    <para>To convert our XML into other formats we will use XSL Transformations (also known as XSLT) <link href="http://www.w3.org/TR/xslt" label="version 2"/> (a W3C standard) and <link href="http://www.w3.org/TR/xslt-30/" label="version 3"/> (a W3C last call draft recommendation) where appropriate.</para>

    <para>XSLT is a functional language designed to transform XML into other markup vocabularies. It defines template rules that match elements in your source document and processing them to convert them to the target vocabulary.</para>

    <para>In the XSLT example below, we do the following:</para>

    <olist>
      <item>Declare the file to be an XML document</item>
      <item>Define the root element of the stylesheet (xsl:stylesheet)</item>
      <item>Indicate the namespaces that we'll use in the document and, in this case, tell the processor to excluse the given namespaces</item>
      <item>Strip whitespaces from all elements and preserve it in the code elements</item>
      <item>Create the default output we'll use for the main document and all generated pages (discussed later)</item>
      <item>Create a default template to warn us if we missed anything</item>
    </olist>

    <code language="xml">&lt;?xml version="1.0" ?>
&lt;!-- Define stylesheet root and namespaces we'll work with -->
&lt;xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:epub="http://www.idpf.org/2007/opf"
  exclude-result-prefixes="dc epub"
  xml:lang="en-US"
  version="2.0">
  &lt;!-- Strip whitespace from the listed elements -->
  &lt;xsl:strip-space elements="*"/>
  &lt;!-- And preserve it from the elements below -->
  &lt;xsl:preserve-space elements="code"/>
  &lt;!-- Define the output for this and all document children -->
  &lt;xsl:output name="xhtml-out" method="xhtml" indent="yes" encoding="UTF-8" omit-xml-declaration="yes" />

    &lt;!--
    Default template taken from http://bit.ly/1sXqIL8

    This will tell us of any unmatched elements rather than
    failing silently
    -->
    &lt;xsl:template match="*">
      &lt;xsl:message terminate="no">
        WARNING: Unmatched element: &lt;xsl:value-of select="name()"/>
      &lt;/xsl:message>

      &lt;xsl:apply-templates/>
    &lt;/xsl:template>

  &lt;!-- More content to be added -->
&lt;/xsl:stylesheet></code>

    <para>This is a lot of work before we start creating our XSLT content. But it's worth doing the work up front. We'll see what are the advantages of doint it this way as we move down the style sheet.</para>

    <para>Now onto our root templates. The first one is the entry point to our document. It performs the following tasks:</para>

    <olist>
      <item>Match the root element to create the skeleton for our HTML content</item>
      <item>In the title we insert the content of the <emphasis>metadata/title</emphasis> element</item>
      <item>In the body we 'apply' the templates that match the content inside our document (more on this later)</item>
    </olist>

    <code language="xml">&lt;!-- Root template, matching / -->
&lt;xsl:template match="book">
  &lt;html>
    &lt;head>
      &lt;xsl:element name="title">
          &lt;xsl:value-of select="metadata/title"/>
      &lt;/xsl:element>
      &lt;xsl:element name="meta">
        &lt;xsl:attribute name="generator">
          &lt;xsl:value-of select="system-property('xsl:product-name')"/>
          &lt;xsl:value-of select="system-property('xsl:product-version')"/>
        &lt;/xsl:attribute>
      &lt;/xsl:element>
      &lt;link rel="stylesheet" href="css/style.css" />
      &lt;xsl:if test="(code)">
        &lt;!--
        Use highlight.js and docco style
        -->
        &lt;link rel="stylesheet" href="css/styles/docco.css" />
        &lt;!-- Load highlight.js -->
        &lt;script src="lib/highlight.pack.js">&lt;/script>
        &lt;script>
          hljs.initHighlightingOnLoad();
        &lt;/script>
      &lt;/xsl:if>
      &lt;!--
        Comment this out for now. It'll become relevant when we add video
        &lt;script src="js/script.js">&lt;/script>
      -->
    &lt;/head>
    &lt;body>
      &lt;xsl:apply-templates/>
      &lt;xsl:apply-templates select="/" mode="toc"/>
    &lt;/body>
  &lt;/html>
&lt;/xsl:template></code>

    <para>We could build the CSS stylesheet and Javascript files as part of our root template but we chose not to.</para>

    <para>Working with the stylesheet as part of the XSLT stylesheet allows the XSLT stylesheet designer to embed the style and parameterize the stylesheet, thus making the stylesheet customizable from the command line.</para>

    <para>For all advantages, this method ties the styles for the project to the XSLT stylesheet and requires the XSLT stylesheet designer to be involved in all CSS and Javascript updates.</para>

    <para>By linking to external CSS and Javascript files we can leverage expertise independent of the Schema and XSLT stylesheets. Book designers can work on the CSS, UX and experience designers can work on Javascript and additional CSS areas, book designers can work on the Paged Media stylesheets and authors can just write.</para>

    <para>Furthermore we can reuse our CSS and Javascript on multiple documents.</para>

    <h2>Table of contents</h2>

    <blockquote>
      <para>The table of content template is under active development and will be different depending on the desired output. I document it here as it is right now but will definitely change as it's further developed.</para>
    </blockquote>

    <para>There is a second template matching the root element of our document to create a table of content. At first thought this looks like the wrong approach</para>

    <para>We leverage XSLT modes that allow us to create templates for the same element to perform different tasks. In `toc mode` we want the root template to do the following:</para>

    <olist>
      <item>Create the section and nav and ol elements</item>
      <item>Add the title for the table of contents</item>
      <item>For each section element that is a child of root create these elements</item>
      <olist>
        <item>The `li` element</item>
        <item>The a element with the corresponding href element</item>
        <item>The value of the href element (a concatenation of the section's type attribute, the position within the document and the .html string)</item>
        <item>The title of the section as the 'clickable' portion of the link</item>
      </olist>
    </olist>

    <code language="xml">&lt;xsl:template match="/" mode="toc">
&lt;section data-type="toc"> (1)
&lt;nav class="toc"> (1)
&lt;h2>Table of Contents&lt;/h2>
&lt;ol>
&lt;xsl:for-each select="book/section">
&lt;xsl:element name="li"> (3.1)
&lt;xsl:element name="a"> (3.2)
&lt;xsl:attribute name="href"> (3.2)
&lt;xsl:value-of select="concat((@type), position(),'.html')"/> (3.3)
&lt;/xsl:attribute>
&lt;xsl:value-of select="title"/> (3.4)
&lt;/xsl:element>
&lt;/xsl:element>
&lt;/xsl:for-each>
&lt;/ol>
&lt;/nav>
&lt;/section>
&lt;/xsl:template></code>


<h2>Metadata and Section</h2>

<para>With these templates in place we can now start writing the major areas of the document, <emphasis>metadata</emphasis> and <emphasis>section</emphasis>.</para>

<h3>Metadata</h3>

<para>The metadata is a container for all the elements inside. As such we just create the div that will hold the content and call `xsl:apply-templates` to process the children inside the metadata element using the apply-template XSLT instruction. The template looks like this</para>

<code language='xml'>
&lt;xsl:template match="metadata">
  &lt;xsl:element name="div">
    &lt;xsl:attribute name="class">metadata&lt;/xsl:attribute>
    &lt;xsl:apply-templates/>
  &lt;/xsl:element>
&lt;/xsl:template>
</code>

<h3>Section</h3>

<para>The section container on the other hand is a lot more complex because it has a lot of work to do. It is our primary unit for generating files, takes most of the same attributes as the root template and then processes the rest of the content.</para>

<para>Inside the template we first create a vairable to hold the name of the file we'll generate. The file name is a concatenation of the following elements:</para>

<ulist>
  <item>The type attribute</item>
  <item>The position in the document</item>
  <item>the string "html"</item>
</ulist>

<para>The result-document element takes two parameters: the value of the file name variable we just defined and the xhtml-out format we defined at the top of the document. The XHTML format may look like overkill right now but it makes sense when we consider moving the generated content to ePub or other fomats where strict XHTML conformance is a requirement.</para>

<para>We start generating the skeleton of the page, we add the default style sheet and  do the first conditional test of the document. Don't want to add stylesheets to the page unless they are needed so we test if there is a code element on the page and only add highlight.js related stylesheets and scripts. </para>

<para>In the body element we see the first of many times we'll conditionally add attributes to the element. We use only add a data-type attribute to body if there is a type attribute in the source document. We do the same thing for id and class.</para>

<code language='xml'>
&lt;xsl:template match="section">
  &lt;!-- Variable to create section file names -->
  &lt;xsl:variable name="fileName" select="concat((@type), (position()-1),'.html')"/>
  &lt;!-- An example result of the variable above would be introduction1.xhtml -->
  &lt;xsl:result-document href='{$fileName}' format="xhtml-out">
    &lt;html>
      &lt;head>
        &lt;link rel="stylesheet" href="css/style.css" />
        &lt;xsl:if test="(code)">
          &lt;!--
            Use highlight.js and github style
          -->
          &lt;link rel="stylesheet" href="css/styles/docco.css" />
          &lt;!-- Load highlight.js -->
          &lt;script src="lib/highlight.pack.js">&lt;/script>
          &lt;script>
            hljs.initHighlightingOnLoad();
          &lt;/script>
        &lt;/xsl:if>
        &lt;!--
          Comment this out for now. It'll become relevant when we add video
          &lt;script src="js/script.js">&lt;/script>
        -->
      &lt;/head>
      &lt;body>
        &lt;section>
          &lt;xsl:if test="@type">
            &lt;xsl:attribute name="data-type">
              &lt;xsl:value-of select="@type"/>
            &lt;/xsl:attribute>
          &lt;/xsl:if>
          &lt;xsl:if test="(@class)">
            &lt;xsl:attribute name="class">
              &lt;xsl:value-of select="@class"/>
            &lt;/xsl:attribute>
          &lt;/xsl:if>
          &lt;xsl:if test="(@id)">
            &lt;xsl:attribute name="id">
              &lt;xsl:value-of select="@id"/>
            &lt;/xsl:attribute>
          &lt;/xsl:if>
          &lt;xsl:apply-templates/>
        &lt;/section>
      &lt;/body>
    &lt;/html>
  &lt;/xsl:result-document>
&lt;/xsl:template>
</code>

<h2>Metadata content</h2>

<h3>Publication information</h3>

<code language='xml'>
&lt;xsl:template match="isbn">
  &lt;p>ISBN: &lt;xsl:value-of select="."/>&lt;/p>
&lt;/xsl:template>
</code>

<code language='xml'>
&lt;xsl:template match="edition">
  &lt;p class="no-margin-left">Edition: &lt;xsl:value-of select="."/>&lt;/p>
&lt;/xsl:template>
</code>

<h3>Individuals</h3>

<code language='xml'>
&lt;!-- complex types to create groups of similar person items -->
&lt;xs:complexType name="person">
    &lt;xs:annotation>
        &lt;xs:documentation>
            Generic element to denote an individual involved in creating the book
        &lt;/xs:documentation>
    &lt;/xs:annotation>
    &lt;xs:sequence>
        &lt;xs:element name="first-name" type="xs:token"/>
        &lt;xs:element name="surname" type="xs:token"/>
    &lt;/xs:sequence>
    &lt;xs:attribute name="id" type="xs:ID" use="optional"/>
&lt;/xs:complexType>

&lt;xs:complexType name="author">
    &lt;xs:annotation>
        &lt;xs:documentation>
            Author person
        &lt;/xs:documentation>
    &lt;/xs:annotation>
    &lt;xs:complexContent>
        &lt;xs:extension base="person">
        &lt;/xs:extension>
    &lt;/xs:complexContent>
&lt;/xs:complexType>

&lt;xs:complexType name="editor">
    &lt;xs:annotation>
        &lt;xs:documentation>extension to person to indicate editor and his/her role&lt;/xs:documentation>
    &lt;/xs:annotation>
    &lt;xs:complexContent>
        &lt;xs:extension base="person">
            &lt;xs:choice>
                &lt;xs:element name="type" type="xs:token"/>
            &lt;/xs:choice>
        &lt;/xs:extension>
    &lt;/xs:complexContent>
&lt;/xs:complexType>

&lt;xs:complexType name="otherRole">
    &lt;xs:annotation>
        &lt;xs:documentation>extension to person to accomodate roles other than author and editor&lt;/xs:documentation>
    &lt;/xs:annotation>
    &lt;xs:complexContent>
        &lt;xs:extension base="person">
            &lt;xs:sequence minOccurs="1" maxOccurs="1">
                &lt;xs:element name="role" type="xs:token"/>
            &lt;/xs:sequence>
        &lt;/xs:extension>
    &lt;/xs:complexContent>
&lt;/xs:complexType>
</code>

<h3>People groups</h3>

<code language='xml'>
&lt;xsl:template match="metadata/authors">
  &lt;h2>Authors&lt;/h2>
  &lt;ul>
    &lt;xsl:for-each select="author">
      &lt;li>
        &lt;xsl:value-of select="first-name"/>
        &lt;xsl:text> &lt;/xsl:text>
        &lt;xsl:value-of select="surname"/>
      &lt;/li>
    &lt;/xsl:for-each>
  &lt;/ul>
&lt;/xsl:template>

&lt;xsl:template match="metadata/editors">
  &lt;h2>Editorial Team&lt;/h2>
  &lt;ul class="no-bullet">
    &lt;xsl:for-each select="editor">
      &lt;li>
        &lt;xsl:value-of select="first-name"/>
        &lt;xsl:text> &lt;/xsl:text>
        &lt;xsl:value-of select="surname"/>
        &lt;xsl:value-of select="concat(' - ', type, ' ', 'editor')">&lt;/xsl:value-of>
      &lt;/li>
    &lt;/xsl:for-each>
  &lt;/ul>
&lt;/xsl:template>

&lt;xsl:template match="metadata/otherRoles">
  &lt;h2>Production team&lt;/h2>
  &lt;ul class="no-bullet">
    &lt;xsl:for-each select="otherRole">
      &lt;li>
        &lt;xsl:value-of select="first-name" />
        &lt;xsl:text> &lt;/xsl:text>
        &lt;xsl:value-of select="surname" />
        &lt;xsl:text> - &lt;/xsl:text>
        &lt;xsl:value-of select="role" />
      &lt;/li>
    &lt;/xsl:for-each>
  &lt;/ul>
&lt;/xsl:template>
</code>

<h2>Titles and headings</h2>

<para>Titles and headings use mostly the same code. We've put them in separate templates to make it possible and easier to generate different code for each heading. It's not the same as using CSS where you can declare rules for the same attribute multiple times (with the last one winning); when writing transformations you can only have one per element otherwise you will get an error.</para>

<para>The goal is to create as simple a markup as we can so we can better leverage CSS to style and make our content display as intended.</para>

<code language="xml">&lt;xsl:template match="title ">
  &lt;xsl:element name="h1">
    &lt;xsl:if test="@align">
      &lt;xsl:attribute name="align">
        &lt;xsl:value-of select="@align"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:value-of select="."/>
  &lt;/xsl:element>
&lt;/xsl:template>

&lt;xsl:template match="h1">
  &lt;xsl:element name="h1">
    &lt;xsl:if test="@align">
      &lt;xsl:attribute name="align">
        &lt;xsl:value-of select="@align"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:value-of select="."/>
  &lt;/xsl:element>
&lt;/xsl:template></code>

<h2>Blockquotes, quotes and asides</h2>

<code language="xml">&lt;xsl:template match="blockquote">
  &lt;xsl:element name="blockquote">
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:apply-templates />
  &lt;/xsl:element>
&lt;/xsl:template>

&lt;!-- BLOCKQUOTE ATTRIBUTION-->
&lt;xsl:template match="attribution">
  &lt;xsl:element name="cite">
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:apply-templates/>
  &lt;/xsl:element>
&lt;/xsl:template>
</code>

<code language='xml'>
&lt;xsl:template match="quote">
  &lt;q>&lt;xsl:value-of select="."/>&lt;/q>
&lt;/xsl:template></code>


<code language="xml">&lt;xsl:template match="aside">
  &lt;aside>
    &lt;xsl:if test="type">
      &lt;xsl:attribute name="data-type">
        &lt;xsl:value-of select="@align"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:apply-templates/>
  &lt;/aside>
&lt;/xsl:template>
</code>

<h2>Div and Span</h2>

<code language="xml">&lt;xsl:template match="div">
  &lt;xsl:element name="div">
    &lt;xsl:if test="@align">
      &lt;xsl:attribute name="align">
        &lt;xsl:value-of select="@align"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:apply-templates/>
  &lt;/xsl:element>
&lt;/xsl:template></code>

<code language="xml">&lt;xsl:template match="span">
  &lt;xsl:element name="span">
    &lt;xsl:if test="@type">
      &lt;xsl:attribute name="data-type">
        &lt;xsl:value-of select="@type"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:value-of select="."/>
  &lt;/xsl:element>
&lt;/xsl:template></code>

<h2>Paragraphs</h2>

<code language="xml">&lt;xsl:template match="para">
  &lt;xsl:element name="p">
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:apply-templates/>
  &lt;/xsl:element>
&lt;/xsl:template></code>

<h2>Styles</h2>

<code language="xml">&lt;xsl:template match="strong">
  &lt;strong>&lt;xsl:apply-templates />&lt;/strong>
&lt;/xsl:template>

&lt;xsl:template match="emphasis">
  &lt;em>&lt;xsl:apply-templates/>&lt;/em>
&lt;/xsl:template>

&lt;xsl:template match="strike">
  &lt;strike>&lt;xsl:apply-templates/>&lt;/strike>
&lt;/xsl:template>

&lt;xsl:template match="underline">
  &lt;u>&lt;xsl:apply-templates/>&lt;/u>
&lt;/xsl:template>
</code>

<h2>Links and anchors</h2>

<para>One of the</para>

<code language="xml">&lt;xsl:template match="link">
  &lt;xsl:element name="a">
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:attribute name="href">
      &lt;xsl:value-of select="@href"/>
    &lt;/xsl:attribute>
    &lt;xsl:attribute name="label">
      &lt;xsl:value-of select="@label"/>
    &lt;/xsl:attribute>
    &lt;xsl:value-of select="@label"/>
  &lt;/xsl:element>
&lt;/xsl:template></code>

<para>When working with links there are times when we want to link to sections within the same document or to specific sections in another document. To do this we need anchors that will resolve to the following HTML:</para>

<code language="html">&lt;a name="target">&lt;a></code>

<para>The transformation element looks like this:</para>

<code language="xml">&lt;xsl:template match="anchor">
  &lt;xsl:element name="a">
    &lt;xsl:attribute name="name">
    &lt;/xsl:attribute>
  &lt;/xsl:element>
&lt;/xsl:template>
</code>

<para>Not sure if I want to make this an empty element or not</para>

<para>Empty element &lt;anchor name="home"/> appeals to my ease of use paradigm but it may not be as easy to understand for peope who are not familiar with XML empty elements</para>

<h2>Code blocks</h2>

    <para>Code elements create <link href="https://help.github.com/articles/github-flavored-markdown/#fenced-code-blocks" label="fenced code blocks"/> like the ones from <link href="https://help.github.com/articles/github-flavored-markdown/" label="Github Flavored Markdown"/>. </para>

    <para>We use <link href="https://www.google.com/fonts/specimen/Source+Code+Pro" label="Adobe Source Code Pro"/> font. It's a clean and readable font designed specifically for source code display.</para>

    <para>We highlight our code with <link href="https://highlightjs.org/" label="Highlight.js"/>.</para>

<blockquote>
  <para>Note that the syntax higlighting only works for HTML. Although PrinceXML supports Highlight.js it is not working. I've asked on the Prince support forums and am waiting for an answer.</para>
</blockquote>

<code language="xml">&lt;xsl:template match="code">
  &lt;xsl:element name="pre">
    &lt;xsl:element name="code">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@language"/>
      &lt;/xsl:attribute>
      &lt;xsl:value-of select="."/>
    &lt;/xsl:element>
  &lt;/xsl:element>
&lt;/xsl:template>
</code>

<h2>Lists and list items</h2>

<para>When I first conceptualized this project I had designed a single list element and attributes to produce bulleted and numbered lists. This proved to difficult to implement so I went back to two separate elements: `ulist` for bulleted lists and `olist` for  numbered lists.</para>

<para>Both elements share the <emphasis>item</emphasis> element to indicates the items inside the list. At least one item is required a list.</para>

<code language="xml">
&lt;xsl:template match="ulist">
  &lt;xsl:element name="ul">
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:apply-templates/>
  &lt;/xsl:element>
&lt;/xsl:template>

&lt;xsl:template match="olist">
  &lt;xsl:element name="ol">
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:apply-templates/>
  &lt;/xsl:element>
&lt;/xsl:template>

&lt;xsl:template match="item">
  &lt;xsl:element name="li">
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:value-of select="."/>
  &lt;/xsl:element>
&lt;/xsl:template>
</code>

<h2>Figures and Images</h2>

<para>Figures, captions and the images inside present a few challenges. Because we allow authors to set height and width on both figure and the imageg inside we may find situations where the figure container is narrower than the image inside.</para>

<para>To avoid this issue we test whether the figure width value is smaller than the width of the image inside. If it is, we use the width of the image as the width of the figure, ootherwise we use the width of the image inside.</para>

<para>We didn't do the same thing for the height. It may be changed in a future iteration. </para>

<para>The data model for our content allows both figures and images to be used in the document. This is so we don't have to insert empty captions to figures just so we can add an image... If we don't want a caption we can insert the image directly on our document.</para>

<code language='xml'>
&lt;xsl:template match="figure">
  &lt;xsl:element name="figure">
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;!--
      If the width of the figure is smaller than the width of the containing image
      we may have display problems.

      If the width of the containging figure is smaller than the width of the image,
      make the figure width equal to the width of hthe image, otherwise use the width
      of the figure element
    -->
    &lt;xsl:choose>
      &lt;xsl:when test="@width lt image/@width">
        &lt;xsl:attribute name="width">
          &lt;xsl:value-of select="@width"/>
        &lt;/xsl:attribute>
      &lt;/xsl:when>
      &lt;xsl:otherwise>
        &lt;xsl:attribute name="width">
          &lt;xsl:value-of select="image/@width"/>
        &lt;/xsl:attribute>
      &lt;/xsl:otherwise>
    &lt;/xsl:choose>
    &lt;!--
      We don't care about height as much as we do width, the caption
      and image are contained inside the figure.

      We only test if it exists. It's up to the author to make sure
      there are no conflicts
    -->
    &lt;xsl:if test="(@height)">
      &lt;xsl:attribute name="height">
        &lt;xsl:value-of select="@height"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;!--
      Alignment can be different. We can have a centered image inside a
      left aligned figure
    -->
    &lt;xsl:if test="(@align)">
      &lt;xsl:attribute name="align">
        &lt;xsl:value-of select="@align"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:apply-templates select="image"/>
    &lt;xsl:apply-templates select="figcaption"/>
  &lt;/xsl:element>
&lt;/xsl:template>

&lt;xsl:template match="figcaption">
  &lt;figcaption>&lt;xsl:apply-templates/>&lt;/figcaption>
&lt;/xsl:template>

&lt;xsl:template match="image">
  &lt;xsl:element name="img">
    &lt;xsl:attribute name="src">
      &lt;xsl:value-of select="@src"/>
    &lt;/xsl:attribute>
    &lt;xsl:attribute name="alt">
      &lt;xsl:value-of select="@alt"/>
    &lt;/xsl:attribute>
    &lt;xsl:if test="(@width)">
      &lt;xsl:attribute name="width">
        &lt;xsl:value-of select="@width"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@height)">
      &lt;xsl:attribute name="height">
        &lt;xsl:value-of select="@height"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@align)">
      &lt;xsl:attribute name="align">
        &lt;xsl:value-of select="@align"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class">
        &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id">
        &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute>
    &lt;/xsl:if>
  &lt;/xsl:element>
&lt;/xsl:template>
</code>
</section>

  <section type="chapter">
    <title>From XML to PDF: Part 1: Special Transformation</title>

    <para>Rather than having to deal with [XSL-FO](http://www.w3.org/TR/2006/REC-xsl11-20061205/), another XML based vocabulary to create PDF content, we'll use XSLT to create another HTML file and process it with [CSS Paged Media](http://dev.w3.org/csswg/css-page-3/) and the companion [Generated Content for Paged Media](http://www.w3.org/TR/css-gcpm-3/) specifications to create PDF content. </para>

    <para>I'm not against XSL-FO but the structure of document is not the easiest or most intuitive. An example of XSL-FO looks like this:</para>

<code language="xml">&lt;?xml version="1.0" encoding="iso-8859-1"?> (1)

    &lt;fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format"> (2)
    &lt;fo:layout-master-set> (3)
    &lt;fo:simple-page-master master-name="my-page">
    &lt;fo:region-body margin="1in"/>
    &lt;/fo:simple-page-master>
    &lt;/fo:layout-master-set>

    &lt;fo:page-sequence master-reference="my-page"> (4)
    &lt;fo:flow flow-name="xsl-region-body"> (5)
    &lt;fo:block>Hello, world!&lt;/fo:block> (6)
    &lt;/fo:flow>
    &lt;/fo:page-sequence>
    &lt;/fo:root></code>

    <olist>
      <item>This is an XML declaration. XSL FO (XSLFO) belongs to XML family, so this is obligatory.</item>
      <item>Root element. The obligatory namespace attribute declares the XSL Formatting Objects namespace.</item>
      <item>Layout master set. This element contains one or more declarations of page masters and page sequence masters  elements that define layouts of single pages and page sequences. In the example, I have defined a rudimentary page master, with only one area in it. The area should have a 1 inch margin from all sides of the page.</item>
      <item>Page sequence. Pages in the document are grouped into sequences; each sequence starts from a new page. Master-reference attribute selects an appropriate layout scheme from masters listed inside `&lt;fo:layout-master-set>`. Setting master-reference to a page master name means that all pages in this sequence will be formatted using this page master.</item>
      <item>Flow. This is the container object for all user text in the document. Everything contained in the flow will be formatted into regions on pages generated inside the page sequence. Flow name links the flow to a specific region on the page (defined in the page master); in our example, it is the body region.</item>
      <item>Block. This object roughly corresponds to `&lt;div>` in HTML, and normally includes a paragraph of text. I need it here, because text cannot be placed directly into a flow.</item>
    </olist>

    <para>Rather than define a flow of content and then the content CSS Paged Media uses a combination of new and existing CSS elements to format the content. For example, to define default page size and then add elements to chapter pages looks like this:</para>

<code language="ccss">@page {
    size: 8.5in 11in;
    margin: 0.5in 1in;
    /* Footnote related attributes */
    counter-reset: footnote;
    @footnote {
    counter-increment: footnote;
    float: bottom;
    column-span: all;
    height: auto;
    }
    }

    @page chapter {
    @bottom-center {
    vertical-align: middle;
    text-align: center;
    content: element(heading);
    }
    }</code>

    <para>The only problem with the code above is that there is no native broser support. For our demonstration we'll use Prince XML to tanslate our HTML/CSS file to PDF. In the not so distant future we will be able to do this transformation in the browser and print the PDF directly. Until then it's a two step process: Modifying the HTML we get from the XML file and running the HTML through Prince to get the PDF.</para>

    <h2>Modifying the HTML results</h2>

    <para>We'll use this opportunity to create an xslt customization layer to make changes only to the templates where we need to.</para>

    <para>We create a customization layer by importing the original stylesheet and making any necessary changes in the new stylesheet. Imported stylesheets have a lower precedence order than the local version so the local version will win if there is conflict.</para>

    <para>In this particular situation we want to:</para>

    <ulist>
      <item>Add the data-type=book attribute to the body of the document</item>
      <item>Convert the multiple file book into a single file by eliminating the result-document element</item>
      <item>Remove filename variable. It's not needed</item>
      <item>Change the test for type attribute so it'll terminate if it fails (type attribute is required for our implementation of the Paged Media style sheet)</item>
      <item>Add the element that will build our running footer (p class="rh" with the same value as the chapter title)</item>
      <item>Remove the toc mode apply-template call from the book template. It's not needed, we may move it to a separate template for navigation</item>
      <item>Rework the metadata template so it'll match the spec on the CSS  (it's a section with data-type = title page)</item>
      <item>Insert a link to the paged media CSS style sheet in the head of the document to make the Prince command easier (and so I won't forget it during testing and development)</item>
    </ulist>

    <para>Only the templates defined in this stilesheet are overriden</para>

    <para>The style sheet is shown below (with large comments removed)</para>

<code language="xml">&lt;?xml version="1.0" encoding="UTF-8"?>
    &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    exclude-result-prefixes="xs"
    version="2.0">
    &lt;!--
    XSLT Paged Media Customization Layer

    Makes the necessary changes to the content to work with the Paged Media CSS stylesheet
    -->
    &lt;!-- First import the base stylesheet -->
    &lt;xsl:import href="book.xsl"/>

    &lt;!-- Define the output for this and all document children -->
    &lt;xsl:output name="xhtml-out" method="xhtml"
    indent="yes" encoding="UTF-8" omit-xml-declaration="yes" />

    &lt;xsl:template match="book">
    &lt;html>
    &lt;head>
    &lt;xsl:element name="title">
    &lt;xsl:value-of select="metadata/title"/>
    &lt;/xsl:element>
    &lt;link rel="stylesheet" href="css/pm-style.css" />
    &lt;!-- Just so I won't forget it again -->
    &lt;link rel="stylesheet" href="css/paged-media.css"/>
    &lt;!--
    Use highlight.js and docco style
    -->
    &lt;link rel="stylesheet" href="css/styles/docco.css" />
    &lt;!-- Load highlight.js -->
    &lt;script src="lib/highlight.pack.js">&lt;/script>
    &lt;script>
    hljs.initHighlightingOnLoad();
    &lt;/script>
    &lt;script src="js/script.js">&lt;/script>
    &lt;/head>

    &lt;body>
    &lt;xsl:attribute name="data-type">book&lt;/xsl:attribute>
    &lt;xsl:element name="meta">
    &lt;xsl:attribute name="generator">
    &lt;xsl:value-of select="system-property('xsl:product-name')"/>
    &lt;xsl:value-of select="system-property('xsl:product-version')"/>
    &lt;/xsl:attribute>
    &lt;/xsl:element>
    &lt;xsl:element name="meta">
    &lt;xsl:attribute name="vendor">
    &lt;xsl:value-of select="system-property('xsl:vendor')" />
    &lt;/xsl:attribute>
    &lt;/xsl:element>
    &lt;xsl:element name="meta">
    &lt;xsl:attribute name="vendor-URL">
    &lt;xsl:value-of select="system-property('xsl:vendor-url')" />
    &lt;/xsl:attribute>
    &lt;/xsl:element>
    &lt;xsl:apply-templates/>
    &lt;/body>
    &lt;/html>
    &lt;/xsl:template>

    &lt;xsl:template match="book/section">
    &lt;section>
    &lt;xsl:choose>
    &lt;xsl:when test="@type">
    &lt;xsl:attribute name="data-type">
    &lt;xsl:value-of select="@type"/>
    &lt;/xsl:attribute>
    &lt;/xsl:when>
    &lt;xsl:otherwise>
    &lt;xsl:message terminate="yes">
    Type attribute is required for paged media
    &lt;/xsl:message>
    &lt;/xsl:otherwise>
    &lt;/xsl:choose>
    &lt;xsl:if test="(@class)">
    &lt;xsl:attribute name="class">
    &lt;xsl:value-of select="@class"/>
    &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:if test="(@id)">
    &lt;xsl:attribute name="id">
    &lt;xsl:value-of select="@id"/>
    &lt;/xsl:attribute>
    &lt;/xsl:if>
    &lt;xsl:element name="p">
    &lt;xsl:attribute name="class">rh&lt;/xsl:attribute>
    &lt;xsl:value-of select="title"/>
    &lt;/xsl:element>
    &lt;xsl:apply-templates/>
    &lt;/section>
    &lt;/xsl:template>

    &lt;!-- Metadata -->
    &lt;xsl:template match="metadata">
    &lt;xsl:element name="section">
    &lt;xsl:attribute name="data-type">titlepage&lt;/xsl:attribute>
    &lt;xsl:apply-templates/>
    &lt;/xsl:element>
    &lt;/xsl:template>

    &lt;xsl:template match="book" mode="toc"/>
    &lt;/xsl:stylesheet>
</code>
  </section>

  <section type="chapter">
    <title>From XML to PDF. Part 2: CSS Paged Media</title>

    <para>This stylesheets sets up a printed stylesheet with a basic set of parameters. It is meant as a starting point for printed media work.</para>

  </section>

  <section type="chapter">
    <title>Task Automation with Grunt</title>

    <figure>
      <anchor/>
      <image src="images/grund-js-opt.png" height="276" width="504" alt="Grunt"/>
      <figcaption>Grunt.js, a Javascript task runner</figcaption>
    </figure>

    <para><link href="http://gruntjs.com/" label="Grunt.js"/> is a task runner written in Javascript. </para>

    <code language="javascript">
/*global module */
/*global require */
(function () {
'use strict';
module.exports = function (grunt) {
// require it at the top and pass in the grunt instance
// it will measure how long things take
require('time-grunt')(grunt);

// load-grunt will read the package file and automatically
// load all our packages configured there.
// Yay for laziness
require('load-grunt-tasks')(grunt);

grunt.initConfig({
    </code>
    <code language="javascript">
// JAVASCRIPT TASKS
// Hint the grunt file and all files under js/
// and one directory below
jshint: {
  files: ['Gruntfile.js', 'js/{,*/}*.js'],
  options: {
    reporter: require('jshint-stylish')
    // options here to override JSHint defaults
  }
},

// Takes all the files under js/ and selected files under lib
// and concatenates them together. I've chosen not to mangle
// the compressed file
uglify: {
  dist: {
    options: {
      mangle: false,
      sourceMap: true,
    sourceMapName: 'css/script.min.map'
    },
    files: {
      'js/script.min.js': ['js/video.js', 'lib/highlight.pack.js']
    }
  }
},

jscs: {
  options: {
    'standard': 'Idiomatic'
  },
  all: ['js/']
},
    </code>
    <code language="javascript">
// SASS RELATED FILES
// Converts all the files under scss/ ending with .scss
// into the equivalent css file on the css/ directory
sass: {
  dev: {
    options: {
      style: 'expanded'
    },
    files: [{
      expand: true,
      cwd: 'scss',
      src: ['*.scss'],
      dest: 'css',
      ext: '.css'
    }]
  },
  production: {
    options: {
      style: 'compact'
    },
    files: [{
      expand: true,
      cwd: 'scss',
      src: ['*.scss'],
      dest: 'css',
      ext: '.css'
    }]
  }
},

// This task requires the scss-lint ruby gem to be installed on your system
// If you choose not to install it, comment out this task and the prep-css
// and work-lint tasks below
//
// I've chosen not to fail on errors or warnings.
scsslint: {
  allFiles: [
    'scss/*.scss',
    'scss/modules/_mixins.scss',
    'scss/modules/_variables.scss',
    'scss/partials/*.scss'
  ],
  options: {
    config: '.scss-lint.yml',
    force: true,
    colorizeOutput: true
  }
},
    </code>
<code language="javascript">
autoprefixer: {
  options: {
    browsers: ['last 2']
  },

  files: {
    expand: true,
    flatten: true,
    src: 'scss/*.scss',
    dest: 'css/'
  }
},

// CSS TASKS TO RUN AFTER CONVERSION
// Cleans the CSS based on what's used in the specified files
// See https://github.com/addyosmani/grunt-uncss for more
// information
uncss: {
  dist: {
    files: {
      'css/tidy.css': ['*.html', '!docs.html']
    }
  }
},
</code>
<code language="javascript">
// FILE MANAGEMENT
// Can't seem to make the copy task create the directory
// if it doesn't exist so we go to another task to create
// the fn directory
mkdir: {
  build: {
    options: {
      create: ['build']
    }
  }
},

// Copy the files from our repository into the build directory
copy: {
  build: {
    files: [{
      expand: true,
      src: ['app/**/*'],
      dest: 'build/'
    }]
  }
},

// Clean the build directory
clean: {
  production: ['build/']
},
</code>
<code language="javascript">
// GH-PAGES TASK
// Push the specified content into the repositories gh-pages branch
'gh-pages': {
  options: {
    message: 'Content committed from Grunt gh-pages',
    base: './build/app',
    dotfiles: true
  },
  // These files will get pushed to the `
  // gh-pages` branch (the default)
  // We have to specifically remove node_modules
  src: ['**/*']
},
</code>
<code language="javascript">
// WATCH TASK
// Watch for changes on the js and scss files and perform
// the specified task
watch: {
  options: {
    nospawn: true
  },
  // Watch all javascript files and hint them
  js: {
    files: ['Gruntfile.js', 'js/{,*/}*.js'],
    tasks: ['jshint']
  },
  sass: {
    files: ['scss/*.scss'],
    tasks: ['sass']
  }
},
</code>
<code language="javascript">
// COMPILE AND EXECUTE TASKS
// rather than using Ant, I've settled on Grunt's shell
// task to run the compilation steps to create HTML and PDF.
// This reduces teh number of dependecies for our project
shell: {
  options: {
    failOnError: true,
    stderr: false
  },
  html: {
    command: 'java -jar /usr/local/java/saxon.jar -xsl:xslt/book.xsl \
    docs.xml -o:index.html'
  },
  single: {
    command: 'java -jar /usr/local/java/saxon.jar -xsl:xslt/pm-book.xsl \
    docs.xml -o:docs.html'
  },
  prince: {
    command: 'prince --verbose --javascript docs.html -o docs.pdf'
  }
}


}); // closes initConfig
</code>
<code language="javascript">
// CUSTOM TASKS
// Usually a combination of one or more tasks defined above
grunt.task.registerTask(
  'lint',
  [
    'scsslint',
    'jshint'
  ]
);

// Prep CSS starting with SASS, autoprefix et. al
grunt.task.registerTask(
  'prep-css',
  [
    'scsslint',
    'sass:dev',
    'autoprefixer'
  ]
);

grunt.task.registerTask(
  'prep-js',
  [
    'jshint',
    'uglify'
  ]
);

// This task should run last, after all the other tasks are completed
grunt.task.registerTask(
  'generate-pdf',
  [
    'shell:single',
    'shell:prince'
  ]
);

grunt.task.registerTask(
  'generate-all',
  [
    'shell'
  ]
);


}; // closes module.exports
}()); // closes the use strict function
    </code>
  </section>

  <section type="chapter">
    <title>Things to Do and Further Research</title>

    <para>These are the things I want to look at after finishing mvp.</para>

    <h2>Deep Linking using Emphasis</h2>

    <para>The NYT developed a deep linking library called Emphasis (<link href="https://github.com/NYTimes/Emphasis" label="code"/> - <link href="http://open.blogs.nytimes.com/2011/01/11/emphasis-update-and-source/" label="writeup"/> that would allow us to create links to specific areas of our content.</para>

    <para>Downside is that it uses jQuery and I'm not certain I want to go through the pain in the ass process of converting it to plain JS or ES6 (and if it's even possible)</para>

    <para>Still, if we use jQuery for something else (video manipulation?) it may be worth exploring both as a sharing tool and as a technology.</para>

    <para>One thing it doesn't do is handle mobile well, if at all. How do we make this tool work everywhere? <link href="http://www.w3.org/TR/pointerevents/" label="Pointer Events"/>?</para>

    <h2>Explore how to add other parts of a book structure</h2>

    <para>Right now we're working with chapters and chapter-like structures. What would it take to add parts? Do we need to add them to the schema and let them trickle from there? Do we really need them?</para>

    <h2>Build Media Queries</h2>

    <para>Particularly if we want to use the same XSLT and CSS for mutliple projects we need to be able to tailor the display for different devices and viewports.</para>

    <para>Media Queries are the best solution (or are they?)</para>

    <h2>Using XSLT to build navigation</h2>

    <para>The same way we build the table of content should allow us to build navigation within the pages of a publication using preceeding-sibling and following-sibling logic</para>

    <h2>Create a better way to generate filenames</h2>

    <para>The current way to create filenames doesn't take into account that different <emphasis>section/@type</emphasis> elements have different starting values. Can I make it start from 1 for every @type in the document?</para>

    <h2>Expand the use cases for this project</h2>

    <para>The original idea was for text and code-heavy content. Is there a case to be made for a more expressive vocabulary? I'm thinking of additional elements for navigation and content display such as asides and blockquotes</para>

    <h2>Explore implementing a serviceworker solution</h2>

    <video controls='conrtrols' width='640' height='360'>
      <source src='video/serviceworker.mp4' type='video/mp4'/>
    </video>

    <para>The core of the proposed offline capabilities is a scoped service worker that will initially handle the caching of the publication's content. We take advantage of the multiple cache capabilitity available with service workers to create caches for individual unitts of content (like magazine issues) and to expire them within a certain time period (by removing and deleting the cache).</para>

    <para>For publications needing to pull data from specific URLs we can special case the requests based on different pieces of the URL allowing to create different caches based on edition (assuming each edition is stored in its own directory), resource type or even the URL we are requesting.</para>

    <para>Serviceworkers have another benefit not directly related with offline connections. They will give all access to our content a speed boost by eliminating the network roundtrip after the content is installed. If the content is in the cache, the resource's time to load is only limited by the Hard Drive's speed.</para>

    <h3>Limitations</h3>

    <para>As powerful as service workers are they also have some drawbacks. They can only be served through HTTPS (you cannot install a service worker in a non secure server) to prevent <link href="http://www.wikiwand.com/en/Man-in-the-middle_attack" label="man-in-the-middle attacks"/>.</para>

    <para>There is limited support for the API (only Chrome Canary and  Firefox Nightly builds behind a flag will work.) This will change as the API matures and becomes finalized in the WHATWG and/or a recommendation with the W3C.</para>

    <para>Even in browsers that support the API the support is not complete. Chrome uses a polyfill for elements of the cache API that it does not support natively. This should be fixed in upcoming versions of Chrome and Chromium (the open source project Chrome is based on.)</para>

    <para>We need to be careful with how much data we choose to store in the caches. From what I understand the ammount of storage given to offline applications is divided between all offline storage types: IndexedDB, Session Storage, Web Workers and ServiceWorkers and this amount is not consistent across all browsers.</para>

    <para>Furthermore I am not aware of any way to increase this total amount or to specifically increase the storage assigned to ServiceWorkers; Jake Archibald mentions this in the offline cookbook section on <link href="http://jakearchibald.com/2014/offline-cookbook/#cache-persistence" label="cache persistence"/></para>

    <h2>Implementing Graphic Callouts</h2>

    <para>What would it take to get callouts to use graphics like Docbook?</para>

    <para>It would take the following:</para>

    <ulist>
      <item>Create a new element (callout)</item>
      <item>Add the callout element to the code data model</item>
    </ulist>

    <para>This would work for code, but not necessarily for images or other elements that need callouts</para>
  </section>

  <section type="bibliography">
    <title>Annotated Bibliography</title>

    <para>For more information, see: <link href="http://alistapart.com/article/building-books-with-css3" label="Building books with css3"/></para>

    <para>For another example, see: <link href="https://github.com/oreillymedia/HTMLBook/blob/master/stylesheets/pdf/pdf.css" label="HTMLbook stylesheet to generate pdf"/> which is the basis for this project.</para>

    <para>For the W3C specifications: <link href="http://www.w3.org/TR/css3-page/" label="Paged Media level 3"/> and <link href="http://www.w3.org/TR/css-gcpm-3/" label="Generated Content for Paged Media"/></para>

    <para><link href="http://antennahouse.com/XSLsample/help/V62/AHFormatterV62.en.pdf" label="Antenna House Formatter Onine Manual"/></para>

    <para><link href="http://www.princexml.com/doc/9.0/" label="Prince XML User Guide"/></para>
  </section>

</book>
