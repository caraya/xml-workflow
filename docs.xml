<?xml version="1.0" encoding="UTF-8" ?>
<book xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="xsd/book-schema-draft.xsd">
  <metadata>
    <title>XML workflow documentation</title>

    <authors>
      <author>
        <first-name>Carlos</first-name>
        <surname>Araya</surname>
      </author>
    </authors>
  </metadata>

  <section type="dedication">
    <title>Thank You</title>
    <para>Thanks to Laura Brady for getting this particular idea started :)
    </para>
  </section>

  <section type="preface">
    <title>Background: HTML is the final format</title>
    <para>In researching the technologies and tools that I use when developing digital content I've come across multiple discussions about what's the best way to create HTML for X application (ebooks, web, transforming into other formats and any number of ideas. Some people think that HTML is perfect for everyone to write, regardless of experience and comfort with the technology. We forget that HTML now is very different to HTML as it was originally created.</para>
    <blockquote>
      <para>HTML —which is short for HyperText Markup Language— is the official language of the World Wide Web and was first conceived in 1990. HTML is a product of SGML (Standard Generalized Markup Language) which is a complex, technical specification describing markup languages, especially those used in electronic document exchange, document management, and document publishing. HTML was originally created to allow those who were not specialized in SGML to publish and exchange scientific and other technical documents. HTML especially facilitated this exchange by incorporating the ability to link documents electronically using hyperlinks.
      </para>
      <para>From:
        <link
          href="http://www.ironspider.ca/webdesign101/htmlhistory.htm"
          label="http://www.ironspider.ca/webdesign101/htmlhistory.htm" />
      </para>
    </blockquote>
    <para>The biggest issue, in my opinion, is that HTML has become a lot more complicated than the initial design. Creating HTML content (particularly when used in conjunction with CSS frameworks like Bootstrap or Zurb or with applications that use additional semantic elements like ePub) takes a lot more than just knowing markup to code them correctly. It takes knowledge of the document structure, the semantics needed for the content or the applications we are creating and the restrictions and schemas that we need to use so that the content will pass validation.</para>
    <para>This article presents 4 different approaches to creating HTML. Two of them use HTML directly but target it as the final output for transformations and templating engines; the other two use markup like HTML without requiring strict HTML conformance. I've made these selections for two reasons:</para>
    <ulist>
      <item>People who are not profesionals should not have to learn all the details of creating an ePub3 table of content or know the classes to add to elements to create a Bootsrap or Foundation layout grid</item>
      <item>It makes it easier for developers and designers to build the layout for the content without having to worry about the content itself; we can play with layout and content organization in parallel with content creation and, if we need to make any further changes, we just run our compilation process again</item>
    </ulist>
    <h2>Markdown</h2>
    <para>Perhaps the simplest solution when moving content from text to HTML is Markdown.
    </para>
    <para>
      <link href="http://daringfireball.net/projects/markdown/" label="Markdown"
       />is a text to (X)HTML conversion tool designed for writers. It refers both to the syntax used in the Markdown text files and the applications used to perform the conversion.</para>
    <para>Markdown language was created in 2004 by John Gruber with the goal of allowing people "to write using an easy-to-read, easy-to-write plain text format, and optionally convert it to structurally valid XHTML (or HTML)" (
      <link
        href="http://daringfireball.net/projects/markdown/"
        label="http://daringfireball.net/projects/markdown/" />)</para>
    <para>The language was designed to be readable as-is, without all the additional tags and attributes that makes it possible to covert markdown to languages like SGML, XML and HTML. Markdown is a formatting syntax for text that can be read by humans and can be easily converted to HTML.
    </para>
    <para>The original implementation of Markdown is
      <link
        href="http://search.cpan.org/~sekimura/Text-Markdown-Discount-0.11/xt/MarkdownXS.pl"
        label="markdown.pl"
       />and has been implemented in several other languages as applications (Ruby Gems, NodeJS modules and Python packages). All versions of Markdown are distributed under open source licenses and are included or available as a plugin for, several content-management systems and text editors.</para>
    <para>Sites such as GitHub, Reddit, Diaspora, Stack Overflow, OpenStreetMap, and SourceForge use variants of Markdown to facilitate content creation and discussion between users.</para>
    <para>The biggest weakness of Markdown is the lack of a unified standard. The original Markdown language hasn't been really supported since it was released in 2004 and all new version of Markdown, both parser and language specification have introduced not wholy compatible changes to Markdown. The lack of standard is also Markdown’s biggest strength. It means you can, like Github did, implement your own extensions to the Markdown syntax to acommodate your needs.</para>
    <para>Markdown is not easy to learn but once your fingers get used to the way we type the different elements it becomes much easier to work with as it is nothing more than inserting specific characters in a specific order to obtain the desired effect. Once you train yourself, it is also easy to read without having to convert it to HTML or any other language.</para>
    <para>Most modern text editors have support for Markdown either as part of the default installation or through plugins.</para>
    <h3>Example Markdown document</h3>
    <ulist>
      <item>
        <link href="http://daringfireball.net/projects/markdown/index.text"
          label="Markdown example form daringfireball" />
      </item>
    </ulist>
    <h2>Asciidoctor</h2>
    <para>I only discovered Asciidoctor recently, while researching O'Reilly Media's publishing toolchains. It caught my attention because of it's structure, the expresiveness of the markup without being HTML like HTMLbook and the extensibility of the templating system that it uses behind the scenes.</para>
    <para>Asciidoctor has both a command line interface (CLI) and an API. The CLI is a drop-in replacement for the
      <emphasis>asciidoc</emphasis> command from the Standard python distribution. This means that you have a command line tool
      <emphasis>asciidoctor</emphasis> that will allow you to convert your marked documents without having to resort to a full blown application.
    </para>
    <para>Syntax-wise, Asciidoctor is progressively more complex as you implement more advanced features. In the first example below no tables are used, for example. Tables are used in the second and thirs examples both as data tables and for layout.</para>
    <para>The
      <link href="documentation"
        label="http://asciidoctor.org/docs/"
       /> provides more detailed instructions for the desired markup.</para>
    <h3>Example Asciidoc documents</h3>
    <ulist>
      <item>
        <link
          href="https://raw.githubusercontent.com/asciidoctor/asciidoctor-documentation/master/infrastructure-goals-planning.adoc"
          label="Asciidoctor planning document" />
      </item>
      <item>
        <link
          href="https://raw.githubusercontent.com/asciidoctor/asciidoctor-documentation/master/infrastructure-goals-planning.adoc"
          label="Comparison of Asciidoctor and AsciiDoc Features" />
      </item>
      <item>
        <link
          href="https://raw.githubusercontent.com/asciidoctor/asciidoctor.org/master/docs/_includes/apply-theme.adoc"
          label="Applying Custom Themes" />
      </item>
    </ulist>
    <h2>HTMLBook</h2>
    <para>O'Reilly Media has developed several new tools to get content from authors to readers. Atlas is their authoring tool, a web based application that allows you to create content they developed HTMLbook, a subset of HTML geared towards authoring and multi format publishing.</para>
    <para>Given O'Reilly's history and association with open source publishing tools (they were an early adopter and promoter of Docbook and still use it for some of their publications) I found HTMLbook intriguing but not something to look at right away, as with many things you leave for later it fell off my radar.</para>
    <para>It wasn't until I saw Sanders Kleinfeld's (O'Reilly Media Director of Publishing Technologies)
      <link
        href="http://www.slideshare.net/sanderskleinfeld/open-source-forpubsslideshare"
        label="presentation at IDPF Book World conference"
       /> that I decided to take a second look at HTMLbook and its ecosystem.</para>
    <para>Conceptually HTMLbook is very simple; it combines a subset of HTML5, the semantic structure of ePub documents and other IDPF specifications to create a flavor of HTML 5 that is designed specifically for publishing. There are also stylesheets that will allow you to convert Markdown and other text formats into HTMLbook (see
      <link
        href="https://github.com/oreillymedia/htmlbook.js"
        label="Markdown to HTMLBook" /> and
      <link
        href="https://github.com/oreillymedia/asciidoctor-htmlbook/"
        label="AsciiDoc to HTMLBook (via AsciiDoctor)" />)</para>
    <para>If you use Atlas (O'Reilly's authoring and publishing platform) you don't have to worry about markup as the content is created visually. The challenges begin when implementing this vocabulary outside the Atlas environment.
    </para>
    <para>The project comes with a set of stylesheets to convert HTMLbook content to ePub, MOBI and PDF. The intriguing thing about the stylesheets is that they use CSS Paged Media stylesheets in conjunction with third party tools such as
      <link
        href="http://www.antennahouse.com" label="AntennaHouse"
         /> or
      <link href="http://www.princexml.com/" label="PrinceXML"
       />.</para>
    <para>The open source solutions offer permisive licenses that allow modification and integration into other products without requiring you to release your project under the same license like GPL and LGPL.</para>
    <para>As with any solution that advocates creating HTML directly I have my reservations. In HTML formating in general and specialized formats like HTMLbooks in particular, the learning curve may be too steep for independent authors to use for creating content.</para>
    <para>The user must learn not only the required HTML5 syntax but also the details regarding ePub semantic structure attributes and the other standards needed to create ePub books. While I understand that technologies such as this are not meant for independent authors or for poeple who are not comfortable or familiar with HTML but the learning curve may still be too steep for most users.</para>
    <h3>Example HTMLbook document</h3>
    <ulist>
      <item>
        <link
          href="https://github.com/oreillymedia/HTMLBook/blob/master/samples/alices_adventures_in_wonderland.html"
          label="Alice Adventures in Wonderland marked as HTMLbook" />
      </item>
    </ulist>
    <h2>XML / XSLT</h2>
    <para>Perhaps the oldest solutions in the book to create HTML without actually creating HTML are XML-based. Docbook, TEI and DITA all have stylesheets that will take the XML content and convert it to HTML, PDF, ePub and other more esoteric formats.</para>
    <para>In addition to stylesheets already available developers can create their own to adress specific needs.</para>
    <para>Furthermore, tools like OxygenXML Author (and I would assume other tools in the same category have a visual mode that allow users to write XML content, validated against a schema in a way that is more familiar to people not used to creating content with raw XML tools.</para>
    <para>The issues with xml are similar to those involved in creating HTML. The markup vocabulary requires brackets, attributes have to be enclosed in quotation marks and generall the syntax is as complicated as you make it. However, tools like Oxygen and smilar help alleviate this problem but don't resolve it completely.</para>
    <para>The screenshot below shows OxygenXML Author working in a Docbook 5 document using visual mode.</para>

    <figure>
      <anchor />
      <image alt="Visual Editing Using OxygenXML Author" height="177"
        src="images/visual-editing-mode-small.png" width="280" />
      <figcaption>OxygenXML Visual Editor for XML</figcaption>
    </figure>

    <para>The positive side is that using XSLT there is no limit to what we can do with our XML content.</para>
    <h3>XML examples</h3>
    <ulist>
      <item>
        <link
          href="https://github.com/oreillymedia/docbook_samples/blob/master/ch01.xml"
          label="Sample Chapter marked as Docbook" />
      </item>
      <item>
        <link href="http://docsouth.unc.edu/southlit/poe/poe.xml"
          label="Tales by Edgar Allan Poe, marked as TEI" />
      </item>
      <item>
        <link
          href="http://sourceforge.net/p/dita2indesign/code/HEAD/tree/trunk/dita_gutenberg_samples/dita_src/20000_leagues/chapters/d2e10630.xml"
          label="Chapter from 20000 Leagues Under the Sea, marked as DITA" />
      </item>
    </ulist>
    <h2>Conclusion</h2>
    <para>After exploring a selection of HTML conversion options the question becomes <strong><emphasis>which one is best?</emphasis></strong>
    </para>
    <para>The answer is <strong><emphasis>it depends</emphasis></strong>.</para>
    <para>The best way to see how can these text-based tools can be incorporated is to ask yourself how much work you want to do in the backend versus how much work do you want you authors to do when creating the content. This is where the value of specialists in digital formats and publishing becomes essential, we can work with clients in providing the best solution to meet their needs.</para>
    <para>Keep in mind who your audience and what the target vocabulary you're working towards, it will dictate what your best strategy is. Are these all the solutions; definitely not. Other solutions may appear that fit your needs better than those presented here; I would love to hear if that is the case.</para>
    <para>Striking the balance between author and publisher is a delicate one. I tend to fall on the side of making things easier for authors... The tools can be made to translate basic markup into the desired result with minimal requirements for authors to mark up the content; the same can't necessarily be said about the publisher-first strategy</para>
  </section>

  <section type="chapter">
    <title>Introduction</title>
    <para>One of the biggest limitations of markup languages, in my opinion, is how confining they are. Even large vocabularies like
      <link
        href="http://docbook.org" label="Docbook"
       /> are limited in what they can do out of the box. HTML4 is non-extensible and HTML5 is limited in how you can extend it (web components are the only way to extend HTML5 I'm aware of that doesn't require an update to the HTML specification.)</para>
    <para>By creating our own markup vocabulary we can be as expressive as we need to be without adding additional complexity for writers and users and without adding unecessary complexity for the developers building the tools to interact with the markup. </para>
    <h2>Why create our own markup</h2>
    <para>I have a few answers to that question:</para>
    <para>In creating your own xml-based markup you enforce separation of content and style. The XML document provides the basic content of the document and the hints to use elsewhere. XSLT stylesheets allow you to structure the base document and associated hints into any number of formats (for the purposes of this document we'll concentrate on XHTML, PDF created through Paged Media CSS and PDF created using XSL formatting Objects)
    </para>
    <para>Creating a domain specific markup vocabulary allows you think about structure and complexity for yourself as the editor/typesetter and for your authors. It makes you think about elements and attributes and which one is better for the given experience you want and what, if any, restrictions you want to impose on your makeup.</para>
    <para>By creating our own vocabulary we make it easier for authors to write clean and simple content. XML provides a host of validation tools to enforce the structure and format of the XML document.</para>
    <h2>Options for defining the markup</h2>
    <para>For the purpose of this project we'll define a set of resources that work with a book structure like the one below:</para>
    <code language="xml"
      >&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;book
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="xsd/book-schema-draft.xsd">
    &lt;metadata>
      &lt;title>Sample Document&lt;/title>
      &lt;authors>
        &lt;author>
          &lt;first-name>Carlos&lt;/first-name>
          &lt;surname>Araya&lt;/surname>
        &lt;/author>
      &lt;/authors>
    &lt;/metadata>
    &lt;section type="chapter">
      &lt;title>Chapter 1&lt;/title>

      &lt;para>&lt;/para>
      &lt;para>&lt;/para>
      &lt;para>&lt;/para>
    &lt;/section>

    &lt;section type="chapter">
      &lt;title>Chapter 2&lt;/title>

      &lt;para>&lt;/para>
      &lt;para>&lt;/para>
      &lt;para>&lt;/para>
    &lt;/section>
&lt;/book> </code>
    <para>It is not a complete structure. We will continue adding elements afte we reach the MVP (Minimum Viable Product) stage. As usual, feedback is always appreciated.</para>
  </section>

  <section type="chapter">
    <title>XML Schema</title>
<div class="content-right">
  <h3>Test Title</h3>

  <para>Flexitarian VHS food truck tousled tattooed. Cliche Godard polaroid, Vice blog biodiesel try-hard. American Apparel viral umami, plaid kogi fap ethical cred next level slow-carb. Paleo master cleanse freegan, pug cliche vinyl fanny pack sriracha polaroid Portland. Before they sold out Brooklyn iPhone raw denim keffiyeh Kickstarter Thundercats. Meh fanny pack single-origin coffee, semiotics actually street art you probably haven't heard of them cornhole scenester stumptown. Tumblr Carles asymmetrical migas, roof party DIY photo booth occupy kale chips.</para>

  <para>Pour-over YOLO you probably haven't heard of them, literally tattooed 8-bit narwhal meh salvia disrupt small batch forage mumblecore master cleanse. Four loko paleo iPhone, Banksy kale chips meh pork belly jean shorts asymmetrical mustache. Slow-carb yr selvage, skateboard DIY 3 wolf moon 90's hashtag freegan health goth. Small batch meggings selvage, mumblecore bicycle rights normcore Austin banh mi Carles mixtape. Cliche food truck hoodie, meggings salvia American Apparel 8-bit squid Tumblr retro ugh. Bicycle rights salvia Schlitz semiotics Thundercats. PBR Intelligentsia polaroid locavore meggings meditation deep v.</para>
</div>

    <para>The schema is defined from most general to most specific elements. We'll follow the same process to explain what the schema does and how we arrived to the choices we made. </para>
    <para>At the beginning of the schema we define some custom types that will be used throughout the document.</para>
    <para><emphasis>string255</emphasis> is a string that is limited to 255 characters in length. We do this to prevent overtly long strings.
    </para>
    <para>The second one,
      <emphasis>isbn</emphasis> is a regular expression to match 10 digits ISBN numbers. We'll have to modify it to handle ISBN-13 as well as 10.</para>
    <para>The third custom type is an enumeration of all possible values for the
      <emphasis>align</emphasis> attribute acording to CSS and HTML. Rather than manually type each of these we will reference this enumeration and include all its values for "free".</para>
    <para>We also allow the optional use of
      <emphasis>class</emphasis> and
      <emphasis>id</emphasis> attributes for the book by assigning `genericPropertiesGroup` attribute group as attributes to the group. We'll see this assigned to other elements so I decided to make it reusable rather than have to duplicate the attributes in every element I want to use them in.</para>
    <code language="xml"
      >&lt;!-- Simple types to use in the content -->
&lt;xs:simpleType name="token255">
  &lt;xs:restriction base="xs:token">
    &lt;xs:maxLength value="255"/>
  &lt;/xs:restriction>
&lt;/xs:simpleType>

&lt;xs:simpleType name="isbn">
  &lt;xs:restriction base="xs:unsignedLong">
    &lt;xs:totalDigits value="10"/>
    &lt;xs:pattern value="d{10}"/>
  &lt;/xs:restriction>
&lt;/xs:simpleType>

&lt;xs:simpleType name="align">
  &lt;xs:restriction base="xs:token">
    &lt;xs:enumeration value="left"/>
    &lt;xs:enumeration value="center"/>
    &lt;xs:enumeration value="right"/>
    &lt;xs:enumeration value="justify"/>
  &lt;/xs:restriction>
&lt;/xs:simpleType>

&lt;xs:attributeGroup name="genericPropertiesGroup">
  &lt;xs:attribute name="id" type="xs:ID" use="optional"/>
  &lt;xs:attribute name="class" type="xs:token" use="optional"/>
&lt;/xs:attributeGroup>
</code>

    <para>The next stage is to define elements to create our
      <emphasis>people</emphasis> types. We create a base person element and then create three role elements based on person. We will use this next to define groups for each role.</para>

    <code language="xml"
      > &lt;!-- complex types to create groups of similar
      person items -->
      &lt;xs:complexType name="person">
        &lt;xs:sequence>
          &lt;xs:element name="first-name" type="xs:token"/>
          &lt;xs:element name="surname" type="xs:token"/>
        &lt;/xs:sequence>
        &lt;xs:attribute name="id" type="xs:ID" use="optional"/>
      &lt;/xs:complexType>

      &lt;xs:complexType name="author">
        &lt;xs:choice minOccurs="1" maxOccurs="unbounded">
          &lt;xs:element name="author" type="person"/>
        &lt;/xs:choice>
      &lt;/xs:complexType>

      &lt;xs:complexType name="editor">
        &lt;xs:complexContent>
          &lt;xs:extension base="person">
            &lt;xs:sequence>
              &lt;xs:element name="type" type="xs:string"/>
            &lt;/xs:sequence>
          &lt;/xs:extension>
        &lt;/xs:complexContent>
      &lt;/xs:complexType>

      &lt;xs:complexType name="otherRole">
        &lt;xs:complexContent>
          &lt;xs:extension base="person">
            &lt;xs:sequence minOccurs="1" maxOccurs="1">
              &lt;xs:element name="role" type="xs:string"/>
            &lt;/xs:sequence>
          &lt;/xs:extension>
        &lt;/xs:complexContent>
      &lt;/xs:complexType> </code>

    <para>Two of the derived types add attributes or elements to the base person element to make the generic person more appropriate to their role rather than repeat the content of person each time that an author, editor or other role appear.</para>
    <para>Author is the most straight forward and only wraps person in the author element. </para>
    <para>Editor takes the base person element and adds a `type` child to indicate the type of editor (some that come to mind are acquisition, production and managing.) The editor elements looks like this:</para>

    <code language="xml"
      >&lt;editor>
  &lt;first-name>Carlos&lt;/first-name>
  &lt;surname>Araya&lt;/surname>
  &lt;type>Managing&lt;/type>
&lt;/editor> </code>

    <para>OtherRoles takes all other roles that are not author or editor and adds a role element to specify what role they play, for example: Illustrator, Indexer, Research Assistant, among others. The element looks like this:</para>

    <code language="xml"
      > &lt;otherRole>
  &lt;first-name>Sherlock&lt;/first-name>
  &lt;surname>Holmes&lt;/surname>
  &lt;role>Researcher&lt;/role>
&lt;/otherRole> </code>

    <para>Next we create wrappers for each group as
      <emphasis>authors</emphasis>,
      <emphasis>editors</emphasis> and
      <emphasis>otherRoles</emphasis> so we can provide easier styling with XSLT and CSS later on.</para>

    <code language="xml"
      >&lt;xs:complexType name="authors">
  &lt;xs:annotation>
    &lt;xs:documentation>Wrapper to get more than one author&lt;/xs:documentation>
  &lt;/xs:annotation>
  &lt;xs:sequence>
    &lt;xs:element name="author" type="person"/>
  &lt;/xs:sequence>
&lt;/xs:complexType>

&lt;xs:complexType name="editors">
  &lt;xs:annotation>
    &lt;xs:documentation>
      extension to person to indicate editor and his/her role
    &lt;/xs:documentation>
  &lt;/xs:annotation>
  &lt;xs:complexContent>
    &lt;xs:extension base="person">
      &lt;xs:sequence>
        &lt;xs:element name="type" type="xs:token"/>
      &lt;/xs:sequence>
    &lt;/xs:extension>
  &lt;/xs:complexContent>
&lt;/xs:complexType>

&lt;xs:complexType name="otherRoles">
  &lt;xs:annotation>
    &lt;xs:documentation>
      extension to person to accomodate roles other than author and editor
    &lt;/xs:documentation>
  &lt;/xs:annotation>
  &lt;xs:complexContent>
    &lt;xs:extension base="person">
      &lt;xs:sequence>
        &lt;xs:element name="role" type="xs:token"/>
      &lt;/xs:sequence>
    &lt;/xs:extension>
  &lt;/xs:complexContent>
 &lt;/xs:complexType> </code>

    <para>We now look at the elements that we can put inside a section. Some of these elements are overtly complex and deliberately so since they have to acommodate a lot of possible parameters.</para>

    <para>We'll look at links first as it is the simplest of our content structures. We borrow the <emphasis>href</emphasis> attribute from HTML to indicate the destination for the link and make it required. </para>

    <para>We also incoporate a <emphasis>label</emphasis> so we can later build the link and for accessibility purposes. It also uses our `genericPropertiesGroup` attribute set to add class and ID as attributes for our links.</para>

    <code language="xml"
      >&lt;xs:element name="link">
  &lt;xs:complexType>
    &lt;xs:attributeGroup ref="genericPropertiesGroup" />
    &lt;xs:attribute name="href" type="xs:string" use="required"/>
    &lt;xs:attribute name="label" type="xs:string" use="required"/>
  &lt;/xs:complexType>
&lt;/xs:element> </code>


    <para>The link in our resulting book will look like this:</para>

    <code language="xml"
      >
      &lt;link href="http://google.com" label="link to google"/>
    </code>

    <para>and with the optional attributes it will look like this</para>

    <code language="xml"
      >
      &lt;link class="external" id="ex01" href="http://google.com" label="link to google">
    </code>

    <para>Once I had the links I figured I need a way to create anchors for internal links that look like this:
      <emphasis>&lt;a href="#top">
      </emphasis> and expect the target to be formated like this
      <emphasis>&lt;a id="top"></emphasis>. To accomodate this I created an anchor element to provide the destination for internal links. </para>

    <code language="xml"
      >&lt;!-- Named Anchor -->
&lt;xs:element name="anchor">
  &lt;xs:complexType>
    &lt;xs:attribute name="id"/>
  &lt;/xs:complexType>
&lt;/xs:element>
  </code>

    <para>As I was working on further ideas for the project I realized that we forgot to create inline and block level containers for the content, important if you're going to style smaller portions of content within a paragraph or witin a section. Taking the names from HTML we define
      <emphasis>section</emphasis> (inline) and
      <emphasis>div</emphasis>
      (block) elements. Div is a secondary section, containing the same model as the section, including additional div containers.</para>

    <code language="xml"
      >&lt;xs:element name="div">
  &lt;xs:complexType mixed="true">
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
      &lt;xs:element ref="code"/>
      &lt;xs:element ref="para" minOccurs="1" maxOccurs="unbounded"/>
      &lt;xs:element ref="ulist"/>
      &lt;xs:element ref="olist"/>
      &lt;xs:element ref="figure"/>
      &lt;xs:element ref="image"/>
      &lt;xs:element ref="div"/>
      &lt;xs:element ref="span"/>
      &lt;xs:element ref="blockquote"/>
      &lt;xs:element ref="h1"/>
      &lt;xs:element ref="h2"/>
      &lt;xs:element ref="h3"/>
      &lt;xs:element ref="h4"/>
      &lt;xs:element ref="h5"/>
      &lt;xs:element ref="h6"/>
    &lt;/xs:choice>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="type"type="xs:token" use="optional"/>
  &lt;/xs:complexType>
&lt;/xs:element> </code>

    <para>Span is an inline element, therefore the model is greatly reduced to only the elements that can be inside a paragraph</para>

    <para>Type is used in these two elements and in our sections to create data-type and epub:type attributes. These are used in the Paged Media stylesheet to decide how will the content be formated.</para>

    <code language="xml"
      >   &lt;xs:element name="span">
  &lt;xs:complexType mixed="true">
    &lt;xs:choice  minOccurs="0" maxOccurs="unbounded">
      &lt;xs:element ref="strong"/>
      &lt;xs:element ref="emphasis"/>
      &lt;xs:element ref="underline"/>
      &lt;xs:element ref="strike"/>
      &lt;xs:element ref="link"/>
      &lt;xs:element ref="span"/>
      &lt;xs:element ref="quote"/>
    &lt;/xs:choice>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;/xs:complexType>
  &lt;/xs:element>
    </code>

    <para>Next are images and figures where we borrow from HTML, again, for the name of attribute names and their functionality. We define 3 elements for the image-related tags:
      <emphasis>figure</emphasis>,
      <emphasis>figcaption</emphasis> and the
      <emphasis>image</emphasis>
      itself.</para>
    <para>
      <emphasis>Figure</emphasis> is the wrapper around a `figcaption` caption and the `image` element itself. The `figcaption` is a text-only element that will contain the caption for the associated image</para>
    <code language="xml"
      >&lt;!-- Figure and related elements -->
&lt;xs:element name="figure">
  &lt;xs:complexType mixed="true">
    &lt;xs:all>
      &lt;xs:element ref="image"/>
      &lt;xs:element ref="figcaption"/>
    &lt;/xs:all>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
&lt;/xs:element> </code>
    <para>The caption child only uses text and, because it's only used as a child of figure, we don't need to assign attributes to it. It will inherit from the image or the surrounding figure.</para>
    <code language="xml"
      >&lt;xs:element name="figcaption">
  &lt;xs:annotation>
    &lt;xs:documentation>
    caption for the image in the figure. Because it's
    only used as a child of figure, we don't need to
    assign attributes to it
    &lt;/xs:documentation>
  &lt;/xs:annotation>
&lt;/xs:element> </code>
    <para>When working with the image element we start with `genericPropertiesGroup` to define
      <emphasis>class</emphasis> and
      <emphasis>id</emphasis>.</para>
    <para>Then we require a
      <emphasis>src</emphasis> attribute to tell where the image is located. We need to be careful because we haven't told the schema the different types of images. We have at least three different locations for the image files. All three of these are valid locations for our image.png file.</para>
    <code language="bash"
      >image.png
      directory/image.png
      http://mysite.org/images/image.png </code>
    <para>We could create branches of our schema to deal with the different locations but I've chosen to let the XSLT style sheets deal with this particular situation. The schema type for the image (
      <emphasis>xs:anyURI</emphasis>) should also help to sort out the issue.
    </para>
    <para>
      <emphasis>width</emphasis> and
      <emphasis>height</emphasis> are expressed as integer and are left as optional to account for the possibility that the CSS or XSLT stylesheets modify the image dimensions. Making these dimensions mandatory may affect how the element interact with the styles later on.</para>
    <para>The
      <emphasis>alt</emphasis> attribute indicates alternative text for the image. It is not meant as a full description so we've constrained it to 255 characters.</para>
    <para>
      <emphasis>align</emphasis> uses our align enumeration to indicae the image's alignment. It is not essential to the XML but will be useful to the XSLT stylesheets we'll create later as part of the process.</para>

    <code language="xml"
      >&lt;xs:element name="image">
  &lt;xs:complexType>
    &lt;xs:attributeGroup ref="genericPropertiesGroup" />
    &lt;xs:attribute name="src" type="xs:string" use="required"/>
    &lt;xs:attribute name="height" type="xs:integer" use="optional"/>
    &lt;xs:attribute name="width" type="xs:integer" use="optional"/>
    &lt;xs:attribute name="alt" type="string255" use="required"/>
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
&lt;/xs:element> </code>
    <para>In order to acommodate the four basic styles available to our documents:
      <emphasis>strong</emphasis>,
      <emphasis>emphasis</emphasis>,
      <emphasis>strike</emphasis> and
      <emphasis>underline</emphasis> and their nesting we had to do some juryriging of the elements to tell the schema what children are allowed for each element. The schema look like this:
    </para>

    <!-- HERE -->

    <code language="xml"
      >&lt;xs:element name="strong">
  &lt;xs:complexType mixed="true">
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
      &lt;xs:element ref="emphasis"/>
      &lt;xs:element ref="underline"/>
      &lt;xs:element ref="strike"/>
    &lt;/xs:choice>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="emphasis">
  &lt;xs:complexType mixed="true">
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
      &lt;xs:element ref="strong"/>
      &lt;xs:element ref="emphasis"/>
      &lt;xs:element ref="underline"/>
      &lt;xs:element ref="strike"/>
    &lt;/xs:choice>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="underline">
  &lt;xs:complexType mixed="true">
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
      &lt;xs:element ref="strong"/>
      &lt;xs:element ref="emphasis"/>
      &lt;xs:element ref="strike"/>
      &lt;/xs:choice>
    &lt;/xs:complexType>
  &lt;/xs:element>

&lt;xs:element name="strike">
  &lt;xs:complexType mixed="true">
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
      &lt;xs:element ref="strong"/>
      &lt;xs:element ref="emphasis"/>
      &lt;xs:element ref="underline"/>
    &lt;/xs:choice>
  &lt;/xs:complexType>
&lt;/xs:element> </code>

    <para>The
      <emphasis>emphasis</emphasis> element is the only one that allows the same element to be nested. When nesting emphasis elements they cancel each other</para>
    <para>When I first conceptualized the project I envisioned one element for both numbered and bulleted lists. That proved to difficult to implement and to cumbersome to write so I reverted to having to sepratate lists, one for ordered or numbered lists (
      <emphasis>olist</emphasis>) and one for unordered or bulleted lists (
      <emphasis>ulist</emphasis>). The only difference is the type of list that we use in XSLT later on.</para>
    <para>The list elements also require at least 1
      <emphasis>item</emphasis>
      child. If it's going to be left empty why bother having the list to begin with.
    </para>
    <para>They inherit class and ID from
      <emphasis>genreicPropertiesGroup</emphasis>.</para>

    <code language="xml"
      >&lt;!-- Lists -->
&lt;xs:element name="ulist">
  &lt;xs:complexType mixed="true">
    &lt;xs:sequence minOccurs="1" maxOccurs="unbounded">
      &lt;xs:element ref="item"/>
    &lt;/xs:sequence>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="olist">
  &lt;xs:complexType mixed="true">
    &lt;xs:sequence minOccurs="1" maxOccurs="unbounded">
      &lt;xs:element ref="item"/>
    &lt;/xs:sequence>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="item">
  &lt;xs:complexType mixed="true">
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
&lt;/xs:element> </code>

    <para>The
      <emphasis>code</emphasis> element wraps code and works as higlighted, fenced code blocks (think Github Flavored Markdown.)</para>
    <para>When using CSS we'll generate a &lt;code>&lt;pre>&lt;/pre>&lt;/code> block with a language attribute that will be formated with Highlight.js (the chosen package will be a part of the project tool chain)</para>
    <para>Because of the intended use, the `language` attribute is required.
    </para>
    <para>Class and ID (from
      <emphasis>genericPropertiesGroup</emphasis>) are optional
    </para>
    <code language="xml"
      >&lt;xs:element name="code">
  &lt;xs:complexType mixed="true">
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="language" use="required"/>
  &lt;/xs:complexType>
&lt;/xs:element> </code>

    <para>Another type of element that came up when working on the documentation were aside, blockquotes and quotes. `Blockquote` and `attribution` are for longer block level quotations (more than 4 lines of text) while `quote` is for shorter quotations usually inserted in a paragraph.</para>

    <code language="xml"
      >&lt;xs:element name="blockquote">
  &lt;xs:complexType mixed="true">
    &lt;xs:sequence minOccurs="1" maxOccurs="unbounded">
      &lt;xs:element ref="attribution"/>
      &lt;xs:element ref="para"/>
    &lt;/xs:sequence>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="attribution">
  &lt;xs:complexType mixed="true">
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
      &lt;xs:element ref="para"/>
    &lt;/xs:choice>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="quote">
  &lt;xs:complexType mixed="true">
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
&lt;/xs:element> </code>

    <para>Paragraphs (
      <emphasis>para</emphasis> in our documents) are the essential unit of content for our books. The paragraph is where most content will happen, text, styles and additional elements that we may add as we go along (inline code comes to mind).</para>
    <para>We include 3 different groups of properties in the paragraph declaration: Styles (
      <emphasis>strong</emphasis>,
      <emphasis>emphasis</emphasis>,
      <emphasis>underline</emphasis> and
      <emphasis>strike</emphasis> to do bold, italics, underline (outside links) and strikethrough text); Organization (
      <emphasis>span</emphasis>
      and
      <emphasis>link</emphasis>) and our
      <emphasis>genericPropertiesGroup</emphasis> (class and id).</para>
    <para>This model barely begins to scratch the surface of what we can do with our paragraph model. I decided to go for simplicity rather than completeness. This will definitely change in future versions of the schema.
    </para>

    <code language="xml"
      >&lt;!-- Paragraphs -->
&lt;xs:element name="para">
  &lt;xs:complexType mixed="true">
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
      &lt;xs:element ref="strong"/>
      &lt;xs:element ref="emphasis"/>
      &lt;xs:element ref="underline"/>
      &lt;xs:element ref="strike"/>
      &lt;xs:element ref="link"/>
      &lt;xs:element ref="span"/>
      &lt;xs:element ref="quote"/>
    &lt;/xs:choice>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
&lt;/xs:element> </code>
    <para>Like HTML we've chose to create 6 levels of headings although, to be honest, I can't see the need for more than 4. </para>
    <para>We give all links three attributes:
      <emphasis>class</emphasis>,
      <emphasis>id</emphasis> and
      <emphasis>align</emphasis> to hint stylesheets where we want to place the heading (left, right, center)
    </para>
    <code language="xml"
      >&lt;!-- Headings -->
&lt;xs:element name="h1">
  &lt;xs:complexType mixed="true">
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="h2">
  &lt;xs:complexType mixed="true">
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="h3">
  &lt;xs:complexType mixed="true">
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="h4">
  &lt;xs:complexType mixed="true">
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="h5">
  &lt;xs:complexType mixed="true">
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
&lt;/xs:element>

&lt;xs:element name="h6">
  &lt;xs:complexType mixed="true">
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/>
  &lt;/xs:complexType>
&lt;/xs:element>
    </code>
    <para>The metadata section tells us more about the book itself and can be used to build a
      <emphasis>package.opf</emphasis> manifest using XSLT as part of our transformation process. We include basic information such as
      <emphasis>isbn</emphasis> (validated as an ISBN type defined earlier in the schema), an
      <emphasis>edition</emphasis> (integer indicating what edition of the book it is) and
      <emphasis>title</emphasis>.</para>
    <code language="xml"
      >&lt;!-- Metadata element -->
&lt;xs:element name="metadata">
  &lt;xs:complexType>
    &lt;xs:sequence>
      &lt;xs:element name="isbn" type="isbn"/>
      &lt;xs:element name="edition" type="xs:integer"/>
      &lt;xs:element name="title" type="token255"/>
      &lt;xs:element name="authors" type="authors" minOccurs="1" maxOccurs="unbounded"/>
      &lt;xs:element name="editors" type="editors" minOccurs="0" maxOccurs="unbounded"/>
      &lt;xs:element name="otherRoles" type="otherRoles" minOccurs="0" maxOccurs="unbounded"/>
      &lt;xs:element ref="para"/>
    &lt;/xs:sequence>
  &lt;/xs:complexType>
&lt;/xs:element> </code>
    <para>Section is our primary container for paragraphs and associated content. Some of the items exclusive to sections are:</para>
    <para>The
      <emphasis>title</emphasis> element is required to appear exactly one time.</para>
    <para>We can have 1 or more
      <emphasis>para</emphasis> elements.</para>
    <para>We can use 0 or more of the following elements:</para>
    <ulist>
      <item><emphasis>anchor</emphasis> to create standalone anchors to content</item>
      <item><emphasis>code</emphasis> fenced code blocks elements</item>
      <item><emphasis>ulist</emphasis> unordered list</item>
      <item><emphasis>olist</emphasis> ordered (numbered) lists</item>
      <item><emphasis>figure</emphasis> for captioned images</item>
      <item><emphasis>image</emphasis> without captions</item>
      <item><emphasis>div</emphasis> block level containers</item>
      <item><emphasis>span</emphasis> inline level container</item>
      <item><emphasis>blockquote</emphasis> block level quotations</item>
      <item><emphasis>video</emphasis> elements</item>
      <item><emphasis>h1 to h6</emphasis> headings</item>
    </ulist>
    <para>The element inherits
      <emphasis>class</emphasis> and
      <emphasis>ID</emphasis> from genericPropertiesGroup.</para>
    <para>Finally we add the `type` to create data-type and/or epub:type attributes. I chose to make it option and default it to chapter. We want to make it easier for authors to create content; where possible. I'd rather have the wrong value than no value at all.</para>
    <code language="xml"
      >    &lt;!-- Section element -->
      &lt;xs:element name="section">
      &lt;xs:complexType mixed="true">
      &lt;xs:sequence>
        &lt;xs:element name="title" type="xs:token" minOccurs="0" maxOccurs="1"/>
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded">
          &lt;xs:element ref="anchor"/>
          &lt;xs:element ref="code"/>
          &lt;xs:element ref="para" minOccurs="1" maxOccurs="unbounded"/>
          &lt;xs:element ref="ulist"/>
          &lt;xs:element ref="olist"/>
          &lt;xs:element ref="figure"/>
          &lt;xs:element ref="image"/>
          &lt;xs:element ref="div"/>
          &lt;xs:element ref="span"/>
          &lt;xs:element ref="blockquote"/>
          &lt;xs:element ref="video"/>
          &lt;xs:element ref="h1"/>
          &lt;xs:element ref="h2"/>
          &lt;xs:element ref="h3"/>
          &lt;xs:element ref="h4"/>
          &lt;xs:element ref="h5"/>
          &lt;xs:element ref="h6"/>
        &lt;/xs:choice>
      &lt;/xs:sequence>
      &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
      &lt;xs:attribute name="type" type="xs:token" use="optional" default="chapter">
      &lt;/xs:attribute>
      &lt;/xs:complexType>
      &lt;/xs:element></code>
    <para>Now that we have defined our elements, we'll define the core structure of the document by defining the structure of the `book` element.</para>
    <para>After all the work we've done defining the content the definition of our book is almost anticlimatic. We define the `book` element as the sequence of exactly 1
      <emphasis>metadata</emphasis> element and 1 or more
      <emphasis>section</emphasis> elements.</para>
    <para>As with all our elements we add
      <emphasis>class</emphasis> and
      <emphasis>ID</emphasis> from our genericPropertiesGroup.</para>
    <code language="xml"
      >&lt;xs:element name="book">
  &lt;xs:complexType mixed="true">
    &lt;xs:sequence>
      &lt;xs:element ref="metadata" minOccurs="0" maxOccurs="1"/>
      &lt;xs:element ref="section" minOccurs="1" maxOccurs="unbounded"/>
    &lt;/xs:sequence>
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/>
  &lt;/xs:complexType>
&lt;/xs:element> </code>
    <para>This covers the schema for our document type. It is not completed by any stretch of the imagination. It can be further customized to suit individual needs. The current version represents a very basic text heavy document type.</para>
    <para>There are definitely more elements to add like video, audio and others both with equivalent elements in HTML and compound elements based on your needs.
    </para>
  </section>

  <section type="chapter">
    <title>From XML to HTML</title>
    <para>One of the biggest advantages of working with XML is that we can convert the abstract tags into other markups. For the purposes of this project we'll convert the XML created to match the schema we just created to HTML and then use tools like
      <link
        href="http://www.princexml.com" label="PrinceXML" /> or
      <link
        href="http://www.antennahouse.com" label="AntenaHouse"
       /> we'll convert the HTML/CSS files to PDF</para>
    <h2>Why HTML</h2>
    <para>HTML is the default format for the web and for most web/html based content such as ePub and Kindle. As such it makes a perfect candidate to explore how to generate it programatically from a single source file.
    </para>
    <para>HTML will also act as our source for using CSS paged media to create PDF cotnent.</para>
    <h2>Why PDF</h2>
    <para>Rather than having to deal with
      <link
        href="http://www.w3.org/TR/2006/REC-xsl11-20061205/" label="XSL-FO"
         />, another XML based vocabulary to create PDF content, we'll use XSLT to create another HTML file and process it with
      <link
        href="http://dev.w3.org/csswg/css-page-3/" label="CSS Paged Media"
         /> and the companion
      <link
        href="http://www.w3.org/TR/css-gcpm-3/"
        label="Generated Content for Paged Media"
       /> specifications to create PDF content.
    </para>
    <para>In this document we'll concentrate on the XSLT to HTML conversion and will defer the from HTML to PDF to a later article.</para>
    <h2>Creating our conversion stylesheets</h2>
    <para>To convert our XML into other formats we will use XSL Transformations (also known as XSLT)
      <link
        href="http://www.w3.org/TR/xslt" label="version 2"
         /> (a W3C standard) and
      <link
        href="http://www.w3.org/TR/xslt-30/" label="version 3"
       /> (a W3C last call draft recommendation) where appropriate.</para>
    <para>XSLT is a functional language designed to transform XML into other markup vocabularies. It defines template rules that match elements in your source document and processing them to convert them to the target vocabulary.
    </para>
    <para>In the XSLT example below, we do the following:</para>
    <olist>
      <item>Declare the file to be an XML document</item>
      <item>Define the root element of the stylesheet (xsl:stylesheet)</item>
      <item>Indicate the namespaces that we'll use in the document and, in this case, tell the processor to excluse the given namespaces</item>
      <item>Strip whitespaces from all elements and preserve it in the code elements
      </item>
      <item>Create the default output we'll use for the main document and all generated pages (discussed later)</item>
      <item>Create a default template to warn us if we missed anything</item>
    </olist>
    <code language="xml"
      >&lt;?xml version="1.0" ?> &lt;!-- Define stylesheet
      root and namespaces we'll work with --> &lt;xsl:stylesheet
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:dc="http://purl.org/dc/elements/1.1/"
      xmlns:epub="http://www.idpf.org/2007/opf" exclude-result-prefixes="dc
      epub" xml:lang="en-US" version="2.0"> &lt;!-- Strip whitespace from the
      listed elements --> &lt;xsl:strip-space elements="*"/> &lt;!-- And
      preserve it from the elements below --> &lt;xsl:preserve-space
      elements="code"/> &lt;!-- Define the output for this and all document
      children --> &lt;xsl:output name="xhtml-out" method="xhtml" indent="yes"
      encoding="UTF-8" omit-xml-declaration="yes" /> &lt;!-- Default template
      taken from http://bit.ly/1sXqIL8 This will tell us of any unmatched
      elements rather than failing silently --> &lt;xsl:template match="*">
      &lt;xsl:message terminate="no"> WARNING: Unmatched element:
      &lt;xsl:value-of select="name()"/> &lt;/xsl:message>
      &lt;xsl:apply-templates/> &lt;/xsl:template> &lt;!-- More content to be
      added --> &lt;/xsl:stylesheet></code>
    <para>This is a lot of work before we start creating our XSLT content. But it's worth doing the work up front. We'll see what are the advantages of doint it this way as we move down the style sheet.</para>
    <para>Now onto our root templates. The first one is the entry point to our document. It performs the following tasks:</para>
    <olist>
      <item>Match the root element to create the skeleton for our HTML content
      </item>
      <item>In the title we insert the content of the
        <emphasis>metadata/title</emphasis> element</item>
      <item>In the body we 'apply' the templates that match the content inside our document (more on this later)</item>
    </olist>
    <code language="xml"
      >&lt;!-- Root template, matching / --> &lt;xsl:template
      match="book"> &lt;html> &lt;head> &lt;xsl:element name="title">
      &lt;xsl:value-of select="metadata/title"/> &lt;/xsl:element>
      &lt;xsl:element name="meta"> &lt;xsl:attribute name="generator">
      &lt;xsl:value-of select="system-property('xsl:product-name')"/>
      &lt;xsl:value-of select="system-property('xsl:product-version')"/>
      &lt;/xsl:attribute> &lt;/xsl:element> &lt;link rel="stylesheet"
      href="css/style.css" /> &lt;xsl:if test="(code)"> &lt;!-- Use highlight.js
      and docco style --> &lt;link rel="stylesheet" href="css/styles/docco.css"
      /> &lt;!-- Load highlight.js --> &lt;script
      src="lib/highlight.pack.js">&lt;/script> &lt;script>
      hljs.initHighlightingOnLoad(); &lt;/script> &lt;/xsl:if> &lt;!-- Comment
      this out for now. It'll become relevant when we add video &lt;script
      src="js/script.js">&lt;/script> --> &lt;/head> &lt;body>
      &lt;xsl:apply-templates/> &lt;xsl:apply-templates select="/" mode="toc"/>
      &lt;/body> &lt;/html> &lt;/xsl:template></code>
    <para>We could build the CSS stylesheet and Javascript files as part of our root template but we chose not to.</para>
    <para>Working with the stylesheet as part of the XSLT stylesheet allows the XSLT stylesheet designer to embed the style and parameterize the stylesheet, thus making the stylesheet customizable from the command line.
    </para>
    <para>For all advantages, this method ties the styles for the project to the XSLT stylesheet and requires the XSLT stylesheet designer to be involved in all CSS and Javascript updates.</para>
    <para>By linking to external CSS and Javascript files we can leverage expertise independent of the Schema and XSLT stylesheets. Book designers can work on the CSS, UX and experience designers can work on Javascript and additional CSS areas, book designers can work on the Paged Media stylesheets and authors can just write.</para>
    <para>Furthermore we can reuse our CSS and Javascript on multiple documents.
    </para>
    <h2>Table of contents</h2>
    <blockquote>
      <para>The table of content template is under active development and will be different depending on the desired output. I document it here as it is right now but will definitely change as it's further developed.
      </para>
    </blockquote>
    <para>There is a second template matching the root element of our document to create a table of content. At first thought this looks like the wrong approach
    </para>
    <para>We leverage XSLT modes that allow us to create templates for the same element to perform different tasks. In `toc mode` we want the root template to do the following:</para>
    <olist>
      <item>Create the section and nav and ol elements</item>
      <item>Add the title for the table of contents</item>
      <item>For each section element that is a child of root create these elements
      </item>
      <olist>
        <item>The `li` element</item>
        <item>The a element with the corresponding href element</item>
        <item>The value of the href element (a concatenation of the section's type attribute, the position within the document and the .html string)
        </item>
        <item>The title of the section as the 'clickable' portion of the link
        </item>
      </olist>
    </olist>
    <code language="xml"
      >&lt;xsl:template match="/" mode="toc"> &lt;section
      data-type="toc"> (1) &lt;nav class="toc"> (1) &lt;h2>Table of
      Contents&lt;/h2> &lt;ol> &lt;xsl:for-each select="book/section">
      &lt;xsl:element name="li"> (3.1) &lt;xsl:element name="a"> (3.2)
      &lt;xsl:attribute name="href"> (3.2) &lt;xsl:value-of
      select="concat((@type), position(),'.html')"/> (3.3) &lt;/xsl:attribute>
      &lt;xsl:value-of select="title"/> (3.4) &lt;/xsl:element>
      &lt;/xsl:element> &lt;/xsl:for-each> &lt;/ol> &lt;/nav> &lt;/section>
      &lt;/xsl:template></code>
    <h2>Metadata and Section</h2>
    <para>With these templates in place we can now start writing the major areas of the document,
      <emphasis>metadata</emphasis> and
      <emphasis>section</emphasis>.</para>
    <h3>Metadata</h3>
    <para>The metadata is a container for all the elements inside. As such we just create the div that will hold the content and call `xsl:apply-templates` to process the children inside the metadata element using the apply-template XSLT instruction. The template looks like this
    </para>
    <code language="xml"
      >&lt;xsl:template match="metadata"> &lt;xsl:element
      name="div"> &lt;xsl:attribute name="class">metadata&lt;/xsl:attribute>
      &lt;xsl:apply-templates/> &lt;/xsl:element> &lt;/xsl:template> </code>
    <h3>Section</h3>
    <para>The section container on the other hand is a lot more complex because it has a lot of work to do. It is our primary unit for generating files, takes most of the same attributes as the root template and then processes the rest of the content.</para>
    <para>Inside the template we first create a vairable to hold the name of the file we'll generate. The file name is a concatenation of the following elements:
    </para>
    <ulist>
      <item>The type attribute</item>
      <item>The position in the document</item>
      <item>the string "html"</item>
    </ulist>
    <para>The result-document element takes two parameters: the value of the file name variable we just defined and the xhtml-out format we defined at the top of the document. The XHTML format may look like overkill right now but it makes sense when we consider moving the generated content to ePub or other fomats where strict XHTML conformance is a requirement.</para>
    <para>We start generating the skeleton of the page, we add the default style sheet and do the first conditional test of the document. Don't want to add stylesheets to the page unless they are needed so we test if there is a code element on the page and only add highlight.js related stylesheets and scripts. </para>
    <para>In the body element we see the first of many times we'll conditionally add attributes to the element. We use only add a data-type attribute to body if there is a type attribute in the source document. We do the same thing for id and class.</para>
    <code language="xml"
      >&lt;xsl:template match="section"> &lt;!-- Variable to
      create section file names --> &lt;xsl:variable name="fileName"
      select="concat((@type), (position()-1),'.html')"/> &lt;!-- An example
      result of the variable above would be introduction1.xhtml -->
      &lt;xsl:result-document href='{$fileName}' format="xhtml-out"> &lt;html>
      &lt;head> &lt;link rel="stylesheet" href="css/style.css" /> &lt;xsl:if
      test="(code)"> &lt;!-- Use highlight.js and github style --> &lt;link
      rel="stylesheet" href="css/styles/docco.css" /> &lt;!-- Load highlight.js
      --> &lt;script src="lib/highlight.pack.js">&lt;/script> &lt;script>
      hljs.initHighlightingOnLoad(); &lt;/script> &lt;/xsl:if> &lt;!-- Comment
      this out for now. It'll become relevant when we add video &lt;script
      src="js/script.js">&lt;/script> --> &lt;/head> &lt;body> &lt;section>
      &lt;xsl:if test="@type"> &lt;xsl:attribute name="data-type">
      &lt;xsl:value-of select="@type"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@class)"> &lt;xsl:attribute name="class">
      &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id"> &lt;xsl:value-of
      select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:apply-templates/>
      &lt;/section> &lt;/body> &lt;/html> &lt;/xsl:result-document>
      &lt;/xsl:template> </code>
    <h2>Metadata content</h2>
    <h3>Publication information</h3>
    <code language="xml"
      >&lt;xsl:template match="isbn"> &lt;p>ISBN:
      &lt;xsl:value-of select="."/>&lt;/p> &lt;/xsl:template> </code>
    <code language="xml"
      >&lt;xsl:template match="edition"> &lt;p
      class="no-margin-left">Edition: &lt;xsl:value-of select="."/>&lt;/p>
      &lt;/xsl:template> </code>
    <h3>People groups</h3>
    <code language="xml"
      >&lt;xsl:template match="metadata/authors">
      &lt;h2>Authors&lt;/h2> &lt;ul> &lt;xsl:for-each select="author"> &lt;li>
      &lt;xsl:value-of select="first-name"/> &lt;xsl:text> &lt;/xsl:text>
      &lt;xsl:value-of select="surname"/> &lt;/li> &lt;/xsl:for-each> &lt;/ul>
      &lt;/xsl:template> &lt;xsl:template match="metadata/editors">
      &lt;h2>Editorial Team&lt;/h2> &lt;ul class="no-bullet"> &lt;xsl:for-each
      select="editor"> &lt;li> &lt;xsl:value-of select="first-name"/>
      &lt;xsl:text> &lt;/xsl:text> &lt;xsl:value-of select="surname"/>
      &lt;xsl:value-of select="concat(' - ', type, ' ',
      'editor')">&lt;/xsl:value-of> &lt;/li> &lt;/xsl:for-each> &lt;/ul>
      &lt;/xsl:template> &lt;xsl:template match="metadata/otherRoles">
      &lt;h2>Production team&lt;/h2> &lt;ul class="no-bullet"> &lt;xsl:for-each
      select="otherRole"> &lt;li> &lt;xsl:value-of select="first-name" />
      &lt;xsl:text> &lt;/xsl:text> &lt;xsl:value-of select="surname" />
      &lt;xsl:text> - &lt;/xsl:text> &lt;xsl:value-of select="role" /> &lt;/li>
      &lt;/xsl:for-each> &lt;/ul> &lt;/xsl:template> </code>
    <h2>Titles and headings</h2>
    <para>Titles and headings use mostly the same code. We've put them in separate templates to make it possible and easier to generate different code for each heading. It's not the same as using CSS where you can declare rules for the same attribute multiple times (with the last one winning); when writing transformations you can only have one per element otherwise you will get an error.</para>
    <para>The goal is to create as simple a markup as we can so we can better leverage CSS to style and make our content display as intended.</para>
    <code language="xml"
      >&lt;xsl:template match="title "> &lt;xsl:element
      name="h1"> &lt;xsl:if test="@align"> &lt;xsl:attribute name="align">
      &lt;xsl:value-of select="@align"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@class)"> &lt;xsl:attribute name="class">
      &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id"> &lt;xsl:value-of
      select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:value-of
      select="."/> &lt;/xsl:element> &lt;/xsl:template> &lt;xsl:template
      match="h1"> &lt;xsl:element name="h1"> &lt;xsl:if test="@align">
      &lt;xsl:attribute name="align"> &lt;xsl:value-of select="@align"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class"> &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id"> &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:value-of select="."/>
      &lt;/xsl:element> &lt;/xsl:template></code>
    <h2>Blockquotes, quotes and asides</h2>
    <code language="xml"
      >&lt;xsl:template match="blockquote"> &lt;xsl:element
      name="blockquote"> &lt;xsl:if test="(@class)"> &lt;xsl:attribute
      name="class"> &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute>
      &lt;/xsl:if> &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id">
      &lt;xsl:value-of select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:apply-templates /> &lt;/xsl:element> &lt;/xsl:template> &lt;!--
      BLOCKQUOTE ATTRIBUTION--> &lt;xsl:template match="attribution">
      &lt;xsl:element name="cite"> &lt;xsl:if test="(@class)"> &lt;xsl:attribute
      name="class"> &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute>
      &lt;/xsl:if> &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id">
      &lt;xsl:value-of select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:apply-templates/> &lt;/xsl:element> &lt;/xsl:template> </code>
    <code language="xml"
      > &lt;xsl:template match="quote"> &lt;q>&lt;xsl:value-of
      select="."/>&lt;/q> &lt;/xsl:template></code>
    <code language="xml"
      >&lt;xsl:template match="aside"> &lt;aside> &lt;xsl:if
      test="type"> &lt;xsl:attribute name="data-type"> &lt;xsl:value-of
      select="@align"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:if
      test="(@class)"> &lt;xsl:attribute name="class"> &lt;xsl:value-of
      select="@class"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:if
      test="(@id)"> &lt;xsl:attribute name="id"> &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:apply-templates/> &lt;/aside>
      &lt;/xsl:template> </code>
    <h2>Div and Span</h2>
    <code language="xml"
      >&lt;xsl:template match="div"> &lt;xsl:element
      name="div"> &lt;xsl:if test="@align"> &lt;xsl:attribute name="align">
      &lt;xsl:value-of select="@align"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@class)"> &lt;xsl:attribute name="class">
      &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id"> &lt;xsl:value-of
      select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:apply-templates/>
      &lt;/xsl:element> &lt;/xsl:template></code>
    <code language="xml"
      >&lt;xsl:template match="span"> &lt;xsl:element
      name="span"> &lt;xsl:if test="@type"> &lt;xsl:attribute name="data-type">
      &lt;xsl:value-of select="@type"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@class)"> &lt;xsl:attribute name="class">
      &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id"> &lt;xsl:value-of
      select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:value-of
      select="."/> &lt;/xsl:element> &lt;/xsl:template></code>
    <h2>Paragraphs</h2>
    <code language="xml"
      >&lt;xsl:template match="para"> &lt;xsl:element
      name="p"> &lt;xsl:if test="(@class)"> &lt;xsl:attribute name="class">
      &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id"> &lt;xsl:value-of
      select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:apply-templates/>
      &lt;/xsl:element> &lt;/xsl:template></code>
    <h2>Styles</h2>
    <code language="xml"
      >&lt;xsl:template match="strong">
      &lt;strong>&lt;xsl:apply-templates />&lt;/strong> &lt;/xsl:template>
      &lt;xsl:template match="emphasis">
      &lt;em>&lt;xsl:apply-templates/>&lt;/em> &lt;/xsl:template>
      &lt;xsl:template match="strike">
      &lt;strike>&lt;xsl:apply-templates/>&lt;/strike> &lt;/xsl:template>
      &lt;xsl:template match="underline"> &lt;u>&lt;xsl:apply-templates/>&lt;/u>
      &lt;/xsl:template> </code>
    <h2>Links and anchors</h2>
    <para>One of the</para>
    <code language="xml"
      >&lt;xsl:template match="link"> &lt;xsl:element
      name="a"> &lt;xsl:if test="(@class)"> &lt;xsl:attribute name="class">
      &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id"> &lt;xsl:value-of
      select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:attribute
      name="href"> &lt;xsl:value-of select="@href"/> &lt;/xsl:attribute>
      &lt;xsl:attribute name="label"> &lt;xsl:value-of select="@label"/>
      &lt;/xsl:attribute> &lt;xsl:value-of select="@label"/> &lt;/xsl:element>
      &lt;/xsl:template></code>
    <para>When working with links there are times when we want to link to sections within the same document or to specific sections in another document. To do this we need anchors that will resolve to the following HTML:
    </para>
    <code language="html">&lt;a name="target">&lt;a></code>
    <para>The transformation element looks like this:</para>
    <code language="xml"
      >&lt;xsl:template match="anchor"> &lt;xsl:element
      name="a"> &lt;xsl:attribute name="name"> &lt;/xsl:attribute>
      &lt;/xsl:element> &lt;/xsl:template> </code>
    <para>Not sure if I want to make this an empty element or not</para>
    <para>Empty element &lt;anchor name="home"/> appeals to my ease of use paradigm but it may not be as easy to understand for peope who are not familiar with XML empty elements</para>
    <h2>Code blocks</h2>
    <para>Code elements create
      <link
        href="https://help.github.com/articles/github-flavored-markdown/#fenced-code-blocks"
        label="fenced code blocks" /> like the ones from
      <link
        href="https://help.github.com/articles/github-flavored-markdown/"
        label="Github Flavored Markdown" />. </para>
    <para>We use
      <link
        href="https://www.google.com/fonts/specimen/Source+Code+Pro"
        label="Adobe Source Code Pro"
       /> font. It's a clean and readable font designed specifically for source code display.</para>
    <para>We highlight our code with
      <link href="https://highlightjs.org/"
        label="Highlight.js" />.</para>
    <blockquote>
      <para>Note that the syntax higlighting only works for HTML. Although PrinceXML supports Highlight.js it is not working. I've asked on the Prince support forums and am waiting for an answer.</para>
    </blockquote>
    <code language="xml"
      >&lt;xsl:template match="code"> &lt;xsl:element
      name="pre"> &lt;xsl:element name="code"> &lt;xsl:attribute name="class">
      &lt;xsl:value-of select="@language"/> &lt;/xsl:attribute> &lt;xsl:value-of
      select="."/> &lt;/xsl:element> &lt;/xsl:element> &lt;/xsl:template> </code>
    <h2>Lists and list items</h2>
    <para>When I first conceptualized this project I had designed a single list element and attributes to produce bulleted and numbered lists. This proved to difficult to implement so I went back to two separate elements: `ulist` for bulleted lists and `olist` for numbered lists.</para>
    <para>Both elements share the
      <emphasis>item</emphasis> element to indicates the items inside the list. At least one item is required a list.</para>
    <code language="xml"
      > &lt;xsl:template match="ulist"> &lt;xsl:element
      name="ul"> &lt;xsl:if test="(@class)"> &lt;xsl:attribute name="class">
      &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id"> &lt;xsl:value-of
      select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:apply-templates/>
      &lt;/xsl:element> &lt;/xsl:template> &lt;xsl:template match="olist">
      &lt;xsl:element name="ol"> &lt;xsl:if test="(@class)"> &lt;xsl:attribute
      name="class"> &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute>
      &lt;/xsl:if> &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id">
      &lt;xsl:value-of select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:apply-templates/> &lt;/xsl:element> &lt;/xsl:template>
      &lt;xsl:template match="item"> &lt;xsl:element name="li"> &lt;xsl:if
      test="(@class)"> &lt;xsl:attribute name="class"> &lt;xsl:value-of
      select="@class"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:if
      test="(@id)"> &lt;xsl:attribute name="id"> &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:value-of select="."/>
      &lt;/xsl:element> &lt;/xsl:template> </code>
    <h2>Figures and Images</h2>
    <para>Figures, captions and the images inside present a few challenges. Because we allow authors to set height and width on both figure and the imageg inside we may find situations where the figure container is narrower than the image inside.</para>
    <para>To avoid this issue we test whether the figure width value is smaller than the width of the image inside. If it is, we use the width of the image as the width of the figure, ootherwise we use the width of the image inside.
    </para>
    <para>We didn't do the same thing for the height. It may be changed in a future iteration. </para>
    <para>The data model for our content allows both figures and images to be used in the document. This is so we don't have to insert empty captions to figures just so we can add an image... If we don't want a caption we can insert the image directly on our document.</para>
    <code language="xml"
      > &lt;xsl:template match="figure"> &lt;xsl:element
      name="figure"> &lt;xsl:if test="(@class)"> &lt;xsl:attribute name="class">
      &lt;xsl:value-of select="@class"/> &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="(@id)"> &lt;xsl:attribute name="id"> &lt;xsl:value-of
      select="@id"/> &lt;/xsl:attribute> &lt;/xsl:if> &lt;!-- If the width of
      the figure is smaller than the width of the containing image we may have
      display problems. If the width of the containging figure is smaller than
      the width of the image, make the figure width equal to the width of hthe
      image, otherwise use the width of the figure element --> &lt;xsl:choose>
      &lt;xsl:when test="@width lt image/@width"> &lt;xsl:attribute
      name="width"> &lt;xsl:value-of select="@width"/> &lt;/xsl:attribute>
      &lt;/xsl:when> &lt;xsl:otherwise> &lt;xsl:attribute name="width">
      &lt;xsl:value-of select="image/@width"/> &lt;/xsl:attribute>
      &lt;/xsl:otherwise> &lt;/xsl:choose> &lt;!-- We don't care about height as
      much as we do width, the caption and image are contained inside the
      figure. We only test if it exists. It's up to the author to make sure
      there are no conflicts --> &lt;xsl:if test="(@height)"> &lt;xsl:attribute
      name="height"> &lt;xsl:value-of select="@height"/> &lt;/xsl:attribute>
      &lt;/xsl:if> &lt;!-- Alignment can be different. We can have a centered
      image inside a left aligned figure --> &lt;xsl:if test="(@align)">
      &lt;xsl:attribute name="align"> &lt;xsl:value-of select="@align"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:apply-templates select="image"/>
      &lt;xsl:apply-templates select="figcaption"/> &lt;/xsl:element>
      &lt;/xsl:template> &lt;xsl:template match="figcaption">
      &lt;figcaption>&lt;xsl:apply-templates/>&lt;/figcaption>
      &lt;/xsl:template> &lt;xsl:template match="image"> &lt;xsl:element
      name="img"> &lt;xsl:attribute name="src"> &lt;xsl:value-of select="@src"/>
      &lt;/xsl:attribute> &lt;xsl:attribute name="alt"> &lt;xsl:value-of
      select="@alt"/> &lt;/xsl:attribute> &lt;xsl:if test="(@width)">
      &lt;xsl:attribute name="width"> &lt;xsl:value-of select="@width"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:if test="(@height)">
      &lt;xsl:attribute name="height"> &lt;xsl:value-of select="@height"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:if test="(@align)">
      &lt;xsl:attribute name="align"> &lt;xsl:value-of select="@align"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:if test="(@class)">
      &lt;xsl:attribute name="class"> &lt;xsl:value-of select="@class"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;xsl:if test="(@id)">
      &lt;xsl:attribute name="id"> &lt;xsl:value-of select="@id"/>
      &lt;/xsl:attribute> &lt;/xsl:if> &lt;/xsl:element> &lt;/xsl:template>
    </code>
  </section>

  <section type="chapter">
    <title>From XML to PDF: Part 1: Special Transformation</title>
    <para> Rather than having to deal with
      <link
        href="http://www.w3.org/TR/2006/REC-xsl11-20061205/" label="XSL-FO"
         />, another XML based vocabulary to create PDF content, we'll use XSLT to create another HTML file and process it with
      <link
        href="http://dev.w3.org/csswg/css-page-3/" label="CSS Paged Media"
         /> and the companion
      <link
        href="http://www.w3.org/TR/css-gcpm-3/"
        label="Generated Content for Paged Media"
       /> specifications to create PDF content.
    </para>
    <para>I'm not against XSL-FO but the structure of document is not the easiest or most intuitive. An example of XSL-FO looks like this:</para>
    <code language="xml"
      > &lt;?xml version="1.0" encoding="iso-8859-1"?> (1)
&lt;fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format"> (2)
&lt;fo:layout-master-set> (3)
  &lt;fo:simple-page-master master-name="my-page">
    &lt;fo:region-body margin="1in"/>
&lt;/fo:simple-page-master> &lt;/fo:layout-master-set>
  &lt;fo:page-sequence master-reference="my-page"> (4)
    &lt;fo:flow flow-name="xsl-region-body"> (5)
      &lt;fo:block>Hello, world!&lt;/fo:block> (6)
    &lt;/fo:flow>
  &lt;/fo:page-sequence>
&lt;/fo:root> </code>
    <olist>
      <item>This is an XML declaration. XSL FO (XSLFO) belongs to XML family, so this is obligatory</item>
      <item>Root element. The obligatory namespace attribute declares the XSL Formatting Objects namespace</item>
      <item>Layout master set. This element contains one or more declarations of page masters and page sequence masters — elements that define layouts of single pages and page sequences. In the example, I have defined a rudimentary page master, with only one area in it. The area should have a 1 inch margin from all sides of the page</item>
      <item>Page sequence. Pages in the document are grouped into sequences; each sequence starts from a new page. Master-reference attribute selects an appropriate layout scheme from masters listed inside `&lt;fo:layout-master-set>`. Setting master-reference to a page master name means that all pages in this sequence will be formatted using this page master</item>
      <item>Flow. This is the container object for all user text in the document. Everything contained in the flow will be formatted into regions on pages generated inside the page sequence. Flow name links the flow to a specific region on the page (defined in the page master); in our example, it is the body region</item>
      <item>Block. This object roughly corresponds to `&lt;div>` in HTML, and normally includes a paragraph of text. I need it here, because text cannot be placed directly into a flow</item>
    </olist>
    <para>Rather than define a flow of content and then the content CSS Paged Media uses a combination of new and existing CSS elements to format the content. For example, to define default page size and then add elements to chapter pages looks like this:</para>
    <code language="css"
      > @page {
      size: 8.5in 11in; margin: 0.5in 1in;
      /* Footnote related attributes */
      counter-reset: footnote;
      @footnote {
        counter-increment: footnote;
        float: bottom;
        column-span: all;
        height: auto;
      }
    }

    @page chapter {
      @bottom-center {
        vertical-align: middle;
        text-align: center;
        content: element(heading);
      }
    } </code>

    <para>The only problem with the code above is that there is no native broser support. For our demonstration we'll use Prince XML to tanslate our HTML/CSS file to PDF. In the not so distant future we will be able to do this transformation in the browser and print the PDF directly. Until then it's a two step process: Modifying the HTML we get from the XML file and running the HTML through Prince to get the PDF.</para>

    <h2>Modifying the HTML results</h2>

    <para>We'll use this opportunity to create an xslt customization layer to make changes only to the templates where we need to.</para>
    <para>We create a customization layer by importing the original stylesheet and making any necessary changes in the new stylesheet. Imported stylesheets have a lower precedence order than the local version so the local version will win if there is conflict.</para>
    <para>Only the templates defined in this stilesheet are overriden. If the template we use is not in this customization layer, the transformation engine will use the template in the base style sheet (book.xsl in this case)
    </para>
    <para>The style sheet is broken by templates and explained below.</para>
    <code language="xml"
      >&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;xsl:stylesheet xmlns:xs="http://www.w3.org/2001/XMLSchema"
  exclude-result-prefixes="xs" version="2.0">
  &lt;!--
      XSLT Paged Media Customization Layer Makes the necessary
      changes to the content to work with the Paged Media CSS
      stylesheet
  -->
  &lt;!-- First import the base stylesheet -->
  &lt;xsl:import href="book.xsl"/>

  &lt;!-- Define the output for this and all document children -->
  &lt;xsl:output name="xhtml-out" method="xhtml" indent="yes"
  encoding="UTF-8" omit-xml-declaration="yes" /> </code>

    <para>The first difference in the customization layer is that it imports another style sheet (
      <emphasis>book.xsl</emphasis>). We do this to avoid having to copy the entire style sheet and, if we make changes, having to make the changes in multiple places.</para>
    <para>We will then override the templates we need in order to get a single file to pass on to Prince or any other CSS Print Processor.</para>
    <code language="xml"
      >&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:xs="http://www.w3.org/2001/XMLSchema"
exclude-result-prefixes="xs"
version="2.0">

&lt;!-- First import the base stylesheet -->
&lt;xsl:import href="book.xsl"/>

&lt;!-- Define the output for this and all document children -->
&lt;xsl:output name="xhtml-out" method="xhtml" indent="yes"
  encoding="UTF-8" omit-xml-declaration="yes" />

&lt;!-- Root template matching book -->
&lt;xsl:template match="book">
  &lt;html>
    &lt;head>
      &lt;xsl:element name="title">
        &lt;xsl:value-of select="metadata/title"/>
      &lt;/xsl:element>
      &lt;!-- Paged Media Styles -->
      &lt;link rel="stylesheet" href="css/pm-style.css" />
      &lt;!-- Load Paged Media definitions just so I won't forget it again -->
      &lt;link rel="stylesheet" href="css/paged-media.css"/>
      &lt;!-- Use highlight.js and style -->
      &lt;xsl:if test="(code)">
        &lt;link rel="stylesheet" href="css/styles/railscasts.css" />
        &lt;!-- Load highlight.js -->
        &lt;script src="lib/highlight.pack.js">&lt;/script>
        &lt;script>
          hljs.initHighlightingOnLoad();
        &lt;/script>
      &lt;/xsl:if>
      &lt;!-- &lt;script src="js/script.js">&lt;/script> -->
    &lt;/head>
    &lt;body>
      &lt;xsl:attribute name="data-type">book&lt;/xsl:attribute>
      &lt;xsl:element name="meta">
          &lt;xsl:attribute name="generator">
            &lt;xsl:value-of select="system-property('xsl:product-name')"/>
            &lt;xsl:value-of select="system-property('xsl:product-version')"/>
          &lt;/xsl:attribute>
      &lt;/xsl:element>

      &lt;xsl:apply-templates select="/" mode="toc"/>
      &lt;xsl:apply-templates/>
    &lt;/body>
  &lt;/html>
&lt;/xsl:template> </code>

    <para>Most of the root template deals with undoing some of the changes we made to create multiple pages.</para>

    <para>We've changed the CSS we use to process the content. We use paged-media.css to create the content for our media files, mostly setting up the different pages based on the data-type attribute.</para>

    <para>We use pm-styles.css to control the style of our documents specifically for our printed page application. We have to take into account the fact that Highlight.js is not working properly with Prince's Javascript implementation and that there are places where we don't want our paragraphs to be indented at all.</para>

    <para>We moved elements from the original section templates. We test whether we need to add the Highlight.JS since we dropped the multipage output.
    </para>

    <h2>Overriding the section template</h2>
    <para>Sections are the element type that got the biggest makeover. What we've done:</para>
    <ulist>
      <item>Remove filename variable. It's not needed</item>
      <item>Remove the result document element since we are building a single file with all our content</item>
      <item>Change way we check for the type attribute in sections. It will now terminate with an error if the attribute is not found</item>
      <item>Add the element that will build our running footer (p class="rh") and assign the value of the secion's title to it</item>
    </ulist>
    <code language="xml"
      > &lt;!-- Override of the section template.-->
  &lt;xsl:template match="section">
    &lt;section>
      &lt;xsl:choose>
        &lt;xsl:when test="string(@type)">
          &lt;xsl:attribute name="data-type">
            &lt;xsl:value-of select="@type"/>
          &lt;/xsl:attribute>
        &lt;/xsl:when>
        &lt;xsl:otherwise>
          &lt;xsl:message terminate="yes">Type attribute is required for paged media. Check your section tags for missing type attributes &lt;/xsl:message>
        &lt;/xsl:otherwise>
      &lt;/xsl:choose>
      &lt;xsl:if test="string(@class)">
        &lt;xsl:attribute name="class">
          &lt;xsl:value-of select="@class"/>
        &lt;/xsl:attribute>
      &lt;/xsl:if>
      &lt;xsl:if test="string(@id)">
        &lt;xsl:attribute name="id">
          &lt;xsl:value-of select="@id"/>
        &lt;/xsl:attribute>
      &lt;/xsl:if>

      &lt;!--
        Running header paragraph. This will be take out of the regular flow
        of text so it doesn't matter if we add it or not
      -->
    &lt;xsl:element name="p">
      &lt;xsl:attribute name="class">rh&lt;/xsl:attribute>
      &lt;xsl:value-of select="title"/>
    &lt;/xsl:element> &lt;!-- closses rh class -->
    &lt;xsl:apply-templates/>
    &lt;/section>
  &lt;/xsl:template> </code>

    <h2>Metadata</h2>
    <para>The Metadata section has been reworked into a new section with the title data-type. We then apply all children templates.</para>


    <code language="xml"
      > &lt;!-- Metadata -->
      &lt;xsl:template match="metadata">
        &lt;xsl:element name="section">
          &lt;xsl:attribute name="data-type">titlepage&lt;/xsl:attribute>
          &lt;xsl:apply-templates/>
        &lt;/xsl:element>
      &lt;/xsl:template> </code>

    <h2>Titles and tables of content</h2>
    <para>The table of content is commented for now as I work on improving the content and placement of the table contents in the final document.</para>
    <para>The title element has only one addition. We add an ID attribute created using XPath's generate-id function on the parent section element.
    </para>
    <code language="xml"
      > &lt;!-- Create Table of Contents Work in progress-->
  &lt;xsl:template match="/" mode="toc"/>
    &lt;xsl:template match="title">
      &lt;xsl:element name="h1">
        &lt;xsl:attribute name="id">
          &lt;xsl:value-of select="generate-id(..)"/>
        &lt;/xsl:attribute>
      &lt;xsl:if test="string(@align)">
        &lt;xsl:attribute name="align">
          &lt;xsl:value-of select="@align"/>
        &lt;/xsl:attribute> &lt;/xsl:if>
      &lt;xsl:if test="string(@class)">
        &lt;xsl:attribute name="class">
          &lt;xsl:value-of select="@class"/>
        &lt;/xsl:attribute>
      &lt;/xsl:if>
      &lt;xsl:value-of select="."/>
    &lt;/xsl:element>
    &lt;!-- closes h1 -->
  &lt;/xsl:template>
&lt;/xsl:stylesheet> </code>
    <para>With all this in place we can now look to the CSS Paged Media file.
    </para>
  </section>

  <section type="chapter">
    <title>HTML To PDF, Part 2: CSS Paged Media</title>
    <para>With the HTML ready, we can no look at the CSS stylesheet to process it into PDF.</para>
    <para>The extensions, pseudo elements and attributes we use are all part of the CSS Paged Media or Generated Content for Paged Media specifications. Where appropriate I've translated them to work on both PDF and HTML.
    </para>
    <h2>Book defaults</h2>
    <para>The first step in creating the default structure for the book using `@page` at-element.</para>
    <para>Our base definition does the following:</para>
    <olist>
      <item>Size the page to letter (8.5 by 11 inches), width first</item>
      <item>Use CSS notation for margins. In this case the top and bottom margin are 0.5 inches and left and right are 1 inch</item>
      <item>Reset the footnote counter.</item>
      <item>Using the @footnote attribute do the following</item>
      <olist>
        <item>Increment the footnote counter</item>
        <item>Place footnote at the bottom using another value for the float attribute
        </item>
        <item>Span all columns</item>
        <item>Make the height as tall as necessary</item>
      </olist>
    </olist>
    <code language="css"
      > /* STEP 1: DEFINE THE DEFAULT PAGE */
@page {
  size: 8.5in 11in; (1)
  margin: 0.5in 1in; (2)
    /* Footnote related attributes */
    counter-reset: footnote; (3)
    @footnote {
      counter-increment: footnote; (4.1)
      float: bottom; (4.2)
      column-span: all; (4.3)
      height: auto; (4.4)
  }
} </code>
    <para>In later sections we'll create named page templates and associate them to different portions of our written content.</para>
    <h2>Page counters</h2>
    <para>We define two conditions under which we reset the page counter: When we have a book followed by a part and when we have a book followed by the a first chapter.</para>
    <para>We do <strong>not</strong> reset the content when the path if from book to chapter to part.</para>
    <code language="css"
      >/* PAGE COUNTERS */
body[data-type='book'] > div[data-type='part']:first-of-type,
body[data-type='book'] > section[data-type='chapter']:first-of-type { counter-reset: page; }
body[data-type='book'] > section[data-type='chapter']+div[data-type='part'] { counter-reset: none }</code>

    <h2>Matching content sections to page types</h2>
    <para>The next section of the style sheet is to match the content on our book to pages in our style sheet. </para>
    <para>The book is broken into sections with data-type attributes to indicate the type of content; we match the section[data-type] element to a page type along with some basic style definitions.</para>
    <para>We will further define the types of pages later in the style sheet.
    </para>
    <code language="css"
      >/* Title Page*/
section[data-type='titlepage'] { page: titlepage }

/* Copyright page */
section[data-type='copyright'] { page: copyright }

/* Dedication */
section[data-type='dedication'] {
  page: dedication;
  page-break-before: always;
}

/* TOC */
section[data-type='toc'] {
  page: toc;
  page-break-before: always;
}
/* Leader for toc page */
section[data-type='toc'] nav ol li a:after {
  content: leader(dotted) ' ' target-counter(attr(href, url), page);
}

/* Foreword  */
section[data-type='foreword'] { page: foreword }

/* Preface*/
section[data-type='preface'] { page: preface }

/* Part */
div[data-type='part'] { page: part }

/* Chapter */
section[data-type='chapter'] {
  page: chapter;
  page-break-before: always;
}

/* Appendix */
section[data-type='appendix'] {
  page: appendix;
  page-break-before: always;
}

/* Glossary*/
section[data-type='glossary'] { page: glossary }

/* Bibliography */
section[data-type='bibliography'] { page: bibliography }

/* Index */
section[data-type='index'] { page: index }

/* Colophon */
section[data-type='colophon'] { page: colophon }
</code>
    <h2>Front matter formatting</h2>
    <para>For each page of front matter contnt (toc, foreword and preface) we define two pages: left and right. We do it this way to acommodate facing pages with numbers on ooposite sides (for two sided printout)</para>
    <para>For the front matter we chose to use Roman numerals on the bottom of the page</para>
    <code language="css"
      >/* Comon Front Mater Page Numbering in lowercase ROMAN numerals*/
@page toc:right {
  @bottom-right-corner { content: counter(page, lower-roman) }
  @bottom-left-corner { content: normal }
}

@page toc:left  {
  @bottom-left-corner { content: counter(page, lower-roman) }
  @bottom-right-corner { content: normal }
}


@page foreword:right {
  @bottom-center { content: counter(page, lower-roman) }
  @bottom-left-corner { content: normal }
}

@page foreword:left  {
  @bottom-left-corner { content: counter(page, lower-roman) }
  @bottom-right-corner { content: normal }
}


@page preface:right {
  @bottom-center {content: counter(page, lower-roman)}
  @bottom-right-corner { content: normal }
  @bottom-left-corner { content: normal }
}
</code>
    <h2>Pages formatting</h2>
    <para>We use the same system we used in the front matter to do a few things with our content.</para>
    <para>We first remove page numbering from the title page and dedication by setting the numbering on both bottom corners to normal.</para>
    <code language="css"
      >/* Comon Front Mater Page Numbering in lowercase ROMAN numerals*/
@page toc:right {
  @bottom-right-corner { content: counter(page, lower-roman) }
  @bottom-left-corner { content: normal }
}

@page toc:left  {
  @bottom-left-corner { content: counter(page, lower-roman) }
  @bottom-right-corner { content: normal }
}


@page foreword:right {
  @bottom-center { content: counter(page, lower-roman) }
  @bottom-left-corner { content: normal }
}

@page foreword:left  {
  @bottom-left-corner { content: counter(page, lower-roman) }
  @bottom-right-corner { content: normal }
}


@page preface:right {
  @bottom-center {content: counter(page, lower-roman)}
  @bottom-right-corner { content: normal }
  @bottom-left-corner { content: normal }
}

@page preface:left  {
  @bottom-center {content: counter(page, lower-roman)}
  @bottom-right-corner { content: normal }
  @bottom-left-corner { content: normal }
}

/* Common Content Page Numbering  in Arabic numerals 1... 199 */
@page titlepage{ /* Need this to clean up page numbers in titlepage in Prince*/
  margin-top: 18em;
  @bottom-right-corner { content: normal }
  @bottom-left-corner { content: normal }
}

@page dedication { /* Need this to clean up page numbers in titlepage in Prince*/
  page-break-before: always;
  margin-top: 18em;
  @bottom-right-corner { content: normal }
  @bottom-left-corner { content: normal }

}
</code>

    <para>Now we start working on our chapter pages. The first thing we do is to place our running header content in the bottom middle of the page, regardless of whether it's left or right. </para>
    <code language="css"
      > @page chapter {
  @bottom-center {
    vertical-align: middle;
    text-align: center;
    content: element(heading);
  }
}</code>
    <para>We next setup a blank page for our chapters and tell the reader that the page was intentionally left blank to prevent confusion</para>

    <code language="css"
      >@page chapter:blank { /* Need this to clean up page numbers in titlepage in Prince*/
  @top-center { content: "This page is intentionally left blank" }
  @bottom-left-corner { content: normal;}
  @bottom-right-corner {content:normal;}
}
    </code>

    <para>Then we number the pages the same way that we did for our front matter except that we use narabic numerals instead of Roman. </para>

    <code language="css"
      >@page chapter:right  {
  @bottom-right-corner { content: counter(page) }
  @bottom-left-corner { content: normal }
}

@page chapter:left {
  @bottom-left-corner { content: counter(page) }
  @bottom-right-corner { content: normal }
}

@page appendix:right  {
  @bottom-right-corner { content: counter(page) }
  @bottom-left-corner { content: normal }
}

@page appendix:left {
  @bottom-left-corner { content: counter(page) }
  @bottom-right-corner { content: normal }
}

@page glossary:right,  {
  @bottom-right-corner { content: counter(page) }
  @bottom-left-corner { content: normal }
}

@page glossary:left, {
  @bottom-left-corner { content: counter(page) }
  @bottom-right-corner { content: normal }
}

@page bibliography:right  {
  @bottom-right-corner { content: counter(page) }
  @bottom-left-corner { content: normal }
}

@page bibliography:left {
  @bottom-left-corner { content: counter(page) }
  @bottom-right-corner { content: normal }
}

@page index:right  {
  @bottom-right-corner { content: counter(page) }
  @bottom-left-corner { content: normal }
}

@page index:left {
  @bottom-left-corner { content: counter(page) }
  @bottom-right-corner { content: normal }
}</code>

    <h2>Running footer</h2>

    <para>We now style the running footer. </para>

    <code language="css"
      > p.rh {
  position: running(heading);
  text-align: center;
  font-style: italic;
} </code>

    <h2>Footnotes and cross references</h2>
    <para>Footnotes are tricky, they consist of two parts, the footnote-call and the footnote content itself. I'm still trying to figure out what the correct markup should be for marking up footnotes.</para>
    <para>We've also defined a special class of links that appends a string and the the destination's page number.</para>
    <code language="css"
      >/* Footnotes */
span.footnote {
  float: footnote;
}

::footnote-marker {
  content: counter(footnote);
  list-style-position: inside;
}

::footnote-marker::after {
  content: '. ';
}

::footnote-call {
  content: counter(footnote);
  vertical-align: super;
  font-size: 65%;
}

/* XReferences */
a.xref[href]::after {
    content: ' [See page ' target-counter(attr(href), page) ']'
}
</code>

    <h2>PDF Bookmarks</h2>
    <para>PDF bookmarks allow you to navigate your content form the left side bookmark menu as show in the image below</para>
    <figure>
      <anchor />
      <image alt="PDF Bookmarks" height="396" src="images/pdf-bookmarks.png"
        width="274" />
      <figcaption>Example of PDF bookmarks</figcaption>
    </figure>
    <para>For each heading level we do the following things for both Antenna House and PrinceXML:</para>
    <ulist>
      <item>Set up the bookmark level</item>
      <item>Set up whether it's open or closed</item>
      <item>Set up the label for the bookmark</item>
    </ulist>
    <para>Only heading 1, 2 and 3 are set up, level 4, 5 and 6 are only set up as bookmarks only. </para>
    <code language="css"
      >/* PDF BOOKMARKS */
section[data-type='chapter'] h1 {
  -ah-bookmark-level: 1;
  -ah-bookmark-state: open;
  -ah-bookmark-label: content();
  prince-bookmark-level: 1;
  prince-bookmark-state: closed;
  prince-bookmark-label: content();
}

section[data-type='chapter'] h2 {
  -ah-bookmark-level: 2;
  -ah-bookmark-state: closed;
  -ah-bookmark-label: content();
  prince-bookmark-level: 2;
  prince-bookmark-state: closed;
  prince-bookmark-label: content();
}

section[data-type='chapter'] h3 {
  -ah-bookmark-level: 3;
  -ah-bookmark-state: closed;
  -ah-bookmark-label: content();
  prince-bookmark-level: 3;
  prince-bookmark-state: closed;
  prince-bookmark-label: content();
}

section[data-type='chapter'] h4 {
  -ah-bookmark-level: 4;
  prince-bookmark-level: 4;
}

section[data-type='chapter'] h5 {
  -ah-bookmark-level: 5;
  prince-bookmark-level: 5;
}

section[data-type='chapter'] h6 {
  -ah-bookmark-level: 6;
  prince-bookmark-level: 6;
}
</code>
    <h2>Running PrinceXML</h2>
    <para>Once we have the HTML file ready we can run it through
      <link
        href="http://www.princexml.com/" label="PrinceXML"
       /> to get our PDF using CSS stylesheet for Paged Media we discussed above. The command to run the conversion for a book.html file is:</para>
    <code language="bash"> $ prince --verbose book.html test-book.pdf </code>
    <para>Because we added the stylesheet link directly to the HTML document we can skip declaring it in the conversion itself. This is always a cause of errors and frustratoins for me so I thought I'd save everyone else the hassle.
    </para>
  </section>

  <section type="chapter">
    <title>CSS Styles for Paged Media</title>
    <para>This is the generated CSS from the SCSS style sheets (see the scss/ directory for the source material.) I've chosen to document the resulting stylesheet here and document the SCSS source in another document to make life simpler for people who don't want to deal with SASS or who want to see what the style sheets look like.</para>
    <para>Typography derived from work done at this URL:
      <link
        href="http://bit.ly/16N6Y2Q" label="http://bit.ly/16N6Y2Q" />
    </para>
    <para>The following scale (also using minor third progression) may also help:
      <link
        href="http://bit.ly/1DdVbqK" label="http://bit.ly/1DdVbqK" />
    </para>
    <para>Feel free to play with these and use them as starting point for your own work :)</para>
    <para>The project currently uses these fonts:</para>
    <ulist>
      <item>Roboto Slab for headings</item>
      <item>Roboto for body copy</item>
      <item>Source Code Pro for code blocks and preformated text</item>
    </ulist>
    <h2>Font Imports</h2>
    <para>Even though SCSS Lint throws a fit when I put font imports in a stylesheet because they stop asynchronous operations, I'm doing it to keep the HTML files clean and because we are not loading the CSS on the page, we're just using it to process the PDF file.</para>
    <para>Eventually I'll switch to locally hosted fonts using bulletproof font syntax (
      <link
        href="http://www.paulirish.com/2009/bulletproof-font-face-implementation-syntax/"
        label="discussed here" /> and available for use at
      <link
        href="http://www.fontsquirrel.com/tools/webfont-generator"
        label="Font Squirrel" />.)</para>
    <para>At this point we are not dealing with
      <link
        href="http://bit.ly/1ul3XBx" label="font subsetting"
       />) but we may in case we need to.</para>

    <code language="css"
      >@import url(http://fonts.googleapis.com/css?family=Roboto:100italic,100,400italic,700italic,300,700,300italic,400);
      @import url(http://fonts.googleapis.com/css?family=Roboto+Slab:400,700);
      @import url(http://fonts.googleapis.com/css?family=Source+Code+Pro:300,400); </code>


    <h2>Defaults</h2>
    <code language="css"
      >html {
  font-size: 16px;
  overflow-y: scroll;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
}

body {
  background-color: #fff;
  color: #554c4d;
  color: #554c4d;
  font-family: Adelle, Rockwell, Georgia, 'Times New Roman', Times, serif;
  font-size: 1em;
  font-weight: 100;
  line-height: 1.1;
  padding-left: 10em;
  padding-right: 10em;
}
</code>


    <h2>Blockquotes, Pullquotes and Marginalia</h2>
    <code language="css"
      >aside .lowlight {
  opacity: .3;
}
aside .lowlight :hover {
  opacity: 1;
}

aside h3 {
  padding-left: 20px;
  text-align: center;
}

aside {
  border-bottom: 3px double #ddd;
  border-top: 3px double #ddd;
  color: #666;
  font-size: 1.8em;
  line-height: 1.4em;
  padding-bottom: .5em;
  padding-top: .5em;
  width: 100%;
}
aside .pull {
  margin-bottom: .5em;
  margin-left: -20%;
  margin-top: .2em;
}

.opening {
  border-bottom: 3px double #ddd;
  border-top: 3px double #ddd;
  font-size: 2em;
  margin-bottom: 10em;
  padding-bottom: 2em;
  padding-top: 2em;
  text-align: center;
}

.margin-notes,
.content-left {
  font-size: .75em;
  margin-left: -230px;
  margin-right: 20px;
  text-align: right;
  width: 230px;
}

.margin-notes-right,
.content-right {
  font-size: .75em;
  margin-left: 760px;
  margin-right: -20px;
  position: absolute;
  text-align: left;
  width: 230px;
}

.content-right {
  font-size: .75em;
  margin-left: 760px;
  margin-right: -20px;
  position: absolute;
  text-align: left;
  width: 230px;
}

.content-right ul,
.content-left ul {
  list-style: none;
}

blockquote {
  color: #222023;
  font-size: 1.5em;
  font-style: italic;
  font-weight: 100;
  margin-bottom: 2em;
  margin-left: 4em;
  margin-right: 4em;
  margin-top: 2em;
}
blockquote p {
  padding-left: .5em;
}

.pullquote {
  border-bottom: 18px solid #000;
  border-top: 18px solid #000;
  font-size: 36px;
  font-weight: 700;
  letter-spacing: -.02em;
  line-height: 38px;
  margin-right: 100px;
  padding: 20px 0;
  position: relative;
  width: 200px;
}
.pullquote p {
  color: #00298a;
  font-weight: 700;
  position: relative;
  text-transform: uppercase;
  z-index: 1;
}
.pullquote p:last-child {
  line-height: 20px;
  padding-top: 2px;
}
.pullquote cite {
  color: #333;
  font-size: 18px;
  font-weight: 400;
}</code>

    <h2>Paragraphs</h2>

    <code language="css"
      >p {
  font-size: 1em;
  margin-bottom: 1.3em;
}
p + p {
  text-indent: 2em;
}

.first-line {
  font-size: 1.1em;
  text-indent: 0;
  text-transform: uppercase;
}

.first-letter {
  float: left;
  font-size: 7em;
  line-height: .8em;
  margin-bottom: -.1em;
  padding-right: .1em;
}</code>

    <h2>Lists</h2>
    <code language="css"
      > ul li {
  list-style: square;
}

ol li {
  list-style: decimal;
} </code>


    <h2>Figures and captions</h2>
    <code language="css"
      >figure {
  counter-increment: figure_count;
  margin-bottom: 1em;
  margin-top: 1em;
}
figure figcaption {
  font-weight: 700;
  padding-bottom: 1em;
  padding-top: .2em;
}
figure figcaption::before {
  content: "Figure " counter(figure_count) ": ";
}</code>

    <h2>Headings</h2>
    <code language="css"
      >h1,
h2,
h3,
h4 {
  font-family: 'Roboto Slab', sans-serif;
  font-weight: 400;
  line-height: 1.2;
  margin: 1.414em .5em;
  text-transform: uppercase;
}

h1 {
  font-size: 3.157em;
  margin-top: 0;
}

h2 {
  font-size: 2.369em;
}

h3 {
  font-size: 1.777em;
}

h4 {
  font-size: 1.333em;
}</code>

    <h2>Different parts of the book</h2>
    <code language="css"
      >section[data-type='titlepage'] h1,
section[data-type='titlepage'] h2 {
  text-align: center;
}
section[data-type='titlepage'] p {
  text-align: left;
}
section[data-type='titlepage'] p + p {
  text-indent: 0 !important;
}

section[data-type='dedication'] h1,
section[data-type='dedication'] h2 {
  text-align: center;
}
section[data-type='dedication'] p {
  text-indent: 0 !important;
}
</code>

    <h2>Preformatted code blocks</h2>
    <code language="css"
      >pre {
overflow-wrap: break-word;
white-space: pre-line !important;
word-wrap: break-word;
}

pre code {
  font-family: 'Source Code Pro', monospace;
  font-size: 1em;
  line-height: 1.2em;
  page-break-inside: avoid;
}
</code>

    <h2>Columns and miscelaneous classes</h2>
    <code language="css"
      >.justified {
  text-align: justify;
}

video {
  border: 1px solid #c5c5d0;
}

blockquote {
  color: #222023;
  font-size: 1.5em;
  font-weight: 300;
  margin: 2em 1.5em;
}

.columns2 {
  column-count: 2;
  column-gap: 3em;
  column-fill: balance;
  column-span: none;
  line-height: 1em;
  width: 100%;
}
.columns2 p:first-of-type {
  border-top: 0;
  margin-top: 0;
}
.columns2 p + p {
  text-indent: 2em;
}

.columns3 {
  column-count: 3;
  column-gap: 10px;
  column-fill: balance;
  column-span: none;
  width: 100%;
}
    </code>
  </section>

  <section type="chapter">
    <title>Task Automation with Grunt</title>

    <para>Because we use XML we can't just dump our code in the browser or the PDF viewer we need to prepare our content for conversion to PDF before we can view it. There are also front-end web development best practices to follow.</para>

    <para>This chapter will discuss tools to accomplish both tasks from one build file.</para>

    <h2>What software we need</h2>
    <para>For this to work you need the following software installed:</para>
    <ulist>
      <item>Java (version 1.7 or later)</item>
      <item>Node.js (0.10.35 or later)</item>
    </ulist>

    <para>Once you have java installed, you can install the following Java package</para>

    <ulist>
      <item>Saxon 9.0.6.4 for Java</item>
    </ulist>

    <para>A note about Saxon: OxygenXML comes with a version of Saxon Enterprise Edition. We'll use a different version to make it easier to use outside the editor.</para>

    <para>Node packages are handled through NPM, the Node Package Manager. On the Node side we need at least the `grunt-cli` package installed globally. TO do so we use this command:</para>

    <code language="bash"> $ npm install -g grunt-cli </code>

    <para>The -g flag will install this globally, as opposed to installing it in the project directory.</para>

    <para>Now that we have the required sotfware installed we can move ahead and create our configuration files.</para>

    <h2>Optional: Ruby, SCSS-Lint and SASS</h2>

    <para>The only external dependencies you need to worry about are Ruby, SCSS-Lint and SASS. Ruby comes installe in most (if not all) Macintosh and Linux systems; an <link
        href="http://rubyinstaller.org/) is also available"
        label="installer for Windows" />.</para>

    <para>SASS (syntactically awesome style sheets) are a superset of CSS that brings to the table enhancements to CSS that make life easier for designers and the people who have to create the stylesheets. I've taken advantage of these features to simplify my stylesheets and to save myself from repetitive and tedious tasks.</para>

    <para>SASS, the main tool, is written in Ruby and is available as a Ruby Gem.</para>

    <para>To install SASS, open a terminal/command window and type:</para>

    <code language="bash"> $ gem install sass </code>

    <para>Note that on Mac and Linux you may need to run the command as a superuser. If you get an error, try the following command:</para>

    <code language="bash"> $ sudo gem install sass </code>

    <para>and enter your password when prompted.</para>

    <para>SCSS-Lint is a linter for the SCSS flavor of SASS. As with other linters it will detect errors and potential erors in your SCSS style sheets. As with SASS, SCSSLint is a Ruby Gem that can be installed with the following command:</para>
    <code language="bash"> $ sudo gem install scss-lint </code>

    <para>The same caveat about errors and installing as an administrator apply.</para>

    <blockquote>
      <para>Ruby, SCSS-Lint and SASS are only necessary if you plan to change the SCSS/SASS files. If you don't you can skip the Ruby install and work directly with the CSS files</para>
      <para>If you want to peek at the SASS source look at the files under the scss directory.</para>
    </blockquote>
    <h2>Installing Node packages</h2>
    <para>Grunt is a Node.js based task runner. It's a declarative version of Make and similar tools in other languages. Since Grunt and it's associated plugins are Node Packages we need to configure Node.</para>
    <para>At the root of the project there's a `package.json` file where all the files necessary for the project have already been configured. All that is left is to run the install command.</para>
    <code language="bash"> $ npm install </code>
    <para>This will install all the packages indicated in configuration file and all their dependencies; go get a cup of coffee as this may take a while in slower machines.</para>
    <para>As it installs the software it'll display a list of what it installed and when it's done you'll have all the packages.</para>
    <para>The final step of the node installation is to run bower, a front end package manager. It is not configured by default but you can use it to manage packages such as jQuery, Highlight.JS, Polymer web components and others.
    </para>
    <h2>Grunt &amp; Front End Development best practices</h2>
    <para>While developing the XML and XSL for this project, I decided that it was also a good chance to test front end development tools and best practices for styling and general front end development.</para>
    <para>One of the best known tools for front end development is Grunt. It is a Javascript task runner and it can do pretty much whatever you need to do in your development environment. The fact that Grunt is written in Javascript saves developers from having to learn another language for task management.
    </para>
    <para>Grunt has its own configuration file (`Gruntfile.js`) one of which is provided as a model for the project.</para>
    <para>As currently written the Grunt file provides the following functionality in the assigned tasks. Please note that the tasks with an asterisk have subtasks to perform specific functions. We will discuss the subtasks as we look at each portion of the file and its purpose.</para>
    <code language="bash"
      >Available tasks
      autoprefixer  Prefix CSS files. *
             clean  Clean files and folders. *
            coffee  Compile CoffeeScript files into JavaScript *
              copy  Copy files. *
            jshint  Validate files with JSHint. *
              sass  Compile Sass to CSS *
            uglify  Minify files with UglifyJS. *
             watch  Run predefined tasks whenever watched files change.
          gh-pages  Publish to gh-pages. *
    gh-pages-clean  Clean cache dir
             mkdir  Make directories. *
          scsslint  Validate `.scss` files with `scss-lint`. *
             shell  Run shell commands *
              sftp  Copy files to a (remote) machine running an SSH daemon. *
           sshexec  Executes a shell command on a remote machine *
             uncss  Remove unused CSS *
              lint  Alias for "jshint" task.
          lint-all  Alias for "scsslint", "jshint" tasks.
          prep-css  Alias for "scsslint", "sass:dev", "autoprefixer" tasks.
           prep-js  Alias for "jshint", "uglify" tasks.
      generate-pdf  Alias for "shell:single", "shell:prince" tasks.
 generate-pdf-scss  Alias for "scsslint", "sass:dev", "shell:single",
                    "shell:prince" tasks.
      generate-all  Alias for "shell" task.</code>

    <h2>Setup</h2>
    <para>The first thing we do is declare two variables (module and require) as global for JSLint and JSHint. Otherwise we'll get errors and it's not essential to declare them before they are used.</para>
    <para>We then wrap the Gruntfile with a self executing function as a deffensive coding strategy.</para>
    <para>When concatenating Javascript files there may be some that use strict Javascript and some that don't; With Javascript <link
        href="http://code.tutsplus.com/tutorials/javascript-hoisting-explained--net-15092"
        label="vriable hoisting"
       /> the use stric declaration would be placed at the very top of the concatenated file making all the scripts underneat use the strict declaration.</para>
    <para>When concatenating Javascript files there may be some that use strict Javascript and some that don't; With Javascript
      <link
        href="http://code.tutsplus.com/tutorials/javascript-hoisting-explained--net-15092"
        label="vriable hoisting"
       /> the use stric declaration would be placed at the very top of the concatenated file making all the scripts underneat use the strict declaration.</para>
    <para>The function wrap prevents this by making the use strict declaration local to the file where it was written. None of the other templates will be affected and they will still execute from the master stylesheet. It's not essential for Grunt drivers (Gruntfile.js in our case) but it's always a good habit to get into.</para>
    <code language="javascript"
      >/*global module */
/*global require */
(function () {
  'use strict';
  module.exports = function (grunt) {
    // require it at the top and pass in the grunt instance
    // it will measure how long things take for performance
    //testing
    require('time-grunt')(grunt);

    // load-grunt will read the package file and automatically
    // load all our packages configured there.
    // Yay for laziness
    require('load-grunt-tasks')(grunt);</code>
    <para>The first two elements that work with our content are
      <emphasis>time-grunt</emphasis> and
      <emphasis>load-grunt-tasks</emphasis>.</para>
    <para>Time-grunt provides a breakdown of time and percentage of total execution time for each task performed in this particular Grunt run. The example below illustrates the result when running multiple tasks.</para>
    <code language="bash"
      > Execution Time (2015-02-01 03:43:57 UTC)
  loading tasks 983ms ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 12%
  scsslint:allFiles 1.1s ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 13%
  sass:dev 441ms ▇▇▇▇▇▇▇▇▇ 5%
  shell:html 1.5s ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 18%
  shell:single 1.2s ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 14%
  shell:prince 2.9s ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 36%
  Total 8.1s </code>
    <para>Load-grunt-tasks automates the loading of packages located in the `package.json` configuration file. It's specially good for forgetful people like me whose main mistake when building Grunt-based tool chains is forgetting to load the plugins to use :-).</para>

    <h2>Javascript</h2>
    <code language="javascript"
      >    grunt.initConfig({

      // JAVASCRIPT TASKS
      // Hint the grunt file and all files under js/
      // and one directory below
      jshint: {
        files: ['Gruntfile.js', 'js/{,*/}*.js'],
        options: {
          reporter: require('jshint-stylish')
            // options here to override JSHint defaults
        }
      },

      // Takes all the files under js/ and selected files under lib
      // and concatenates them together. I've chosen not to mangle
      // the compressed file
      uglify: {
        dist: {
          options: {
            mangle: false,
            sourceMap: true,
            sourceMapName: 'css/script.min.map'
          },
          files: {
            'js/script.min.js': ['js/video.js', 'lib/highlight.pack.js']
          }
        }
      },</code>

    <para>JSHint will lint the Gruntfile itself and all files under the js/ directory for errors and potential errors. </para>

    <code language="bash"
      >$ grunt jshint
Running "jshint:files" (jshint) task
Gruntfile.js
      line 9 col 33 Missing semicolon.
      line 269 col 6 Missing semicolon.

      ⚠ 2 warnings

Warning: Task "jshint:files" failed. Use --force to continue.
Aborted due to warnings. </code>
    <para>Uglify allow us to concatenate our Javascript files and, if we choose to, further reduce the file size by mangling the code (See this [page](http://lisperator.net/uglifyjs/mangle) for an explanation of what mangle is and does). I've chosen not to mangle the code to make it easier to read. May add it as an option for production deployments.</para>

    <h2>SASS and CSS</h2>
    <para>As mentioned elsewhere I chose to use the SCSS flavor of SASS because it allows me to do some awesome things with CSS that I wouldn't be able to do with CSS alone. </para>
    <para>The first task with SASS is convert it to CSS. For this we have two separate tasks. One for development (dev task below) where we pick all the files from the scss directory (the entire files section is equivalent to writing
      <emphasis>scss/*.scss</emphasis>) and converting them to files with the same name in the css directory. </para>
    <code language="javascript"
      >      // SASS RELATED TASKS
      // Converts all the files under scss/ ending with .scss
      // into the equivalent css file on the css/ directory
      sass: {
        dev: {
          options: {
            style: 'expanded'
          },
          files: [{
            expand: true,
            cwd: 'scss',
            src: ['*.scss'],
            dest: 'css',
            ext: '.css'
          }]
        },
        production: {
          options: {
            style: 'compact'
          },
          files: [{
            expand: true,
            cwd: 'scss',
            src: ['*.scss'],
            dest: 'css',
            ext: '.css'
          }]
        }
      },</code>
    <para>There are two similar versions of the task. The development version will produce the format below, which is easier to read and easier to troubleshoot (css-lint, discussed below, tells you what line the error or warning happened in.)</para>
    <code language="css"
      >@import url(http://fonts.googleapis.com/css?family=Roboto:100italic,100,400italic,700italic,300,700,300italic,400);
@import url(http://fonts.googleapis.com/css?family=Montserrat:400,700);
@import url(http://fonts.googleapis.com/css?family=Roboto+Slab:400,700);
@import url(http://fonts.googleapis.com/css?family=Source+Code+Pro:300,400);
html {
  font-size: 16px;
  overflow-y: scroll;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
}

body {
  background-color: #fff;
  color: #554c4d;
  color: #554c4d;
  font-family: Adelle, Rockwell, Georgia, 'Times New Roman', Times, serif;
  font-size: 1em;
  font-weight: 100;
  line-height: 1.1;
  padding-left: 10em;
  padding-right: 10em;
}</code>
    <para>The production code compresses the output. It deletes all tabs and carriage returns to produce cod elike the one below. It reduces the file size by eliminating spaces, tabs and carriage returns inside the rules, otherwise both versions are equivalent.</para>
    <code language="css"
      >@import url(http://fonts.googleapis.com/css?family=Roboto:100italic,100,400italic,700italic,300,700,300italic,400);
@import url(http://fonts.googleapis.com/css?family=Montserrat:400,700);
@import url(http://fonts.googleapis.com/css?family=Roboto+Slab:400,700);
@import url(http://fonts.googleapis.com/css?family=Source+Code+Pro:300,400);
html { font-size: 16px; overflow-y: scroll; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }

body { background-color: #fff; color: #554c4d; color: #554c4d; font-family: Adelle, Rockwell, Georgia, 'Times New Roman', Times, serif; font-size: 1em; font-weight: 100; line-height: 1.1; padding-left: 10em; padding-right: 10em; }
    </code>
    <para>I did consider adding
      <link
        href="https://github.com/gruntjs/grunt-contrib-cssmin" label="cssmin"
       /> but decided against it for two reasons:</para>
    <ulist>
      <item>SASS already concatenates all the files when it imports files from the modules and partials directory so we're only working with one file for each version of the project (html and PDF)</item>
      <item>The only other file we'd have to add, normalize.css, is a third party library that I'd rather leave along rather than mess with.</item>
    </ulist>
    <para>The
      <emphasis>scsslint</emphasis> task is a wrapper for the scss-lint Ruby Gem that must be installed on your system. It warns you of errors and potential errors in your SCSS stylesheets.</para>
    <para>We've chosen to force it to run when it finds errors. We want the linting tasks to be used as the developer's discretion, there may be times when vendor prefixes have to be used or where colors have to be defined multiple times to acommodate older browsers. </para>
    <code language="javascript"
      >      // I've chosen not to fail on errors or warnings.
      scsslint: {
        allFiles: [
          'scss/*.scss',
          'scss/modules/_mixins.scss',
          'scss/modules/_variables.scss',
          'scss/partials/*.scss'
        ],
        options: {
          config: '.scss-lint.yml',
          force: true,
          colorizeOutput: true
        }
      },</code>
    <para>Grunt's
      <link
        href="https://github.com/nDmitry/grunt-autoprefixer"
        label="autoprefixer" /> task uses the
      <link
        href="http://caniuse.com/" label="CanIUse"
       /> database to determine if properties need a vendor prefix and add the prefix if they do.</para>
    <para>This becomes important for older browsers or when vendors drop their prefix for a given property. Rather than having to keep up to date on all vendor prefixed properties you can tell autoprefixer what browsers to test for (last 2 versions in this case) and let it worry about what needs to be prefixed or not.</para>
    <code language="javascript"
      >      autoprefixer: {
        options: {
          browsers: ['last 2']
        },

        files: {
          expand: true,
          flatten: true,
          src: 'scss/*.scss',
          dest: 'css/'
        }
      },
</code>
    <para>The last css task is the most complicated one.
      <link
        href="https://github.com/addyosmani/grunt-uncss" label="Uncss"
       /> takes out whatever CSS rules are not used in our target HTML files.</para>
    <code language="javascript"
      >      // CSS TASKS TO RUN AFTER CONVERSION
      // Cleans the CSS based on what's used in the specified files
      // See https://github.com/addyosmani/grunt-uncss for more
      // information
      uncss: {
        dist: {
          files: {
            'css/tidy.css': ['*.html', '!docs.html']
          }
        }
      },</code>
    <para>This is not a big deal for our workflow as most, if not all, the CSS is designed for the tags and classes we've implemented but it's impossible for the SASS/CSS libraries to grow over time and become bloated.</para>
    <para>This will also become and issue when you decide to include third part libraries in projects implemented on top of our workflow. By running Uncss on all our HTML files except the file we'll pass to our PDF generator (docs.html) we can be assured that we'll get the smallest css possible.
    </para>
    <para>We skip out PDF source html file because I'm not 100% certain that Uncss can work with Paged Media CSS extensions. Better safe than sorry. </para>

    <h2>Optional tasks</h2>
    <para>I've also created a set of optional tasks that are commented in the Grunt file but have been uncommented here for readability. </para>
    <para>The first optional task is a Coffeescript compiler.
      <link
        href="http://coffeescript.org/" label="Coffeescript"
       /> is a scripting language that provides a set of useful features and that compiles directly to Javascript. </para>
    <para>I some times use Coffeescript to create scripts and other interactive content so it's important to have the compilation option available.</para>
    <code language="javascript"
      >       // OPTIONAL TASKS
       // Tasks below have been set up but are currently not used.
       // If you want them, uncomment the corresponding block below

       // COFFEESCRIPT
       // If you want to use coffeescript (http://coffeescript.org/)
       // instead of vanilla JS, uncoment the block below and change
       // the cwd value to the locations of your coffee files
       coffee: {
        target1: {
          expand: true,
          flatten: true,
          cwd: 'src/',
          src: ['*.coffee'],
          dest: 'build/',
          ext: '.js'
      },</code>
    <para>The following two tasks are for managing file transfers and uploads to different targets.</para>
    <para>One of the things I love from working on Github is that your project automatically gets an ssl-enabled site for free.
      <link
        href="https://pages.github.com/" label="Github Pages"
       /> work with any kind of static website; Github even offers an automatic site generator as part of our your project site.</para>
    <para>For the puposes of our workflow validation we'll make a package of our content in a build directory and push it to the gh-pages branch of our repository. We'll look at building our app directory when we look at copying files.</para>
    <code language="javascript"
      >      // GH-PAGES TASK
      // Push the specified content into the repositories gh-pages branch
      'gh-pages': {
        options: {
          message: 'Content committed from Grunt gh-pages',
          base: './build/app',
          dotfiles: true
        },
        // These files will get pushed to the `
        // gh-pages` branch (the default)
        // We have to specifically remove node_modules
        src: ['**/*']
      },
    </code>

    <para>There are times when we are not working with Github or pages. In this case we need to FTP or SFTP (encrypted version of FTP) to push files to remote servers. We use an external json file to store our account information. Ideally we'd encrypt the information but until then using the external file is the first option. </para>

    <code language="javascript"
      >       //SFTP TASK
      //Using grunt-ssh (https://www.npmjs.com/package/grunt-ssh)
      //to store files in a remote SFTP server. Alternative to gh-pages
      secret: grunt.file.readJSON('secret.json'),
      sftp: {
        test: {
          files: { "./": "*.json" },
          options: {
            path: '/tmp/',
            host: '&lt;%= secret.host %>',
            username: '&lt;%= secret.username %>',
            password: '&lt;%= secret.password %>',
            showProgress: true
          }
        }
      },</code>

    <h2>File Management</h2>
    <para>We've taken a few file management tasks into Grunt to make our lifes easier. The functions are for:</para>
    <ulist>
      <item>Creating directories</item>
      <item>Copying files</item>
      <item>Deleting files and directories</item>
    </ulist>
    <para>We will use the mkdir and copy tasks to create a build directory and copy all css, js and html files to the build directory. We will then use the gh-pages task (described earlier) to push the content to the repository's gh-pages branches</para>
    <code language="javascript"
      >      // FILE MANAGEMENT
      // Can't seem to make the copy task create the directory
      // if it doesn't exist so we go to another task to create
      // the fn directory
      mkdir: {
        build: {
          options: {
            create: ['build']
          }
        }
      },

      // Copy the files from our repository into the build directory
      copy: {
        build: {
          files: [{
            expand: true,
            src: ['app/**/*'],
            dest: 'build/'
          }]
        }
      },

      // Clean the build directory
      clean: {
        production: ['build/']
      },</code>

    <h2>Watch task</h2>
    <para>Rather than type a command over and over again we can set up watchers so that, any time a file of the indicated type changes, we perform specific tasks. </para>
    <para>As currentlly configured we track Javascript and SASS files.</para>
    <para>For Javascript files anytime that the Gruntfile or any file under the Javascript directorie we run the JSHint task to make sure we haven't made any mistakes.</para>
    <para>For our SASS/SCSS files, any files under the scss directory, we run the sass:dev task to translate the files to CSS. </para>
    <code language="javascript"
      >       // WATCH TASK
      // Watch for changes on the js and scss files and perform
      // the specified task
      watch: {
        options: {
          nospawn: true
        },
        // Watch all javascript files and hint them
        js: {
          files: ['Gruntfile.js', 'js/{,*/}*.js'],
          tasks: ['jshint']
        },
        sass: {
          files: ['scss/*.scss'],
          tasks: ['sass']
        }
      }, </code>

    <h2>Compile and Execute</h2>
    <para>Rather than using Ant, I've settled on Grunt's shell task to run the compilation steps to create HTML and PDF. This reduces teh number of dependecies for our project and makes it easier to consolidate all the work.
    </para>
    <para>We have three different commands:</para>
    <ulist>
      <item>html will create multiple html files using Saxon, a Java XSLT processor
      </item>
      <item>single will create a single html file using Saxon</item>
      <item>prince will create a PDF based on the single html file using PrinceXML
      </item>
    </ulist>
    <para>We make sure that we don't continue if there is an error. Want to make sure that we troubleshoot before we get all the resulting files.</para>
    <code language="javascript"
      >       // COMPILE AND EXECUTE TASKS
      // rather than using Ant, I've settled on Grunt's shell
      // task to run the compilation steps to create HTML and PDF.
      // This reduces teh number of dependecies for our project
      shell: {
        options: {
          failOnError: true,
          stderr: false
        },
        html: {
          command: 'java -jar /usr/local/java/saxon.jar -xsl:xslt/book.xsl docs.xml -o:index.html'
        },
        single: {
          command: 'java -jar /usr/local/java/saxon.jar -xsl:xslt/pm-book.xsl docs.xml -o:docs.html'
        },
        prince: {
          command: 'prince --verbose --javascript docs.html -o docs.pdf'
        }
      }


    }); // closes initConfig</code>

    <h2>Custom Tasks</h2>
    <para>The custom task uses one or more of the tasks defined above to accomplish a sequence of tasks.</para>
    <para>Look at specific tasks defined above for specific definitions.</para>
    <code language="javascript"
      >    // CUSTOM TASKS
    // Usually a combination of one or more tasks defined above
    grunt.task.registerTask(
      'lint',
      [
        'jshint'
      ]
    );

    grunt.task.registerTask(
      'lint-all',
      [
        'scsslint',
        'jshint'
      ]
    );

    // Prep CSS starting with SASS, autoprefix et. al
    grunt.task.registerTask(
      'prep-css',
      [
        'scsslint',
        'sass:dev',
        'autoprefixer'
      ]
    );

    grunt.task.registerTask(
      'prep-js',
      [
        'jshint',
        'uglify'
      ]
    );

    grunt.task.registerTask(
      'generate-pdf',
      [
        'shell:single',
        'shell:prince'
      ]
    );

    grunt.task.registerTask(
      'generate-pdf-scss',
      [
        'scsslint',
        'sass:dev',
        'shell:single',
        'shell:prince'
      ]
    );

    grunt.task.registerTask(
      'generate-all',
      [
        'shell'
      ]
    );


  }; // closes module.exports
}()); // closes the use strict function</code>
  </section>

  <section type="chapter">
    <title>Things to Do and Further Research</title>
    <para>These are the things I want to look at after finishing mvp.</para>
    <h2>Deep Linking using Emphasis</h2>
    <para>The NYT developed a deep linking library called Emphasis (
      <link
        href="https://github.com/NYTimes/Emphasis" label="code" /> -
      <link
        href="http://open.blogs.nytimes.com/2011/01/11/emphasis-update-and-source/"
        label="writeup"
       /> that would allow us to create links to specific areas of our content.</para>
    <para>Downside is that it uses jQuery and I'm not certain I want to go through the pain in the ass process of converting it to plain JS or ES6 (and if it's even possible)</para>
    <para>Still, if we use jQuery for something else (video manipulation?) it may be worth exploring both as a sharing tool and as a technology.</para>
    <para>One thing it doesn't do is handle mobile well, if at all. How do we make this tool work everywhere?
      <link
        href="http://www.w3.org/TR/pointerevents/" label="Pointer Events"
       />?</para>
    <h2>Explore how to add other parts of a book structure</h2>
    <para>Right now we're working with chapters and chapter-like structures. What would it take to add parts? Do we need to add them to the schema and let them trickle from there? Do we really need them?</para>
    <h2>Build Media Queries</h2>
    <para>Particularly if we want to use the same XSLT and CSS for mutliple projects we need to be able to tailor the display for different devices and viewports.</para>
    <para>Media Queries are the best solution (or are they?)</para>
    <h2>Using XSLT to build navigation</h2>
    <para>The same way we build the table of content should allow us to build navigation within the pages of a publication using preceeding-sibling and following-sibling logic</para>
    <h2>Create a better way to generate filenames</h2>
    <para>The current way to create filenames doesn't take into account that different
      <emphasis>section/@type</emphasis> elements have different starting values. Can I make it start from 1 for every @type in the document?
    </para>
    <h2>Expand the use cases for this project</h2>
    <para>The original idea was for text and code-heavy content. Is there a case to be made for a more expressive vocabulary? I'm thinking of additional elements for navigation and content display such as asides and blockquotes
    </para>
    <h2>Explore implementing a serviceworker solution</h2>
    <video controls="conrtrols" height="360" width="640">
      <source src="video/serviceworker.mp4" type="video/mp4" />
    </video>
    <para>The core of the proposed offline capabilities is a scoped service worker that will initially handle the caching of the publication's content. We take advantage of the multiple cache capabilitity available with service workers to create caches for individual unitts of content (like magazine issues) and to expire them within a certain time period (by removing and deleting the cache).</para>
    <para>For publications needing to pull data from specific URLs we can special case the requests based on different pieces of the URL allowing to create different caches based on edition (assuming each edition is stored in its own directory), resource type or even the URL we are requesting.
    </para>
    <para>Serviceworkers have another benefit not directly related with offline connections. They will give all access to our content a speed boost by eliminating the network roundtrip after the content is installed. If the content is in the cache, the resource's time to load is only limited by the Hard Drive's speed.</para>
    <h3>Limitations</h3>
    <para>As powerful as service workers are they also have some drawbacks. They can only be served through HTTPS (you cannot install a service worker in a non secure server) to prevent
      <link
        href="http://www.wikiwand.com/en/Man-in-the-middle_attack"
        label="man-in-the-middle attacks" />.</para>
    <para>There is limited support for the API (only Chrome Canary and Firefox Nightly builds behind a flag will work.) This will change as the API matures and becomes finalized in the WHATWG and/or a recommendation with the W3C.</para>
    <para>Even in browsers that support the API the support is not complete. Chrome uses a polyfill for elements of the cache API that it does not support natively. This should be fixed in upcoming versions of Chrome and Chromium (the open source project Chrome is based on.)</para>
    <para>We need to be careful with how much data we choose to store in the caches. From what I understand the ammount of storage given to offline applications is divided between all offline storage types: IndexedDB, Session Storage, Web Workers and ServiceWorkers and this amount is not consistent across all browsers.</para>
    <para>Furthermore I am not aware of any way to increase this total amount or to specifically increase the storage assigned to ServiceWorkers; Jake Archibald mentions this in the offline cookbook section on
      <link
        href="http://jakearchibald.com/2014/offline-cookbook/#cache-persistence"
        label="cache persistence" />
    </para>
    <h2>Implementing Graphic Callouts</h2>
    <para>What would it take to get callouts to use graphics like Docbook?
    </para>
    <para>It would take the following:</para>
    <ulist>
      <item>Create a new element (callout)</item>
      <item>Add the callout element to the code data model</item>
    </ulist>
    <para>This would work for code, but not necessarily for images or other elements that need callouts</para>
  </section>
  <section type="bibliography">
    <title>Annotated Bibliography</title>
  </section>
</book>
