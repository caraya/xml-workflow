<?xml version="1.0" encoding="UTF-8"?>
<book xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="xsd/book-schema-draft.xsd">
    <metadata>
        <title>XML workflow documentation</title>

        <authors>
            <author>
                <first-name>Carlos</first-name>
                <surname>Araya</surname>
            </author>
        </authors>

        <para>Thanks to Laura Brady for getting this particular idea started :)</para>

        <para>I'm dogfooding my XML workflow for digital publishing, there are certainly bugs remaining. Please let me know if you find any</para>
    </metadata>
    <section type="chapter">
      <title>Converting our content to HTML</title>

      <para>One of the biggest advantages of working with XML is that we can convert the abstract tags into other markups. For the purposes of this project we'll convert the XML created to match the schema we just created to HTML and then use tools like <link href="http://www.princexml.com" label="PrinceXML"/> or <link href="http://www.antennahouse.com" label="AntenaHouse"/> we'll convert the HTML/CSS files to PDF</para>

      <h2>Why HTML</h2>

      <para>HTML is the default format for the web and for most web/html based content such as ePub and Kindle. As such it makes a perfect candidate to explore how to generate it programatically from a single source file.</para>

      <para>HTML will also act as our source for using CSS paged media to create PDF cotnent.</para>

      <h2>Why PDF</h2>

      <para>Rather than having to deal with <link href="http://www.w3.org/TR/2006/REC-xsl11-20061205/" label="XSL-FO"/>, another XML based vocabulary to create PDF content, we'll use XSLT to create another HTML file and process it with <link href="http://dev.w3.org/csswg/css-page-3/" label="CSS Paged Media"/> and the companion <link href="http://www.w3.org/TR/css-gcpm-3/" label="Generated Content for Paged Media"/> specifications to create PDF content.</para>

      <para>In this document we'll concentrate on the XSLT to HTML conversion and will defer the conversion from HTML to PDF to a later article.</para>

      <h1>Creating our conversion stylesheets</h1>

      <para>To convert our XML into other formats we will use XSL Transformations (also known as XSLT) <link href="http://www.w3.org/TR/xslt" label="version 2"/> (a W3C standard) and <link href="http://www.w3.org/TR/xslt-30/" label="version 3"/> (a W3C last call draft recommendation) where appropriate.</para>

      <para>XSLT is a functional language designed to transform XML into other markup vocabularies. It defines template rules that match elements in your source document and processing them to convert them to the target vocabulary.</para>

      <para>In the XSLT example below, we do the following:</para>

      <olist>
          <item>match the root element to create the skeleton for our HTML content</item>
          <item>In the title we insert the content of the `metadata/title` element</item>
          <item>In the body we 'apply' the templates that match the content inside our document (more on this later)</item>
      </olist>

      <code language="xml">
      &lt;?xml version="1.0" ?>
      <!-- Define stylesheet root and namespaces we'll work with -->
      &lt;xsl:stylesheet
          xmlns="http://www.w3.org/1999/xhtml"
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
          xmlns:dc="http://purl.org/dc/elements/1.1/"
          xml:lang="en-US"
          version="2.0">

          &lt;xsl:template match="/">
              &lt;html>
                  &lt;head>
                     &lt;title>&lt;xsl:value-of select="metadata/title"/>&lt;/title>
                      &lt;link rel="stylesheet" href="css/style.css"/>
                      &lt;script src="js/script.js">&lt;/script>
                  &lt;/head>
                  &lt;body>
                    &lt;xsl:apply-templates/>
                  &lt;/body>
              &lt;/html>
          &lt;/xsl:template>
      &lt;/xsl:stylesheet>
      </code>

      <para>We could build the CSS stylesheet as part of our root element but I choose not to do so. Working with the stylesheet as part of the XSLT stylesheet allows the XSLT stylesheet designer to embed the style and parameterize the stylesheet, thus making the stylesheet customizable from the command line.</para>

      <para>For all advantages, this method ties the styles for the project to the XSLT stylesheet and requires the XSLT stylesheet designer to be involved in all CSS updates. </para>

      <para>By linking to external CSS and Javascript files we can leverage expertise independent of the Schema and XSLT stylesheets. Book designers can work on the CSS, UX and experience designers can work on Javascript and additional CSS areas, book designers can work on the Paged Media stylesheets and authors can just write.</para>

      <para>Furthermore we can reuse our CSS and Javascript on multiple documents.</para>

      <h2>Working on content with XSLT</h2>

      <para>Once we have defined the structure of the document structure we can start building the rendering of our content.</para>

      <para>The first thing we'll do is to define the output for our master document and all the files that will be generated from our style sheet.</para>

        <code language="xml">
        <!-- Define the output for this and all document children -->
        &lt;xsl:output name="xhtml-out" method="xhtml" indent="yes"
            encoding="UTF-8" omit-xml-declaration="yes" />
        </code>

        <para>We will being with the major areas of the document, `metadata` and `section`. The metadata is a container for all the elements inside. As such we just create the div that will hold the content and call `xsl:apply-templates` to process the content inside the metadata element.</para>

        <code language="xml">
        &lt;xsl:template match="metadata" mode="content">
            &lt;div class="metadata">
                &lt;xsl:apply-templates/>
            &lt;/div>
        &lt;/xsl:template>
       </code>

       <para>The <emphasis>section</emphasis> element is hardest to wrap your head around</para>

       <code language="xml">
         &lt;xsl:template match="section" mode="content">
            <!--
              Each section element will generate its own file

              We create the file name by concatenating the type attribute
              for the section, the count of how many sections of that type
              there are and the .xhtml extension
            -->
            &lt;xsl:variable name="fileName"
                select="concat(section/@type, count(section),'.xhtml')"/>
            &lt;!-- An example result of the variable above would be introduction1.xhtml -->
            &lt;xsl:apply-templates/>
            &lt;xsl:if test="(@class)">
              &lt;xsl:attribute name="class">
                &lt;xsl:value-of select="@class"/>
              &lt;/xsl:attribute>
            &lt;/xsl:if>
            &lt;xsl:if test="(@id)">
              &lt;xsl:attribute name="id">
                &lt;xsl:value-of select="@id"/>
              &lt;/xsl:attribute>
            &lt;/xsl:if>
            &lt;xsl:result-document href='${fileName}' format="xhtml-out">
              &lt;section>
                &lt;xsl:apply-templates/>
              &lt;/section>
            &lt;/xsl:result-document>
         &lt;/xsl:template>
      </code>
    </section>

    <section type="chapter">
      <title>Converting HTML to PDF</title>

      <para>Rather than having to deal with <link href="http://www.w3.org/TR/2006/REC-xsl11-20061205/" label="XSL-FO"/>, another XML based vocabulary to create PDF content, we'll use XSLT to create another HTML file and process it with <link href="http://dev.w3.org/csswg/css-page-3/" label="CSS Paged Media"/> and the companion <link href="http://www.w3.org/TR/css-gcpm-3/" label="Generated Content for Paged Media"/> specifications to create PDF content.</para>

      <para>I'm not against XSL-FO but the structure of document is not the easiest or most intuitive. An example of XSL-FO looks like this:</para>

      <code language="xml">
        &lt;?xml version="1.0" encoding="iso-8859-1"?> (1)

      &lt;fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format"> (2)
        &lt;fo:layout-master-set> (3)
          &lt;fo:simple-page-master master-name="my-page">
            &lt;fo:region-body margin="1in"/>
          &lt;/fo:simple-page-master>
        &lt;/fo:layout-master-set>

        &lt;fo:page-sequence master-reference="my-page"> (4)
          &lt;fo:flow flow-name="xsl-region-body"> (5)
            &lt;fo:block>Hello, world!&lt;/fo:block> (6)
          &lt;/fo:flow>
        &lt;/fo:page-sequence>
      &lt;/fo:root>
      </code>

      <olist>
        <item>This is an XML declaration. XSL FO (XSLFO) belongs to XML family, so this is obligatory.</item>
        <item>Root element. The obligatory namespace attribute declares the XSL Formatting Objects namespace.</item>
        <item>Layout master set. This element contains one or more declarations of page masters and page sequence masters â€” elements that define layouts of single pages and page sequences. In the example, I have defined a rudimentary page master, with only one area in it. The area should have a 1 inch margin from all sides of the page</item>
        <item>Page sequence. Pages in the document are grouped into sequences; each sequence starts from a new page. Master-reference attribute selects an appropriate layout scheme from masters listed inside &lt;fo:layout-master-set>. Setting master-reference to a page master name means that all pages in this sequence will be formatted using this page master.</item>
        <item>Flow. This is the container object for all user text in the document. Everything contained in the flow will be formatted into regions on pages generated inside the page sequence. Flow name links the flow to a specific region on the page (defined in the page master); in our example, it is the body region</item>
        <item>Block. This object roughly corresponds to &lt;div>` in HTML, and normally includes a paragraph of text. I need it here, because text cannot be placed directly into a flow.</item>
      </olist>

      <para>Rather than define a flo of content and then the content CSS Paged Media uses a combination of new and existing CSS elements to format the content. For example, to define default page size and then add elements to chapter pages looks like this:</para>

    <code language="css">
      @page {
        size: 8.5in 11in;
        margin: 0.5in 1in;
      /* Footnote related attributes */
      counter-reset: footnote;
      @footnote {
        counter-increment: footnote;
        float: bottom;
        column-span: all;
        height: auto;
        }
      }

      @page chapter {
      @bottom-center {
        vertical-align: middle;
        text-align: center;
        content: element(heading);
        }
      }
    </code>
  </section>

  <section type="chapter">
    <title>Tools</title>

    <para/>
  </section>

  <section type="chapter">
      <title>Further Research</title>

      <para>These are the things I want to look at after finishing mvp.</para>

      <h2>Deep Linking using Emphasis</h2>

      <para>The NYT developed a deep linking library called Emphasis (<link href="https://github.com/NYTimes/Emphasis" label="code"/> - <link href="http://open.blogs.nytimes.com/2011/01/11/emphasis-update-and-source/)" label="writeup"/>) that would allow us to create links to specific areas of our content.</para>

      <para>Downside is that it uses jQuery and I'm not certain I want to go through the pain in the ass process of converting it to plain JS or ES6 (and if it's even possible)</para>

      <para>Still, if we use jQuery for something else (video manipulation?) it may be worth exploring both as a sharing tool and as a technology.</para>

      <para>One thing it doesn't do is handle mobile well, if at all. How do we make this tool work everywhere? <link href="http://www.w3.org/TR/pointerevents/" label="Pointer Events"></link>?</para>

      <h2>Build Media Queries</h2>

      <para>Particularly if we want to use the same XSLT and CSS for mutliple projects we need to be able to tailor the display for different devices and viewports.</para>

      <para>Media Queries are the best solution (or are they?)</para>

      <h2>Using XSLT to build navigation</h2>

      <para>The same way we build the table of content should allow us to build navigation within the pages of a publication using preceeding-sibling and following-sibling logic</para>

      <h2>Create a better way to generate filenames</h2>

      <para>The current way to create filenames doesn't take into account that different `section/@type` elements have different starting values. Can I make it start from 1 for every @type in the document?</para>

      <h2>Expand the use cases for this project</h2>

      <para>The original idea was for text and code-heavy content. Is there a case to be made for a more expressive vocabulary? I'm thinking of additional elements for navigation and content display such as asides and blockquotes</para>

    </section>
</book>
