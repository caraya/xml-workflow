<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" class="no-js" lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <meta charset="utf-8" />
      <link rel="stylesheet" href="css/epub-styles.css" />
      <link rel="stylesheet" href="css/normalize.css" />
      <link rel="stylesheet" href="css/styles/github.css" /><script src="lib/highlight.pack.js"></script><script>
              hljs.initHighlightingOnLoad();
            </script></head>
   <body>
      <section epub:type="chapter">
         <h1>The XML Schema</h1>
         <blockquote>
            <p>This version of the documentation is based on commit 542178fb21 to the Github repository.
               Any differences between this document and the repository should be resolved in favor
               of the repository (repo is always right)
            </p>
         </blockquote>
         <p>The idea behind the schema is to create as clean a document as possible. The base
            document uses classes and IDs to avoid having to add styles directy to the document
            and leaving all the styling to CSS. There are 2 exceptions for addresses (discussed
            when we look at the XML to XHTML conversion.)
         </p>
         <p>We cover all the content for the schema but will only detail the things I belive are
            important to understand the choices I made and why the schema was created this way.
         </p>
         <h2>Why a schema</h2>
         <p>There are many ways to define a schema. There is the original <a href="http://www.w3.org/XML/Schema" label="XML Schema">XML Schema</a> from W3C, there is RelaxNG developed by OASIS in a <a href="https://www.oasis-open.org/committees/relax-ng/" label="technical committee">technical committee</a> and <a href="http://www.schematron.com/" label="Schematron">Schematron</a> defined as an ISO standard.
         </p>
         <p>With all these choices why did I stick with Schema?</p>
         <ul>
            <li>It's the most widely supported</li>
            <li>It can be converted to RelaxNG or Schematron (an experimental conversion to RelaxNG
               is available in the rng directory of the repository)
            </li>
         </ul>
         <p>You can work with either the Schema or RelaxNG version. This document will refer to
            the Schema.
         </p>
         <h2>Getting started</h2>
         <p>As with all XML document the schema needs to define the XML Prologue (<em>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</em>), the root element (<em>&lt;xs:schema</em>), the namespaces we'll use for the project and the default forms for elements (<em>elementFormDefault="qualified"</em>) and attributes (<em>attributeFormDefault="unqualified"</em>`)
         </p><pre><code class="xml hljs">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    elementFormDefault="qualified"
    attributeFormDefault="unqualified"&gt;
</code></pre><p>Form defaults refer to whether we need to add the namespace prefix to our default
            elements. To avoid confusion I've chosen to add namespace prefixes to all our elements
            (using `xs:` as the namespace prefix for the schema name space.) Doing that for attributes
            is unnecessary; it may not always be the case.
         </p>
         <p>We begin the actual work in the schema by defining some basic types that will be the
            basis of elements and complex types later in the schema.
         </p>
         <p>Most of the simeType elements are created by restriction. We base the element in one
            of the default Schema data types.
         </p>
         <p>For example: token255 is based on the toke schema element and is restricted to a maximum
            length of 255 characters. When this length is not enough we can use strings or other
            data types.
         </p><pre><code class="xml hljs">&lt;!-- Simple types to use in the content --&gt;
&lt;xs:simpleType name="token255"&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:maxLength value="255"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
    </code></pre><p>ISBN-type10 uses string as its base and creates a regular expression to match the
            format of <a href="http://www.isbn.org/" label="ISBN">ISBN</a> codes used to identify books worldwide.
         </p>
         <p>The ISBN element only matches one format. There are many formats that could match
            an ISBN record depending on where the book was published and which country it was
            registered in. There is a simple type element for ISBN numbers worldwide available
            at <a href="http://xfront.com/isbn.html" label="XFront">XFront</a>. The code can be incorporated to the schema at a later time.
         </p><pre><code class="xml hljs">
&lt;xs:simpleType name="ISBN-type10"&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;xs:pattern value="0-[0-1][0-9]-\d{6}-[0-9x]"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
</code></pre><p>The align simple type is an enumeration. We list all the possible values for align
            attribute so we can reference them later without having to type them all the time.
         </p><pre><code class="xml hljs">
&lt;xs:simpleType name="align"&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:enumeration value="left"/&gt;
    &lt;xs:enumeration value="center"/&gt;
    &lt;xs:enumeration value="right"/&gt;
    &lt;xs:enumeration value="justify"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
</code></pre><p>Languages are handled using an element types as the language primitive (<em>xs:language</em>.) We can use it anywhere in the schema where we are allowed to use children elements.
         </p>
         <p>Another possibility is to convert it to an attribute and move it to the generic properties
            attribute group discussed below.
         </p><pre><code class="xml hljs">
&lt;xs:element name="language" type="xs:language"/&gt;
</code></pre><p>The attribute group element adds all the attributs with one statement. As it currently
            set up, it adds id and class attributes to the elements it's been added to. A future
            enhancement may be to add the language element as an attribute.
         </p><pre><code class="xml hljs">
&lt;xs:attributeGroup name="genericPropertiesGroup"&gt;
  &lt;xs:attribute name="id" type="xs:ID" use="optional"/&gt;
  &lt;xs:attribute name="class" type="xs:token" use="optional"/&gt;
&lt;/xs:attributeGroup&gt;
</code></pre><h2>Organization and children</h2>
         <p>Initially there was no organization element until the question came up: <strong>What happens when an author is not a person but a company or group?</strong></p>
         <p>We keep the organization element as generic as possible to make sure we can use it
            in different instances. The only thing we know we'll need is the organization's name...
            everything else can be added when we build elements on top of organization (like publisher,
            discussed below.)
         </p>
         <p>Address is one of those additional elements we add to organization. Addresses are
            string based and use the U.S. model.
         </p>
         <p>Finally we build a publisher element by putting together our organization and address
            elements. Notice how the complex type and the element are called differently.
         </p><pre><code class="xml hljs">
&lt;xs:complexType name="organization"&gt;
  &lt;xs:all&gt;
    &lt;xs:element name='name' type="xs:string"/&gt;
  &lt;/xs:all&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="address"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="recipient" type="xs:string"/&gt;
      &lt;xs:element name="street" type="xs:string"/&gt;
      &lt;xs:element name="city" type="xs:string"/&gt;
      &lt;xs:element name="state" type="xs:string"/&gt;
      &lt;xs:element name="postcode" type="xs:string"/&gt;
      &lt;xs:element name="country" type="xs:token"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="publisher"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:all&gt;
      &lt;xs:element name="name" type="organization"/&gt;
      &lt;xs:element ref="address"/&gt;
    &lt;/xs:all&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Person and children elements</h2>
         <p>We now move to define individuals and their roles.</p>
         <p>The base class is person where we define a first-name and surname. We'll use this
            to create the roles for our different users with additional elements and attributes
            where necessary.
         </p><pre><code class="xml hljs">
&lt;!-- complex types to create groups of similar person items --&gt;
&lt;xs:complexType name="person"&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name="first-name" type="xs:string"/&gt;
    &lt;xs:element name="surname" type="xs:string"/&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</code></pre><p>Author, editor and otherRole use person as the base and then add additional elements
            to expand the person based on the type of editor (for the editor element) or the role
            they play in the book (for otherRole.)
         </p>
         <p>During initial develpment I thought I'd just only work with plural elements (authors,
            editors and otherRoles) but soon realized that it took a lot of flexibility out of
            the schema since there may be other places where we need this information. For example,
            we may have an edited volume where each chapter has one or more authors.
         </p>
         <p>So we have individual author (directly based on person), editor (with a <em>type</em> attribute to indicate what kind of editor the person is) and otherRole (for roles
            other than editor we use this with the <em>role</em> attribute.)
         </p><pre><code class="xml hljs">
&lt;xs:complexType name="author"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="person"/&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="editor"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="person"&gt;
      &lt;xs:choice&gt;
        &lt;xs:element name="type" type="xs:string"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="otherRole"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="person"&gt;
      &lt;xs:sequence minOccurs="1" maxOccurs="1"&gt;
        &lt;xs:element name="role" type="xs:string"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</code></pre><p>With individual roles created we can now create elements for multiple individuals.</p>
         <p>Authors can have 1 or more author elements. At least 1 author is required for the
            document to validate, whether we choose to use it or not. Remember that the transformation
            (using XSLT) doesn't have to use all the elements on the XML source.
         </p>
         <p>Editors and otherRoles wrap around individual elements (editor and otherRole) to provide
            an easier way to work with them in XSLT later on.
         </p>
         <p>Also note that we require 0 or more instances of the base type, rather than 1. This
            is my way of making the element optional: either we have zero, one or more than one
            children.
         </p><pre><code class="xml hljs">
&lt;!-- Wrappers around complext types --&gt;
&lt;xs:element name="authors"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element name="author" type="author"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="editors"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element name="editor" type="editor"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="otherRoles"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element name="otherRole" type="otherRole"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>Metadata and publishing information</p>
         <p>In order to acommodate publishing information, we add multiple publishing related
            elements to account for publishing and publishing related information.
         </p>
         <p>Most of these elements (except pubdate) are made of 1 or more paragraphs.</p><pre><code class="xml hljs">
&lt;xs:element name="releaseinfo"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="copyright"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="legalnotice"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="abstract"&gt;
  &lt;xs:complexType mixed="true"&gt;
      &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="para"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>The date is different as it's based on the date schema type which in turn it's based
            on the <a href="http://www.wikiwand.com/en/ISO_8601" label="ISO 8601">ISO 8601</a> standard.
         </p>
         <p>An example of a valid ISO 8601 date is: <em>2015-02-28</em></p>
         <p>This is also the standard that handles time so, in theory, we could build a date/time
            structure including a date formated like the example above plus time and timezone
            offset but, unless we're required to we will avoid that much level of detail.
         </p><pre><code class="xml hljs">
&lt;xs:element name="pubdate" type="xs:date"/&gt;
</code></pre><p>The idea behind revision and revhistory is to provide an accountability chain for
            the publication's history. We can have one or more paragraphs where we outline the
            following information:
         </p>
         <ul>
            <li>Revision number (cast as a string)</li>
            <li>Date (using the pubdate element defined earlier)</li>
            <li>Author's initials (short 255 character string)</li>
            <li>Revision description/notes (short 255 character string)</li>
         </ul>
         <p>The revhistory element is a set of one or more revisions. We'll use XSLT to put them
            in na div tag or inside a table structure.
         </p><pre><code class="xml hljs">
&lt;xs:element name="revision"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:all&gt;
      &lt;xs:element name="revnumber" type="xs:string"/&gt;
      &lt;xs:element ref="pubdate"/&gt;
      &lt;xs:element name="authorinitials" type="token255"/&gt;
      &lt;xs:element name="revnotes" type="token255"/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="revhistory"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="revision"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Links and related elements</h2>
         <p>Links are essential to the web. They allow us to connect our content to other elements
            inside and outside the pages we create. We add class and ID from `genericPropertiesGroup`
            and two new elements:
         </p>
         <ul>
            <li><em>href</em> indicates the URL (local or relative) we are linking to
            </li>
            <li><em>label</em> used as the text of the link and also the label attribute created for accessibility
            </li>
         </ul><pre><code class="xml hljs">
&lt;!-- Links --&gt;
&lt;xs:element name="link"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="href" type="xs:anyURI" use="required"/&gt;
    &lt;xs:attribute name="label" type="xs:string" use="required"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h3>About the xs:anyURI data type</h3>
         <blockquote>
            <p>Some information and examples for this section taken from <a href="http://www.datypic.com/sc/xsd/t-xsd_anyURI.html" label="http://www.datypic.com/sc/xsd/t-xsd_anyURI.html">http://www.datypic.com/sc/xsd/t-xsd_anyURI.html</a></p>
         </blockquote>
         <p>Unti I used the value xs:anyURI I wasn't sure what it did and how much work it would
            actually save me. I thought it was just another name for URLs but they are much more
            and the amount of work they save is significant.
         </p>
         <p>URI (uniform resource indicator) are a superset of the web's URL. There are two main
            types of URIs: absolute and relative.
         </p>
         <p>Absolute URIs provide the entire context for locating the resources, such as <strong>http://datypic.com/prod.html</strong>.
         </p>
         <p>Relative URIs are specified as the difference from a base URI, such as <strong>../prod.html</strong>. It is also possible to specify a fragment identifier, using the # character, such
            as <strong>../prod.html#shirt</strong>. Note that when relative URI references are used as values of xsd:anyURI there is
            no attempt made to track the base of the URI.
         </p>
         <p>The three previous examples happen to be HTTP URLs (Uniform Resource Locators), but
            URIs also encompass URLs of other schemes (e.g., FTP, gopher, telnet), as well as
            URNs (Uniform Resource Names). URIs doen't have to exist to be valid; there is no
            need for a resource to live at http://datypic.com/prod.html for the URI pointing to
            it to validate.
         </p>
         <p>URIs require that some characters be escaped with their hexadecimal Unicode code point
            preceded by the % character. This includes non-ASCII characters and some ASCII characters,
            namely control characters, spaces, and the following characters (unless they are used
            as deliimiters in the URI): &lt;&gt;#%{}|\^`. For example, **../édition.html** must be represented
            instead as **../%C3%A9dition.html**, with the é escaped as %C3%A9. However, the anyURI
            type will accept these characters either escaped or unescaped. With the exception
            of the characters % and #, it will assume that unescaped characters are intended to
            be escaped when used in an actual URI, although the schema processor will do nothing
            to alter them. It is valid for an anyURI value to contain a space, but this practice
            is strongly discouraged. Spaces should instead be escaped using %20.
         </p>
         <p>The schema processor is not required to parse the contents of an xsd:anyURI value
            to determine whether it is valid according to any particular URI scheme. Since the
            bare minimum rules for valid URI references are fairly generic, the schema processor
            will accept most character strings, including an empty value. The only values that
            are not accepted are ones that make inappropriate use of reserved characters, such
            as ones that contain multiple # characters or have % characters that are not followed
            by two hexadecimal digits.
         </p>
         <p>For more information on URIs, see <a href="https://www.ietf.org/rfc/rfc2396.txt" label="RFC 2396, Uniform Resource Identifiers (URI): Generic Syntax">RFC 2396, Uniform Resource Identifiers (URI): Generic Syntax</a>.
         </p>
         <p><strong>Valid URI matching xs:anyURI</strong></p>
         <ul>
            <li>http://datypic.com <strong>absolute URI (also a URL)</strong></li>
            <li>mailto:info@datypic.com <strong>absolute URI</strong></li>
            <li>../%C3%A9dition.html	<strong>relative URI containing escaped non-ASCII character</strong></li>
            <li>../édition.html	<strong>relative URI containing unescaped non-ASCII character</strong></li>
            <li>http://datypic.com/prod.html#shirt <strong>URI with fragment identifier</strong></li>
            <li>../prod.html#shirt <strong>relative URI with fragment identifier</strong></li>
            <li>urn:example:org <strong>URN</strong></li>
            <li>an empty value is allowed</li>
         </ul>
         <h2>Div and span</h2>
         <p>Div and Span are subcontainers for block level elements (div) and inline elements
            (span). As containers I have to decide what elements are allowed as children and that's
            not always easy; any time we add a new element to the schema we have to decide if
            we're using it as a block element (that can be used inside a div) and/or an inline
            element (and whether that inline element can be used inside a span.)
         </p>
         <p>The only special thing about div and span is the additional attribute type. We use
            type to build <em>data-type</em> and <em>epub:type</em> attributes. ePub and Edupub have lists of allowed values for the attribute and it's
            a good starting point for work with Javascript or additional functionality.
         </p>
         <p>Div is a subsection of our section elements. Most of the elements that we can add
            to a section are also valid inside a div, including other div elements.
         </p>
         <p>Span is used mostly to hold styles that apply to part of a paragraph and can be nested
            to build more elaborate effects and styles using class and id attributes.
         </p><pre><code class="xml hljs">
&lt;xs:element name="div"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:element ref="language"/&gt;
        &lt;xs:element ref="anchor"/&gt;
        &lt;xs:element ref="code"/&gt;
        &lt;xs:element ref="para"/&gt;
        &lt;xs:element ref="ulist"/&gt;
        &lt;xs:element ref="olist"/&gt;
        &lt;xs:element ref="figure"/&gt;
        &lt;xs:element ref="image"/&gt;
        &lt;xs:element ref="div"/&gt;
        &lt;xs:element ref="span"/&gt;
        &lt;xs:element ref="blockquote"/&gt;
        &lt;xs:element ref="video"/&gt;
        &lt;xs:element ref="aside"/&gt;
        &lt;xs:element ref="h1"/&gt;
        &lt;xs:element ref="h2"/&gt;
        &lt;xs:element ref="h3"/&gt;
        &lt;xs:element ref="h4"/&gt;
        &lt;xs:element ref="h5"/&gt;
        &lt;xs:element ref="h6"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="type" type="xs:token" use="optional"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="span"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice  minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="language"/&gt;
      &lt;xs:element ref="strong"/&gt;
      &lt;xs:element ref="emphasis"/&gt;
      &lt;xs:element ref="underline"/&gt;
      &lt;xs:element ref="strike"/&gt;
      &lt;xs:element ref="link"/&gt;
      &lt;xs:element ref="span"/&gt;
      &lt;xs:element ref="quote"/&gt;
    &lt;/xs:choice&gt;
      &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
      &lt;xs:attribute name="type" type="xs:token" use="optional"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Figure and image</h2>
         <p>Figure and image are the two ways the schema provides for working with images. Rather
            than make several elements and attributes optional and make the image elements brittle
            we allow both a figure element with caption and image children and an image without
            caption.
         </p>
         <p>Most of the time I will use the figure/caption/image combination to give a numbering
            schema when performing the transformations.
         </p><pre><code class="xml hljs">&lt;xs:element name="figure"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:all&gt;
      &lt;xs:element ref="image"/&gt;
      &lt;xs:element ref="figcaption"/&gt;
    &lt;/xs:all&gt;
    &lt;xs:attribute name="height" type="xs:nonNegativeInteger" use="optional"/&gt;
    &lt;xs:attribute name="width" type="xs:nonNegativeInteger" use="optional"/&gt;
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>Captions are made of a single paragraph with all the children available to paragraphs
            elsewhere. This way we can add links and styles to the captions.
         </p><pre><code class="xml hljs">
&lt;xs:element name="figcaption"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>One last thing to note about figures and images: Since figure and image have the same
            attributes we can combine them in different combinations. For example: we can have
            a left centered figure and caption with a right-aligned image inside.
         </p><pre><code class="xml hljs">
&lt;xs:element name="image"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="src" type="xs:token" use="required"/&gt;
    &lt;xs:attribute name="height" type="xs:nonNegativeInteger" use="required"/&gt;
    &lt;xs:attribute name="width" type="xs:nonNegativeInteger" use="required"/&gt;
    &lt;xs:attribute name="alt" type="token255" use="required"/&gt;
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Video</h2>
         <p>Video is a rather complex subject. According to the <a href="http://www.w3.org/html/wg/drafts/html/master/semantics.html#the-video-element" label="specification">specification</a> there are two ways to create video elements. I've chosen to adopt the multi-source
            element rather than a single src attribute to the video tag itself.
         </p>
         <p>We use two children element: source and track.</p>
         <p>The <em>source</em> element is for the actual video content. The element contains two attributes: <em>src</em> indicates the location of the video source. <em>Type</em> indicates the mimetype of the video and, optionally the codecs that were used to
            encode the video. This is particularly important with MP4 video as there are muliple
            "profiles" that may or may not be supported in all devices.
         </p>
         <p>At least one of source element is required.</p>
         <p>The track element is used to provide additional information to the video using the
            [VTT community specification](http://dev.w3.org/html5/webvtt/). You can use VTT to
            provide captioning and subtitles in multiple languages allowing the user to decide
            what language and what type of track they want to use with the video.
         </p>
         <p>There are other uses for VTT tracks discussed in the HTML5 video captioning article
            listed in resources.
         </p>
         <h3>Attributes for video tag</h3>
         <ul>
            <li>width — Horizontal dimension</li>
            <li>height — Vertical dimension</li>
            <li>poster — Poster frame to show prior to video playback</li>
            <li>preload — Hints how much buffering the media resource will likely need</li>
            <li>autoplay — Hint that the media resource can be started automatically when the page
               is loaded
            </li>
            <li>loop — Whether to loop the media resource</li>
            <li>muted — Whether to mute the media resource by default</li>
            <li>controls — Show user agent controls</li>
         </ul>
         <h3>Additional Resources</h3>
         <ul>
            <li><a href="http://www.w3.org/html/wg/drafts/html/master/semantics.html#the-video-element" label="HTML5 video specification">HTML5 video specification</a></li>
            <li><a href="http://dev.w3.org/html5/webvtt/" label="WebVTT Draft Community Specification">WebVTT Draft Community Specification</a></li>
            <li><a href="http://publishing-project.rivendellweb.net/video-in-epub/" label="Video in ePub">Video in ePub</a> discusses HTML5 video. While written for ePub it is also applicable to HTML5 content
               in general
            </li>
            <li><a href="http://publishing-project.rivendellweb.net/html5-video-captioning-using-vtt/" label="HTML5 video captioning using VTT">HTML5 video captioning using VTT</a> discusses captioning video using VTT tracks
            </li>
         </ul><pre><code class="xml hljs">
    &lt;!-- Video and multimedia --&gt;
    &lt;xs:element name="video"&gt;
      &lt;xs:complexType mixed="true"&gt;
        &lt;xs:choice&gt;
          &lt;xs:element ref="source" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;xs:element ref="track" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:choice&gt;
        &lt;xs:attribute name="height" type="xs:nonNegativeInteger"/&gt;
        &lt;xs:attribute name="width" type="xs:nonNegativeInteger"/&gt;
        &lt;xs:attribute name="controls" type='xs:string' use="optional"/&gt;
        &lt;xs:attribute name="poster" type="xs:anyURI" use="optional"/&gt;
        &lt;xs:attribute name="autoplay" type="xs:string" use="optional"/&gt;
        &lt;xs:attribute name="preload" type="xs:string" use="optional" default="none"/&gt;
        &lt;xs:attribute name="loop" type="xs:string" use="optional"/&gt;
        &lt;xs:attribute name="muted" type="xs:string" use="optional"/&gt;
      &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

    &lt;xs:element name="source"&gt;
      &lt;xs:complexType&gt;
        &lt;xs:attribute name="src" type='xs:string' use="required"/&gt;
        &lt;xs:attribute name="type" type='xs:string' use="optional"/&gt;
      &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

    &lt;xs:element name="track"&gt;
      &lt;xs:complexType&gt;
        &lt;xs:attribute name="src" type='xs:string' use="required"/&gt;
        &lt;xs:attribute name="label" type='xs:string' use="required"/&gt;
        &lt;xs:attribute name="kind" type='xs:string'/&gt;
        &lt;xs:attribute name="srclang" type='xs:string' default='en'/&gt;
      &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
</code></pre><h2>Styles</h2>
         <p>Styles are hints for the transformation engine to apply rules and classes to the enclosed
            elements. We allow for nested styles by indetifying what styles can nest inside each
            of our four basic styles.
         </p><pre><code class="xml hljs">
&lt;!-- Style elements --&gt;
&lt;xs:element name="strong"&gt;
  &lt;xs:complexType mixed="true"&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="emphasis"/&gt;
          &lt;xs:element ref="underline"/&gt;
          &lt;xs:element ref="strike"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="underline"&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:complexType mixed="true"&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="strong"/&gt;
          &lt;xs:element ref="emphasis"/&gt;
          &lt;xs:element ref="strike"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="strike"&gt;
  &lt;xs:complexType mixed="true"&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="strong"/&gt;
          &lt;xs:element ref="emphasis"/&gt;
          &lt;xs:element ref="underline"/&gt;
      &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>Emphasis is the only style that can be nested in itself. The idea is that if an emphasis
            element is nested inside another emphasis it will display as normal text.
         </p><pre><code class="xml hljs">&lt;xs:element name="emphasis"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="strong"/&gt;
      &lt;xs:element ref="emphasis"/&gt;
      &lt;xs:element ref="underline"/&gt;
      &lt;xs:element ref="strike"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Lists</h2>
         <p>When I originally conceived the schema I had only one list element that, based on
            a type attribute, would generate the correct type of list (numbered or bulleted.)
            as I was implementing this I trealized it was too brittle and hard to work with and
            hard to maintain.
         </p>
         <p>So I broke the element into two separate list elements; one for bulleted (<em>ulist</em>) and one for numbered (<em>olist</em>) lists. They can also nest other list elements (of either tupe) inside.
         </p><pre><code class="xml hljs">
&lt;!-- Lists --&gt;
&lt;xs:element name="ulist"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="item"/&gt;
      &lt;xs:element ref="olist"/&gt;
      &lt;xs:element ref="ulist"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="olist"&gt;
&lt;xs:complexType mixed="true"&gt;
  &lt;xs:choice minOccurs="1" maxOccurs="unbounded"&gt;
    &lt;xs:element ref="item"/&gt;
    &lt;xs:element ref="olist"/&gt;
    &lt;xs:element ref="ulist"/&gt;
  &lt;/xs:choice&gt;
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>They share a common <em>item</em> element that contains a reduced subset of the paragraph element content. We don't
            want a full paragraph in each item because they'll mess up the display when we convert
            them to HTML or PDF. We do want the ability to style the content, link or provide
            span and quotes elements.
         </p><pre><code class="xml hljs">
&lt;xs:element name="item"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice  minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="strong"/&gt;
      &lt;xs:element ref="emphasis"/&gt;
      &lt;xs:element ref="underline"/&gt;
      &lt;xs:element ref="strike"/&gt;
      &lt;xs:element ref="link"/&gt;
      &lt;xs:element ref="span"/&gt;
      &lt;xs:element ref="quote"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Fenced code blocks</h2>
         <p>I love the way Github displays fenced code blocks and wanted to get my HTML and, if
            possible, the PDF generated from XML to look similar to it. After researching the
            issue I found out code highlighting libraries for the web. The one I chose (<a href="https://highlightjs.org/" label="highlight.js">highlight.js</a>) also works with PrinceXML (with some extra work.)
         </p>
         <p>The schema defines the container for the code, the XSLT transformations, discussed
            in a later chapter, add the appropriate HTML tags and scripts to highlight the code
            and PrinceXML will honor the code highlight in the HTML and display it in the resulting
            PDF.
         </p><pre><code class="xml hljs">
    &lt;!-- Fenced code blocks --&gt;
    &lt;xs:element name="code"&gt;
        &lt;xs:complexType mixed="true"&gt;
            &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
            &lt;xs:attribute name="language" use="required"/&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
</code></pre><h2>Blockquotes, asides and marginalia</h2>
         <blockquote>
            <p>Element descriptions taken from the <a href="HTML5 nightly specification" label="http://www.w3.org/html/wg/drafts/html/master/semantics.html">http://www.w3.org/html/wg/drafts/html/master/semantics.html</a></p>
         </blockquote>
         <p>Blockquotes, asides and quotes provide related or parenthetical content.</p>
         <p>The blockquote element represents content that is quoted from another source, optionally
            with a citation which must be within a footer or cite element, and optionally with
            in-line changes such as annotations and abbreviations.
         </p>
         <p>Attribution provides a way to give credit for the quote.</p><pre><code class="xml hljs">
&lt;!-- Blockquotes, asides and marginalia --&gt;
&lt;xs:element name="attribution"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice  minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="blockquote"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="language" minOccurs="0"/&gt;
      &lt;xs:element ref="anchor"/&gt;
      &lt;xs:element ref="attribution"/&gt;
      &lt;xs:element ref="para" minOccurs="1"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>The aside element represents a section of a page that consists of content that is
            tangentially related to the content around the aside element, and which could be considered
            separate from that content. Such sections are often represented as sidebars in printed
            typography. It can be used for typographical effects like pull quotes or sidebars,
            for advertising, for groups of nav elements, and for other content that is considered
            separate from the main content of the page.
         </p>
         <p>It's not appropriate to use the aside element just for parentheticals, since those
            are part of the main flow of the document.
         </p><pre><code class="xml hljs">
&lt;xs:element name="aside"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:element ref="code"/&gt;
        &lt;xs:element ref="para" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="ulist"/&gt;
        &lt;xs:element ref="olist"/&gt;
        &lt;xs:element ref="figure"/&gt;
        &lt;xs:element ref="image"/&gt;
        &lt;xs:element ref="div"/&gt;
        &lt;xs:element ref="span"/&gt;
        &lt;xs:element ref="blockquote"/&gt;
        &lt;xs:element ref="h1"/&gt;
        &lt;xs:element ref="h2"/&gt;
        &lt;xs:element ref="h3"/&gt;
        &lt;xs:element ref="h4"/&gt;
        &lt;xs:element ref="h5"/&gt;
        &lt;xs:element ref="h6"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="type" type="xs:token" use="optional"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>The quote element represents some inline content quoted from another source.</p>
         <p>Content inside a quote element must be quoted from another source, whose address,
            if it has one, may be cited in the cite attribute. The source may be fictional, as
            when quoting characters in a novel or screenplay.
         </p>
         <p>If the cite attribute is present, it must be a valid URL potentially surrounded by
            spaces. To obtain the corresponding citation link, the value of the attribute must
            be resolved relative to the element. User agents may allow users to follow such citation
            links, but they are primarily intended for private use (e.g. by server-side scripts
            collecting statistics about a site's use of quotations), not for readers.
         </p>
         <p>The quote element must not be used in place of quotation marks that do not represent
            quotes; for example, it is inappropriate to use the quote element for marking up sarcastic
            statements.
         </p><pre><code class="xml hljs">
&lt;xs:element name="quote"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:all&gt;
      &lt;xs:element ref="language"/&gt;
    &lt;/xs:all&gt;
    &lt;xs:attribute name="cite" type="xs:anyURI" use="optional"/&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Paragraphs</h2>
         <p>The paragraph is our main unit of content and where we do most, if not all, our inline
            styling of elements (indicated by what children elements are allowed to the paragraph)
         </p>
         <p>In addition to the genericPropertiesGroup attributes, we also use align to control
            the horizontal alignment of the paragraph. This is useful when the paragraph is inside
            an attribution and I'd like the attribution to be right aligned while keeping the
            paragraph aligned to the left.
         </p><pre><code class="xml hljs">
&lt;xs:element name="para"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice  minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element ref="language"/&gt;
      &lt;xs:element ref="strong"/&gt;
      &lt;xs:element ref="emphasis"/&gt;
      &lt;xs:element ref="underline"/&gt;
      &lt;xs:element ref="strike"/&gt;
      &lt;xs:element ref="link"/&gt;
      &lt;xs:element ref="span"/&gt;
      &lt;xs:element ref="quote"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Headings</h2>
         <p>Headins should be self explainatory. They are used to indicate headings and structure
            in the document. While we only show the level 1 heading, the other levels (h2 thought
            h6) share the same structure.
         </p><pre><code class="xml hljs">
&lt;xs:element name="h1"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="align" type="align" use="optional" default="left"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Metadata element</h2>
         <p>The metadata element contains all the elements for our publication that are not content.
            Information such as copyright, legal notices, publisher, author and staff information.
         </p>
         <p>I placed it in a separate element rather than incorporate it in a section with the
            appropriate type because keeping it separate makes it easier to transfor and pick
            the order and the types of elements we'll use for each type of document we generate.
         </p>
         <p>Having a separate metadata element makes it easier to add or take away elements as
            needed.
         </p><pre><code class="xml hljs">
&lt;!-- Metadata element --&gt;
&lt;xs:element name="metadata"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
      &lt;xs:element name="isbn" type="ISBN-type10"/&gt;
      &lt;xs:element name="edition" type="xs:string"/&gt;
      &lt;xs:element ref="authors"/&gt;
      &lt;xs:element ref="editors"/&gt;
      &lt;xs:element ref="otherRoles"/&gt;
      &lt;xs:element ref="publisher"/&gt;
      &lt;xs:element ref="releaseinfo"/&gt;
      &lt;xs:element ref="copyright"/&gt;
      &lt;xs:element ref="legalnotice"/&gt;
      &lt;xs:element name="title" type="xs:string"/&gt;
      &lt;xs:element name="subtitle" type="xs:string"/&gt;
      &lt;xs:element ref="language"/&gt;
      &lt;xs:element ref="revhistory" minOccurs="0"/&gt;
      &lt;xs:element ref="para"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Section element</h2>
         <p>Sections are the primary container for our documents. It is at this level that we
            will create separate files when I start looking at multiple output.
         </p>
         <p>I also use the <em>type</em> attribute here to indicate the type of section it is. The default value for it is
            chapter since it's the one I use most often.  I've been thinking whether I want to
            create an enumeration of all the different values for type (based on epub and edupub
            profiles) to make it easier to create (oXygen gives me a list of all possible values
            for type and it currently only shows the default.)
         </p>
         <p>Other than the title element, defined as a string schema type, all other elements
            reference reference other elements in the schema.
         </p>
         <p>It derives class and id from our genericPropertiesGroup and the type attribute.</p><pre><code class="xml hljs">
&lt;!-- Section element --&gt;
&lt;xs:element name="section"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="title" type="xs:string" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
        &lt;xs:element ref="anchor"/&gt;
        &lt;xs:element ref="code"/&gt;
        &lt;xs:element ref="para" minOccurs="1" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="ulist"/&gt;
        &lt;xs:element ref="olist"/&gt;
        &lt;xs:element ref="figure"/&gt;
        &lt;xs:element ref="image"/&gt;
        &lt;xs:element ref="div"/&gt;
        &lt;xs:element ref="span"/&gt;
        &lt;xs:element ref="blockquote"/&gt;
        &lt;xs:element ref="video"/&gt;
        &lt;xs:element ref="aside"/&gt;
        &lt;xs:element ref="h1"/&gt;
        &lt;xs:element ref="h2"/&gt;
        &lt;xs:element ref="h3"/&gt;
        &lt;xs:element ref="h4"/&gt;
        &lt;xs:element ref="h5"/&gt;
        &lt;xs:element ref="h6"/&gt;
      &lt;/xs:choice&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
    &lt;xs:attribute name="type" type="xs:token" use="optional" default="chapter"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><h2>Table of contents placeholder</h2>
         <p>Even though we're generating the table of contents in the transformation stage of
            the process I still need an element to tell the script where to place the generated
            table of contents.
         </p>
         <p>Since this is a placeholder element we don't assign attributes or children elements.</p><pre><code class="xml hljs">
&lt;!-- place holder for generated toc element --&gt;
&lt;xs:element name="toc"/&gt;
</code></pre><h2>Puting it al together: The book element</h2>
         <p>The last thing to do is to put the structure of the book together. As currently outlined,
            the structure is metadata, followed by the table of contents placeholder and 1 or
            more sections where only 1 section element is required.
         </p>
         <p>The idea for making 1 section required and nothing else is that, sometimes, we're
            writing something quick where I don't really want metadata information or a table
            of contents. Since the section element already has a title I can get away with using
            only that for the document.
         </p><pre><code class="xml hljs">
&lt;!-- Base book element --&gt;
&lt;xs:element name="book"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:choice maxOccurs="unbounded"&gt;
      &lt;xs:element ref="metadata" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="toc" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xs:element ref="section" minOccurs="1" maxOccurs="unbounded"/&gt;
    &lt;/xs:choice&gt;
    &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
&lt;/xs:schema&gt;
</code></pre></section>
   </body>
</html>