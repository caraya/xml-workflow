<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" class="no-js" lang="en">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <meta charset="utf-8" />
      <link rel="stylesheet" href="css/epub-styles.css" />
      <link rel="stylesheet" href="css/normalize.css" />
      <link rel="stylesheet" href="css/styles/github.css" /><script src="lib/highlight.pack.js"></script><script>
              hljs.initHighlightingOnLoad();
            </script></head>
   <body>
      <section epub:type="chapter">
         <h1>Converting XML content to HTML</h1>
         <p>One of the biggest advantages of working with XML is that we can convert the abstract
            tags into other markups. For the purposes of this project we'll convert the XML created
            to match the schema we just created to HTML and then use tools like <a href="http://www.princexml.com" label="PrinceXML">PrinceXML</a> or <a href="http://www.antennahouse.com" label="AntenaHouse">AntenaHouse</a> we'll convert the HTML/CSS files to PDF
         </p>
         <h2>Why HTML</h2>
         <p>HTML is the default format for the web and for most web/html based content such as
            ePub and Kindle. As such it makes a perfect candidate to explore how to generate it
            programmatically from a single source file.
         </p>
         <p>HTML will also act as our source for using CSS paged media to create PDF content.</p>
         <h2>Why PDF</h2>
         <p>Rather than having to deal with <a href="http://www.w3.org/TR/2006/REC-xsl11-20061205/" label="XSL-FO">XSL-FO</a>, another XML based vocabulary to create PDF content, we'll use XSLT to create another
            HTML file and process it with <a href="http://dev.w3.org/csswg/css-page-3/" label="CSS Paged Media">CSS Paged Media</a> and the companion <a href="http://www.w3.org/TR/css-gcpm-3/" label="Generated Content for Paged Media">Generated Content for Paged Media</a> specifications to create PDF content.
         </p>
         <p>Where there is a direct equivalent between our mode and the <a href="http://www.w3.org/html/wg/drafts/html/master/sections.html" label="HTML5.1 nightly specification">HTML5.1 nightly specification</a> I've quoted the relevant section of the HTML5 spec as a reference and as a rationale
            of why I've done things the way I did.
         </p>
         <p>In this document we'll concentrate on the XSLT to HTML conversion and will defer converting
            HTML to PDF to a later article.
         </p>
         <h1>Creating our conversion style sheets</h1>
         <p>To convert our XML into other formats we will use XSL Transformations (also known
            as XSLT) <a href="http://www.w3.org/TR/xslt" label="version 2">version 2</a> (a W3C standard) and <a href="http://www.w3.org/TR/xslt-30/" label="version 3">version 3</a> (a W3C last call draft recommendation) where appropriate.
         </p>
         <p>XSLT is a functional language designed to transform XML into other markup vocabularies.
            It defines template rules that match elements in your source document and processing
            them to convert them to the target vocabulary. 
         </p>
         <p>In the XSLT template below, we do the following:</p>
         <ol>
            <li>Declare the file as an XML document</li>
            <li>Define the root element of the style sheet (xsl:stylesheet)</li>
            <li>Indicate the namespaces that we'll use in the document and, in this case, tell the
               processor to exclude the given namespace
            </li>
            <li>Strip whitespace from all elements and keep it in the code elements</li>
            <li>Create the default output we'll use for the main document and all generated pages
               (discussed later)
            </li>
            <li>Create a default template to warn us if we missed anything</li>
         </ol><pre><code class="xml hljs">
&lt;?xml version="1.0" ?&gt;
&lt;!-- Define stylesheet root and namespaces we'll work with --&gt;
&lt;xsl:stylesheet
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:epub="http://www.idpf.org/2007/opf"
  exclude-result-prefixes="dc epub"
  xml:lang="en-US"
  version="2.0"&gt;
  &lt;!-- Strip whitespace from the listed elements --&gt;
  &lt;xsl:strip-space elements="*"/&gt;
  &lt;!-- And preserve it from the elements below --&gt;
  &lt;xsl:preserve-space elements="code"/&gt;
  &lt;!-- Define the output for this and all document children --&gt;
  &lt;xsl:output name="xhtml-out" method="xhtml" indent="yes" encoding="UTF-8" omit-xml-declaration="yes" /&gt;
  &lt;xsl:template match="*"&gt;
    &lt;xsl:message terminate="no"&gt;
      WARNING: Unmatched element: &lt;xsl:value-of select="name()"/&gt;
    &lt;/xsl:message&gt;

    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</code></pre><p>This is a lot of work before we start creating our XSLT content. But it's worth doing
            the work up front. We'll see what are the advantages of doing it this way as we move
            down the style sheet.
         </p>
         <p>Now to our root templates. The first one is the entry point to our document. It performs
            the following tasks:
         </p>
         <ol>
            <li>Match the root element to create the skeleton for our HTML content</li>
            <li>We include the name and version of our XSLT processor as a meta element</li>
            <li>In the title we insert the value of the <em>metadata/title</em> element
            </li>
            <li>In the body we <em>apply</em> the templates that match the content inside our document (more on this later)
            </li>
         </ol><pre><code class="xml hljs">
&lt;xsl:template match="book"&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;xsl:element name="title"&gt;
      &lt;xsl:value-of select="metadata/title"/&gt;
    &lt;/xsl:element&gt;
    &lt;xsl:element name="meta"&gt;
      &lt;xsl:attribute name="generator"&gt;
        &lt;xsl:value-of select="system-property('xsl:product-name')"/&gt;
        &lt;xsl:value-of select="system-property('xsl:product-version')"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:element&gt;
    &lt;link rel="stylesheet" href="css/style.css" /&gt;
    &lt;xsl:if test="(code)"&gt;
      &lt;link rel="stylesheet" href="css/styles/docco.css" /&gt;
      &lt;!-- Load highlight.js --&gt;
      &lt;script src="lib/highlight.pack.js"&gt;&lt;/script&gt;
      &lt;script&gt;
        hljs.initHighlightingOnLoad();
      &lt;/script&gt;
    &lt;/xsl:if&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:apply-templates select="/" mode="toc"/&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</code></pre><p>We could build the CSS style sheet and JavaScript files as part of our root template
            but we chose not to.
         </p>
         <p>Working with the style sheet as part of the XSLT style sheet allows the XSLT stylesheet
            designer to embed the style and parametrize the stylesheet, thus making the stylesheet
            customizable from the command line.
         </p>
         <p>For all advantages, this method ties the styles for the project to the XSLT stylesheet
            and requires the XSLT stylesheet designer to remain involved in all CSS and JavaScript
            updates.
         </p>
         <p>By linking to external CSS and JavaScript files we can leverage expertise independent
            of the Schema and XSLT style sheets. Book designers can work on the CSS, UX and experience
            designers can work on JavaScript and other CSS areas, book designers can work on the
            Paged Media style sheets and authors can just write.
         </p>
         <p>Furthermore we can reuse our CSS and JavaScript on multiple documents.</p>
         <h2>Table of contents</h2>
         <p>There is a second template matching the root element of our document to create a table
            of content. At first thought this looks like the wrong approach 
         </p>
         <p>We leverage XSLT modes that allow us to create templates for the same element to perform
            different tasks. In <em>toc mode</em> we want the root template to do the following:
         </p>
         <ol>
            <li>Create the document that will hold the table of content</li>
            <li>Build the HTML document</li>
            <li>Create the sectiion and assign its data-type attribute</li>
            <li>Add the title for the table of contents</li>
            <li>For each section element that is a child of root create these elements</li>
            <ol>
               <li>The <em>li</em> element
               </li>
               <li>The a element with the corresponding href element</li>
               <li>The href attribute</li>
               <li>The value of the href attribute (a concatenation of the section's type attribute,
                  the position within the document and the .html string)
               </li>
               <li>The title of the section as the 'clickable' portion of the link</li>
            </ol>
         </ol><pre><code class="xml hljs">
&lt;xsl:template match="/" mode="toc"&gt;
  &lt;xsl:result-document href='toc.html' format="xhtml-out"&gt; (1)
    &lt;html&gt; (2)
      &lt;head&gt;
        &lt;link rel="stylesheet" href="css/style.css" /&gt;
        &lt;!-- Load Normalize library --&gt;
        &lt;link rel="stylesheet" href="css/normalize.css"/&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;section data-type="toc"&gt; (3)
          &lt;h2&gt;Table of Contents&lt;/h2&gt; (4)
          &lt;nav&gt;
            &lt;ol&gt;
              &lt;xsl:for-each select="//section"&gt; (5)
                &lt;xsl:element name="li"&gt; (5.1)
                  &lt;xsl:element name="a"&gt; (5.2)
                    &lt;xsl:attribute name="href"&gt; (5.3)
                      &lt;xsl:value-of select="concat(@type, position(),'.html')"/&gt; (5.4)
                    &lt;/xsl:attribute&gt;
                    &lt;xsl:value-of select="title"/&gt; (5.5)
                  &lt;/xsl:element&gt;
                &lt;/xsl:element&gt;
              &lt;/xsl:for-each&gt;
            &lt;/ol&gt;
          &lt;/nav&gt;
        &lt;/section&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
</code></pre><h2>Metadata and Section</h2>
         <p>With these templates in place we can now start writing the major areas of the document,
            <em>metadata</em> and <em>section</em>. 
         </p>
         <h3>Metadata</h3>
         <p>The metadata is a container for all the elements inside. As such we just create the
            section that will hold the content and call `xsl:apply-templates` to process the children
            inside the metadata element using the apply-template XSLT instruction. The template
            looks like this
         </p><pre><code class="xml hljs">
&lt;xsl:template match="metadata"&gt;
  &lt;xsl:element name="section"&gt;
    &lt;xsl:attribute name="data-type" select="'metadata'"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Section</h3>
         <p>The section template, on the other hand, is more complex because it has a lot of work
            to do. It is our primary unit for generating content fifiles, takes most of the same
            attributes as the root template and then processes the rest of the content.
         </p>
         <p>Inside the template we first create a vairable to hold the name of the file we'll
            generate. The file name is a concatenation of the following elements:
         </p>
         <ul>
            <li>The type attribute</li>
            <li>The position in the document</li>
            <li>the string ".html"</li>
         </ul>
         <p>The result-document element takes two parameters: the value of the file name variable
            we just defined and the xhtml-out format we defined at the top of the document. The
            XHTML format may look like overkill right now but it makes sense when we consider
            moving the generated content to ePub or other fomats where strict XHTML conformance
            is a requirement. 
         </p>
         <p>We start generating the skeleton of the page, we add the default style sheet and 
            do the first conditional test of the document. Don't want to add stylesheets to the
            page unless they are needed so we test if there is a code element on the page and
            only add highlight.js related stylesheets and scripts.
         </p>
         <p>In the body element we add a section element, the main wrapper for our content.</p>
         <p>For the section we conditionally add attributes to the element. We use only add a
            data-type attribute to body if there is a type attribute in the source document. We
            do the same thing for id and class.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="section"&gt;
  &lt;!-- Variable to create section file names --&gt;
  &lt;xsl:variable name="fileName" select="concat((@type), (position()-1),'.html')"/&gt;
  &lt;!-- An example result of the variable above would be introduction1.xhtml --&gt;
  &lt;xsl:result-document href='{$fileName}' format="xhtml-out"&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;link rel="stylesheet" href="css/style.css" /&gt;
        &lt;xsl:if test="(code)"&gt;
          &lt;link rel="stylesheet" href="css/styles/docco.css" /&gt;
          &lt;!-- Load highlight.js --&gt;
          &lt;script src="lib/highlight.pack.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            hljs.initHighlightingOnLoad();
          &lt;/script&gt;
        &lt;/xsl:if&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;section&gt;
          &lt;xsl:if test="string(@type)"&gt;
            &lt;xsl:attribute name="data-type"&gt;
              &lt;xsl:value-of select="@type"/&gt;
            &lt;/xsl:attribute&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="string(@class)"&gt;
            &lt;xsl:attribute name="class"&gt;
              &lt;xsl:value-of select="@class"/&gt;
            &lt;/xsl:attribute&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:if test="string(@id)"&gt;
            &lt;xsl:attribute name="id"&gt;
              &lt;xsl:value-of select="@id"/&gt;
            &lt;/xsl:attribute&gt;
          &lt;/xsl:if&gt;
          &lt;xsl:apply-templates/&gt;
        &lt;/section&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
</code></pre><h2>Metadata content</h2>
         <p>Since the style sheets were oginally written I've added more content to the metadata
            element to acommodate different publishing requirements. The first additional element
            I've added is publisher, an organization or person that has a name (pubname element)
            and an address (modeled after a United States address)
         </p>
         <p>Most of the metadata templates use two conditional statements. The first one tests
            to see if the author gave the element a class attribute. If there is one, we use that
            as the value of the class attribute, otherwise we assign a default value based on
            the element name or its function.
         </p>
         <p>The second test is simple. If there is an ID attribute use it as the value for the
            ID attribute, otherwise leave it blank. 
         </p>
         <p>I coded it this way because of the difference in using classes versus ID values. </p>
         <p>Unless you're using the IDs to structure your content there is no real reason to use
            IDs instead of classes. The consensus is to avoid IDs as much as possible as explained
            in the <a href="https://github.com/CSSLint/csslint/wiki/Disallow-IDs-in-selectors" label="CSSLint rule that disallows IDs in selectors">CSSLint rule that disallows IDs in selectors</a></p>
         <p>With two different classes I'm also giving content creators the flexibility of either
            using the default CSS (or no CSS at all) or create their own CSS for the metadata
            element, the choice is yours.
         </p><pre><code class="xml hljs">
  &lt;xsl:template match="publisher"&gt;
    &lt;xsl:element name="div"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="string(@class)"&gt;
          &lt;xsl:attribute name="class" select="@class"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:attribute name="class" select="'publisher'"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:if test="string(@id)"&gt;
        &lt;xsl:attribute name="id"&gt;
          &lt;xsl:value-of select="@id"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:if&gt;
        &lt;xsl:value-of select="name"/&gt;
        &lt;xsl:apply-templates select="address"/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:template&gt;
</code></pre><p>Right now the address is a list of paragraphs with the information of the children
            elements. We may change the structure to a single paragraphy with span elements to
            indicate where each child element happens. I'm not 100% sure which way is better.
         </p><pre><code class="xml hljs">
  &lt;xsl:template match="address"&gt;
    &lt;xsl:element name="div"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="string(@class)"&gt;
          &lt;xsl:attribute name="class" select="@class"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:attribute name="class" select="'address'"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="recipient"/&gt;&lt;/xsl:element&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="street"/&gt;&lt;/xsl:element&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="city"/&gt;&lt;/xsl:element&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="state"/&gt;&lt;/xsl:element&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="postcode"/&gt;&lt;/xsl:element&gt;
      &lt;xsl:element name="p"&gt;&lt;xsl:value-of select="country"/&gt;&lt;/xsl:element&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:template&gt;
</code></pre><p>These elements: releaseinfo, copyright, legal notice, pubdate and abstract share a
            similar structure so, instead of creating one template we match all of them and we
            do a little magic. We replace the class name in the otherwise clause and use the name()
            xpath expression that will match the name of the element that matched the template.
         </p><pre><code class="xml hljs">
  &lt;xsl:template match="releaseinfo | copyright | legalnotice | pubdate | abstract"&gt;
  &lt;xsl:element name="div"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="string(@class)"&gt;
        &lt;xsl:attribute name="class" select="@class"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:attribute name="class" select="name()"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p>The revhistory and revisions attribute provides a way to do authority and change tracking.
            I'm still working on these templates. As they are right now they are paragraphs inside
            a div inside another div holding the full history.
         </p>
         <p>Normally I'd consider using a table but want to explore other options before I do
            so.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="revhistory"&gt;
  &lt;xsl:element name="div"&gt;
    &lt;xsl:attribute name="class" select="'revhistory'"/&gt;
    &lt;xsl:value-of select="revision"/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="revision"&gt;
  &lt;xsl:element name="div"&gt;
    &lt;xsl:attribute name="class" select="'revision'"/&gt;
    &lt;p&gt;&lt;xsl:value-of select="revnumber"/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;xsl:value-of select="pubdate"/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;xsl:value-of select="authorinitials"/&gt;&lt;/p&gt;
    &lt;p&gt;&lt;xsl:value-of select="revnotes"/&gt;&lt;/p&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p>For authors we do the following:</p>
         <ol>
            <li>For each individual in the group we take the first name and the surname</li>
            <li>Wrap the name around an li element to build an unnumbered list. We can style the list
               with CSS later
            </li>
         </ol>
         <p>For editors and other roles we do the same thing</p>
         <ol>
            <li>For each individual in the group we take the first name and the surname</li>
            <li>We concatenate the type/role to create a full title (production editor for example)</li>
            <li>Wrap the name and the title with an li element that we can style with CSS later</li>
         </ol><pre><code class="xml hljs">
&lt;xsl:template match="metadata/authors"&gt;
  &lt;h2&gt;Authors&lt;/h2&gt;
  &lt;ul&gt;
    &lt;xsl:for-each select="author"&gt;
      &lt;li&gt;
        &lt;xsl:value-of select="first-name"/&gt;
        &lt;xsl:text&gt; &lt;/xsl:text&gt;
        &lt;xsl:value-of select="surname"/&gt;
      &lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;
</code></pre><pre><code class="xml hljs">
&lt;xsl:template match="metadata/editors"&gt;
  &lt;h2&gt;Editorial Team&lt;/h2&gt;
  &lt;ul class="no-bullet"&gt;
    &lt;xsl:for-each select="editor"&gt;
      &lt;li&gt;
        &lt;xsl:value-of select="first-name"/&gt;
        &lt;xsl:text&gt; &lt;/xsl:text&gt;
        &lt;xsl:value-of select="surname"/&gt;
        &lt;xsl:value-of select="concat(' - ', type, ' ', 'editor')"/&gt;
      &lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;
</code></pre><pre><code class="xml hljs">
&lt;xsl:template match="metadata/otherRoles"&gt;
  &lt;h2&gt;Production team&lt;/h2&gt;
  &lt;ul class="no-bullet"&gt;
    &lt;xsl:for-each select="otherRole"&gt;
      &lt;li&gt;
        &lt;xsl:value-of select="first-name" /&gt;
        &lt;xsl:text&gt; &lt;/xsl:text&gt;
        &lt;xsl:value-of select="surname" /&gt;
        &lt;xsl:text&gt; - &lt;/xsl:text&gt;
        &lt;xsl:value-of select="role" /&gt;
      &lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Titles and headings</h3>
         <p>Headings are primarily used to create sections of content. We use the same heading
            levels as HTML with the addition of a <em>title</em> tag that also maps to a level 1 heading. We've put <em>title</em> and <em>h1</em> in separate templates to make it possible and easier to generate different code for
            each heading.
         </p>
         <p>Working with XSLT is not the same as using CSS where you can declare rules for the
            same attribute multiple times (with the last one winning); when writing transformations
            you can only have one per element otherwise you will get an error or a different result
            to the one you expected.
         </p>
         <p>According to the spec:</p>
         <blockquote>
            <p>These elements [h1 to h6] represent headings for their sections.</p>
            <p>The semantics and meaning of these elements are defined in the section on headings
               and sections.
            </p>
            <p>These elements have a rank given by the number in their name. The h1 element is said
               to have the highest rank, the h6 element has the lowest rank, and two elements with
               the same name have equal rank.
            </p>
            <p>h1â€“h6 elements must not be used to markup subheadings, subtitles, alternative titles
               and taglines unless intended to be the heading for a new section or subsection. Instead
               use the markup patterns in the <a href="http://www.w3.org/html/wg/drafts/html/master/common-idioms.html#common-idioms" label="Common idioms without dedicated elements">Common idioms without dedicated elements</a> section of the specification.
            </p><cite>
               <p><strong><em>- 4.3.6 The h1, h2, h3, h4, h5, and h6 elements, Berjon et al. 2013</em></strong></p></cite></blockquote>
         <p>All elements have the same attribute set: align, class and id.</p>
         <p>The remaining headings, h2 through h6, all have the same attributes and the templates
            are structured the same way.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="title "&gt;
  &lt;xsl:element name="h1"&gt;
    &lt;xsl:if test="@align"&gt;
      &lt;xsl:attribute name="align"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Blockquotes, quotes and asides</h3>
         <p>Blockquotes, asides and quotes provide sidebar-like content on our document. According
            to the W3C:
         </p>
         <blockquote>
            <p>The blockquote element represents content that is quoted from another source, *optionally*
               with a citation which must be within a footer or cite element, and *optionally* with
               in-line changes such as annotations and abbreviations.
            </p>
            <p>Content inside a blockquote other than citations and in-line changes *must* be quoted
               from another source, whose address, if it has one, *may* be cited in the cite attribute.
               [emphasis mine]
            </p><cite>
               <p><strong><em>- 4.51 the Blockquote element , Berjon et al. 2013</em></strong></p></cite></blockquote>
         <p>The cite HTML provides attribution to the blockquote it is used in. To prevent confusion
            and to make it's meaning clear the document model uses the <em>attribution</em> tag instead, their purpose is identical and during the transformation the attribution
            will become a <em>cite</em> element. According to spec:
         </p>
         <blockquote>
            <p>The cite element represents a reference to a creative work. It must include the title
               of the work or the name of the author (person, people or organization) or an URL reference,
               which may be in an abbreviated form as per the conventions used for the addition of
               citation metadata.
            </p>
            <p><strong><em>- 4.51 the Cite element , Berjon et al. 2013</em></strong></p>
         </blockquote><pre><code class="xml hljs">
&lt;xsl:template match="blockquote"&gt;
  &lt;xsl:element name="blockquote"&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates /&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;!-- BLOCKQUOTE ATTRIBUTION--&gt;
&lt;xsl:template match="attribution"&gt;
  &lt;xsl:element name="cite"&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p>The <em>q</em> element is the inline equivalent to `blockquote` and has been replaced in our markup
            by the <em>quote</em> element. As stated in the HTML5 specification:
         </p>
         <blockquote>
            <p>The q element represents some phrasing content quoted from another source.</p>
            <p>Quotation punctuation (such as quotation marks) that is quoting the contents of the
               element must not appear immediately before, after, or inside q elements; they will
               be inserted into the rendering by the user agent.
            </p>
            <p>Content inside a q element must be quoted from another source, whose address, if it
               has one, may be cited in the cite attribute. The source may be fictional, as when
               quoting characters in a novel or screenplay.
            </p>
            <p>If the cite attribute is present, it must be a valid URL potentially surrounded by
               spaces. To obtain the corresponding citation link, the value of the attribute must
               be resolved relative to the element. User agents may allow users to follow such citation
               links, but they are primarily intended for private use (e.g. by server-side scripts
               collecting statistics about a site's use of quotations), not for readers.
            </p>
            <p>The q element must not be used in place of quotation marks that do not represent quotes;
               for example, it is inappropriate to use the q element for marking up sarcastic statements.
            </p>
            <p>The use of q elements to mark up quotations is entirely optional; using explicit quotation
               punctuation without q elements is just as correct.
            </p>
            <p><strong><em>- 4.5.7 The q element, Berjon et al. 2013</em></strong></p>
         </blockquote><pre><code class="xml hljs">
&lt;xs:element name="quote"&gt;
&lt;xs:complexType mixed="true"&gt;
  &lt;xs:attribute name="cite" type="xs:anyURI" use="optional"/&gt;
  &lt;xs:attributeGroup ref="genericPropertiesGroup"/&gt;
&lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre><p>Asides are primarily used for content realted to the main flow of the document. I
            use it mostly for notes indirectly related to the main content, for example, to explain
            that there are other ways to generate Schemas apart from W3C's Schema. It is good
            to know this but it won't change the information in the main content flow.
         </p>
         <p>Per Spec:</p>
         <blockquote>
            <p>The aside element represents a section of a page that consists of content that is
               tangentially related to the content around the aside element, and which could be considered
               separate from that content. Such sections are often represented as sidebars in printed
               typography.
            </p>
            <p>The element can be used for typographical effects like pull quotes or sidebars, for
               advertising, for groups of nav elements, and for other content that is considered
               separate from the main content of the page.
            </p><cite>
               <p><strong><em>- 4.3.5 The aside element, Berjon et al. 2013</em></strong></p></cite></blockquote><pre><code class="xml hljs">
&lt;xsl:template match="aside"&gt;
  &lt;aside&gt;
    &lt;xsl:if test="type"&gt;
      &lt;xsl:attribute name="data-type"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/aside&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Div and Span</h3>
         <p>div and span elements are neutral, they don't have meaning on their onw but they can
            get their meaning from attributes such as <em>class</em>, <em>data-*</em>, and <em>id</em>. Divs are meant as block level elements and siblings or children to sections where
            `span` is used inline, like a child to our <em>para</em> elements.
         </p>
         <p>According to the specification:</p>
         <blockquote>
            <p>The div element has no special meaning at all. It represents its children. It can
               be used with the class, lang, and title attributes to mark up semantics common to
               a group of consecutive elements.
            </p>
            <p>Authors are strongly encouraged to view the div element as an element of last resort,
               for when no other element is suitable. Use of more appropriate elements instead of
               the div element leads to better accessibility for readers and easier maintainability
               for authors.
            </p><cite>
               <p><strong><em>- 4.4.14 The div element, Berjon et al. 2013</em></strong></p></cite></blockquote><pre><code class="xml hljs">
&lt;xsl:template match="div"&gt;
  &lt;xsl:element name="div"&gt;
    &lt;xsl:if test="@align"&gt;
      &lt;xsl:attribute name="align"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p>The span element on its own is meaningless. We can give it meaning with the attributes
            we pass to it. We can give it a class or id for CSS styling or a type to generate
            semantic meaning for the contained text.
         </p>
         <p>When we start working on an ePub implementation we can also add the epub:type attribute
            to create an even more detailed semantic map of our content.
         </p>
         <blockquote>
            <p>The span element doesn't mean anything on its own, but can be useful when used together
               with the global attributes, e.g. class, lang, or dir. It represents its children.
            </p><cite>
               <p><strong><em>- 4.5.28 The span element, Berjon et al. 2013</em></strong></p></cite></blockquote><pre><code class="xml hljs">
&lt;xsl:template match="span"&gt;
  &lt;xsl:element name="span"&gt;
    &lt;xsl:if test="@type"&gt;
      &lt;xsl:attribute name="data-type"&gt;
        &lt;xsl:value-of select="@type"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Paragraphs</h3>
         <p>The paragraph is our basic unit of content. Paragraphs are usually represented as
            blocks of text but they can be styled anyway we choose with the proper CSS.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="para"&gt;
  &lt;xsl:element name="p"&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><h3>Styles</h3>
         <p>Styles are used to indicate typograhical styles such as strong, emphsis, strikethrough
            and underline.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="strong"&gt;
  &lt;strong&gt;&lt;xsl:apply-templates /&gt;&lt;/strong&gt;
&lt;/xsl:template&gt;
</code></pre><p>Since we're working with print and visual media only we use only <em>strong</em> to indicate bold elements. I've never understood how do strong and <em>b</em> work in screen and printed pages or in screen displays.
         </p>
         <p>May have to implement <em>b</em> when developing the accessibility component for the document schema.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="emphasis"&gt;
  &lt;em&gt;&lt;xsl:apply-templates/&gt;&lt;/em&gt;
&lt;/xsl:template&gt;
</code></pre><p>As with strong, I've decided to only use <em>emphasis</em> to indicate italics and save `<em>i</em>` for a future revision when, and if, it becomes necessary. 
         </p><pre><code class="xml hljs">
&lt;xsl:template match="strike"&gt;
  &lt;strike&gt;&lt;xsl:apply-templates/&gt;&lt;/strike&gt;
&lt;/xsl:template&gt;
</code></pre><p>Although the strikethrough element has been deprecated in the HTML5 standard, it's
            still worth having as it can also be the target for CSS that accomplishes the same
            goal.
         </p>
         <p>The CSS way is to assign a <em>text-decoration: line-through</em> instruction to the strike selector.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="underline"&gt;
  &lt;u&gt;&lt;xsl:apply-templates/&gt;&lt;/u&gt;
&lt;/xsl:template&gt;
</code></pre><p>While there is a <em>u</em> element it has different semantics than underline. Like strike the correct way to
            do it is with CSS; in this case using `text-decoration: underlike` for the chosen
            element.
         </p>
         <h2>Links</h2>
         <p>Links are the essence of the web. They allow you to navigate within the document you're
            in or move to external documents. I've taken shortcuts and made the label attribute
            (used for accessibility) and the content of the link the same text. This reduced the
            ammount of typing we have to do but run the risk of becoming too inflexible.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="link"&gt;
  &lt;xsl:element name="a"&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:attribute name="href"&gt;
      &lt;xsl:value-of select="@href"/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="label"&gt;
      &lt;xsl:value-of select="@label"/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:value-of select="@label"/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p>When working with links there are times when we want to link to sections within the
            same document or to specific sections in another document or to specific sections
            inside a paragraph or to a figure. To do this we need anchors that will resolve to
            the following HTML:
         </p><pre><code class="html hljs">
&lt;a id="#target"&gt;&lt;a&gt;
</code></pre><p>Since all our structural elements can have an id, it's better to target the id in
            the element rather than create a separate element to link to. Because we have the
            facilitie to accomplish the same task I've removed the anchor element from the document
            model.
         </p>
         <h2>Code blocks</h2>
         <p>Code elements create <a href="https://help.github.com/articles/github-flavored-markdown/#fenced-code-blocks" label="fenced code blocks">fenced code blocks</a> like the ones from <a href="https://help.github.com/articles/github-flavored-markdown/" label="Github Flavored Markdown">Github Flavored Markdown</a>. 
         </p>
         <p>We use <a href="https://www.google.com/fonts/specimen/Source+Code+Pro" label="Adobe Source Code Pro">Adobe Source Code Pro</a> font. It's a clean and readable font designed specifically for source code display.
         </p>
         <p>We highlight our code with <a href="https://highlightjs.org/" label="Highlight.js">Highlight.js</a>. This makes the class attribute mandatory as we need it to tell highlight.js what
            syntax library to use
         </p><pre><code class="xml hljs">
&lt;xsl:template match="code"&gt;
  &lt;xsl:element name="pre"&gt;
    &lt;xsl:element name="code"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@language"/&gt;
      &lt;/xsl:attribute&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><h2>Lists and list items</h2>
         <p>When I first conceptualized this project I had designed a single list element and
            attributes to produce bulleted and numbered lists. This proved to difficult to implement
            so I went back to two separate elements: <em>ulist</em> for bulleted lists and <em>olist</em> for  numbered lists. 
         </p>
         <p>Both elements share the <em>item</em> element to indicates the items inside the list. At least one item is required a list.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="ulist"&gt;
  &lt;xsl:element name="ul"&gt;
    &lt;xsl:if test="string(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="string(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="olist"&gt;
  &lt;xsl:element name="ol"&gt;
    &lt;xsl:if test="string(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="string(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="item"&gt;
  &lt;xsl:element name="li"&gt;
    &lt;xsl:if test="string(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="string(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre><p></p>
         <h2>Figures and Images</h2>
         <blockquote>
            <p>The figure element represents some flow content, optionally with a caption, that is
               self-contained (like a complete sentence) and is typically referenced as a single
               unit from the main flow of the document.
            </p>
            <p>The element can thus be used to annotate illustrations, diagrams, photos, code listings,
               etc.
            </p>
            <p>A figure element's contents are part of the surrounding flow. If the purpose of the
               page is to display the figure, for example a photograph on an image sharing site,
               the figure and figcaption elements can be used to explicitly provide a caption for
               that figure. For content that is only tangentially related, or that serves a separate
               purpose than the surrounding flow, the aside element should be used (and can itself
               wrap a figure). For example, a pull quote that repeats content from an article would
               be more appropriate in an aside than in a figure, because it isn't part of the content,
               it's a repetition of the content for the purposes of enticing readers or highlighting
               key topics.
            </p><cite>
               <p><strong><em>-  4.4.11 The figure element, Berjon et al. 2013</em></strong></p></cite></blockquote>
         <p>Figures, captions and the images inside present a few challenges. Because we allow
            authors to set height and width on both figure and the image inside we may find situations
            where the figure container is narrower than the image inside.
         </p>
         <p>To avoid this issue we test whether the figure width value is smaller than the width
            of the image inside. If it is, we use the width of the image as the width of the figure,
            otherwise we use the width of the image inside.
         </p>
         <p>We do the same thing for height in order to avoid squished images of captions that
            draw over the image because it's too small. If the height of the figure is smaller
            than the height of the image we use the height of the image, otherwise we use the
            height of the figure element.
         </p>
         <p>For both height and width we concatenate the attribute value with the string 'px'
            to make sure that it works in both straight CSS and with Prince and other CSS PDF
            generators
         </p>
         <p>Alignments can be different, it is possible to have a right-aligned image to live
            inside a centered container.
         </p>
         <p>Contrary to the HTML specification we use figure only to display images. We have a
            specialized template to address code blocks for program listings and can create additional
            elements
         </p><pre><code class="xml hljs">
&lt;xsl:template match="figure"&gt;
  &lt;xsl:element name="figure"&gt;
    &lt;xsl:if test="string(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="string(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="string(width) and (@width lt image/@width)"&gt;
        &lt;xsl:attribute name="width"&gt;
          &lt;xsl:value-of select="@width"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:attribute name="width"&gt;
          &lt;xsl:value-of select="image/@width"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="string(@height) and (@height lt image/@height)"&gt;
        &lt;xsl:attribute name="width"&gt;
          &lt;xsl:value-of select="@height"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:attribute name="width"&gt;
          &lt;xsl:value-of select="image/@height"/&gt;
        &lt;/xsl:attribute&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:if test="(@align)"&gt;
      &lt;xsl:attribute name="align"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="image"/&gt;
    &lt;xsl:apply-templates select="figcaption"/&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="figcaption"&gt;
  &lt;figcaption&gt;&lt;xsl:apply-templates/&gt;&lt;/figcaption&gt;
&lt;/xsl:template&gt;
</code></pre><p>The data model for our content allows both figures and images to be used in the document.
            This is so we don't have to insert empty captions to figures just so we can add an
            image. If we don't want a caption we can insert the image directly on our document.
         </p><pre><code class="xml hljs">
&lt;xsl:template match="image"&gt;
  &lt;xsl:element name="img"&gt;
    &lt;xsl:attribute name="src"&gt;
      &lt;xsl:value-of select="@src"/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="alt"&gt;
      &lt;xsl:value-of select="@alt"/&gt;
    &lt;/xsl:attribute&gt;
    &lt;xsl:if test="(@width)"&gt;
      &lt;xsl:attribute name="width"&gt;
        &lt;xsl:value-of select="@width"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@height)"&gt;
      &lt;xsl:attribute name="height"&gt;
        &lt;xsl:value-of select="@height"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@align)"&gt;
      &lt;xsl:attribute name="align"&gt;
        &lt;xsl:value-of select="@align"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@class)"&gt;
      &lt;xsl:attribute name="class"&gt;
        &lt;xsl:value-of select="@class"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="(@id)"&gt;
      &lt;xsl:attribute name="id"&gt;
        &lt;xsl:value-of select="@id"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;
</code></pre></section>
   </body>
</html>